// in order to be able to cherry pick modules instead of using the full package, the paths must be separated
angular.module('Realize.core.paths', ['Realize.core.configs.SCRIPT_PATH'])
    .provider('REALIZE_CORE_ROOT_PATH', function() {
        return {
            $get: ['SCRIPT_PATH',
                function(SCRIPT_PATH) {
                    return SCRIPT_PATH + '/realize.core';
                }
            ]
        };
    });

// define module to house pre-cached templates
// in order to cherry pick, each module that has a (external) template should have this as a dependency
angular.module('Realize.core.templates', ['Realize.core.paths']);

// todo: deprecated!  no need to do a rollup of these modules.. an individual app can do that themselves if they desier
// convience rollup of complete package
angular.module('Realize.core', [
    'Realize.core.paths',
    'Realize.core.templates',
    'Realize.core.legacyApiSupport',
    'Realize.core.sessionTimeoutInterceptor',
    'Realize.core.directives.htmlUnsafe',
    'Realize.core.filters.fileSize',
    'Realize.core.filters.toArray',
    'Realize.core.filters.capitalizeFirstWord',
    'Realize.core.filters.letterizeNumber',
    'Realize.core.filters.getExtension',
    'Realize.core.filters.removeExtension',
    'Realize.core.filters.underscores',
    'Realize.core.filters.contains',
    'Realize.core.filters.trunc',
    'Realize.core.filters.nospace',
    'Realize.core.filters.ellipses',
    'Realize.core.filters.brStrip',
    'Realize.core.filters.replace',
    'Realize.core.filters.localize',
    'Realize.core.filters.coerce',
    'Realize.core.filters.handleEmptyResponse',
    'Realize.core.services.browserInfo',
    'Realize.core.services.debounce',
    'Realize.core.services.log',
    'Realize.core.services.messages',
    'Realize.core.services.rumbaDataService',
    'Realize.core.services.user',
    'Realize.core.services.userSvc',
    'Realize.core.services.isodate',
    'Realize.core.services.accessibility',
    'Realize.core.services.filesystem'
]);;angular.module('Realize.core.directives.htmlUnsafe', [])
.directive('ngBindHtmlUnsafe', ['$sce', '$log', '$parse', function($sce, $log, $parse) {
        return {
            link: function(scope, element, attrs) {
                element.addClass('ng-binding').data('$binding', attrs.ngBindHtmlUnsafe);

                var parsed = $parse(attrs.ngBindHtmlUnsafe);
                function getStringValue() { return (parsed(scope) || '').toString(); }

                scope.$watch(getStringValue, function ngBindHtmlUnsafeWatchAction(value) {
                    element.html(value);
                });
            }
        };
    }
]);;angular.module('Realize.core.filters.brStrip', [])
    .filter('brStrip', ['$log',
        function($log) {
            return function(input) {
                var output;
                try {
                    output = input.replace(/<br\s*\/?\s*>/g, "");
                } catch (e) {
                    $log.warn("the question/response text is not valid!!", input);
                    output = input;
                }

                return (output);
            };
        }
    ]);;angular.module('Realize.core.filters.capitalizeFirstWord', [])
/*
 * Filter to capitalize the first word of the given string.
 **/
.filter("capitalizeFirstWord", function() {
    return function(input) {
        return input.charAt(0).toUpperCase() + input.substr(1).toLowerCase();
    };
});;angular.module('Realize.core.filters.coerce', [])
    .filter("coerce", [
        '$log',
        '$injector',
        function($log, $injector) {

            return function(data, EntityType_in) {

                if(angular.isUndefined(data) || angular.isUndefined(EntityType_in)) {
                    return;
                }

                var returnData = [],
                    EntityType = angular.isFunction(EntityType_in) ? EntityType_in : $injector.get(EntityType_in);

                if(!EntityType) {
                    return;
                }

                // if it is an array of objects convert each one
                if (angular.isArray(data)) {
                    angular.forEach(data, function(d) {
                        returnData.push(new EntityType(d));
                    });

                    return returnData;
                } else {
                    return new EntityType(data);
                }
            };

        }
    ]);;angular.module('Realize.core.filters.contains', [])
    .filter("contains", function() {
        return function(input, match, flags) {
            if (!input) {
                return false;
            }

            if (!flags) {
                flags = "ig";
            }

            var rx = new RegExp(match, flags);

            return input.search(rx) >= 0;
        };
    });;angular.module('Realize.core.filters.ellipses', [])
    .filter("ellipses", function() {
        return function(input, len, ellipsis) {
            if (!input || !len) {
                return;
            }

            if (!ellipsis) {
                ellipsis = "...";
            }

            if (input.length <= len) {
                return input;
            } else {
                return input.substr(0, len) + ellipsis;
            }
        };
    });;// fileSize.js
angular.module("Realize.core.filters.fileSize", [])
    .filter("fileSize", function() {
        // these methods adapted to angular from OLE's util.js
        var numFormat = function (number, decimals, dec_point, thousands_sep) {
            number = number.toString().replace(',', '').replace(' ', '');

            var n = !isFinite(+number) ? 0 : +number,
                prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),
                sep = thousands_sep ? ',' : thousands_sep,
                dec = dec_point ? '.' : dec_point,
                s = '',
                toFixedFix = function (n, prec) {
                    var k = Math.pow(10, prec);
                    return (Math.round(n * k) / k).toString();
                };

            // Fix for IE parseFloat(0.55).toFixed(0) = 0;
            s = (prec ? toFixedFix(n, prec) : Math.round(n).toString()).split('.');
            if (s[0].length > 3) {
                s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
            }

            if ((s[1] || '').length < prec) {
                s[1] = s[1] || '';
                while(s[1].length < prec) {
                    s[1] += '0';
                }
            }

            return s.join(dec);
        };

        return function(input) {
            var filesize;

            if(!input) { return "N/A"; }

            if (input >= 1073741824) {
                filesize = numFormat(input / 1073741824, 2, '.', '') + ' GB';
            } else {
                if (input >= 1048576) {
                    filesize = numFormat(input / 1048576, 2, '.', '') + ' MB';
                } else {
                    if (input >= 1024) {
                        filesize = numFormat(input / 1024, 0) + ' KB';
                    } else {
                        filesize = numFormat(input, 0) + ' bytes';
                    }
                }
            }

            return filesize;
        };
    });;angular.module('Realize.core.filters.getExtension', [])
    .filter('getExtension', function() {
        return function(input, fallback) {
            var index = input.lastIndexOf("."),
                extension = input.slice(index);

            return (index === -1) ? fallback : extension;
        };
    });;angular.module('Realize.core.filters.handleEmptyResponse', [])
    .filter('handleEmptyResponse', function() {
        return function(input) {
            if (null !== input && input.length === 0) {
                return '-';
            } else {
                return input;
            }
        };
    });;angular.module('Realize.core.filters.letterizeNumber', [])
// convert number to a letter. e.g. show responses of assessment question ordered by 'A', 'B', etc
.filter("letterizeNumber", function() {
    var CHAR_CODE_OF_A = 'A'.charCodeAt(0);
    return function(number) {
        return String.fromCharCode(CHAR_CODE_OF_A + number);
    };
});;angular.module('Realize.core.filters.localize', ['Realize.core.services.messages'])
    .filter("localize", ['Messages',
        function(Messages) {
            /**
             * @filter localize
             * Return a message string from a localized messages file.
             * An optional array of values can be passed to interpolate the values into the string.
             * Example, no interpolation: {{ 'my.localized.string.name' | localize }}
             * Example, with interpolation: {{ 'my.localized.interpolated.string.name' | localize: ['x'] }}
             * Example message string to be interpolated: 'Rob has [0] cats and [1] goats.'
             * @param input {String} - name of message string
             * @param interpolatedValues {Array} - optional. An array of values to be interpolated in the message string.
             */
            return function(input, interpolatedValues) {
                var msg;

                if (angular.isArray(interpolatedValues)) {
                    msg = Messages.getInterpolatedMessage(input, interpolatedValues);
                } else {
                    msg = Messages.getMessage(input);
                }

                return msg;
            };
        }
    ]);;angular.module('Realize.core.filters.nospace', [])
    .filter("nospace", function() {
        return function(input) {
            if (!input) {
                return;
            }

            return input.replace(' ', '');
        };
    });;angular.module('Realize.core.filters.removeExtension', [])
    .filter('removeExtension', ['$filter',
        function($filter) {
            return function(input) {
                var index = input.lastIndexOf(".");

                return (index === -1) ? input : input.substring(0, index);
            };
        }
    ]);;angular.module('Realize.core.filters.replace', [])
// For replacing %# with scope variables in messages_en.json
.filter('replace', function() {
    return function(input) {
        if (!input) {
            return;
        } else {
            if (arguments.length > 1) {
                var i;
                for (i = 1; i < arguments.length; i++) {
                    input = input.replace("%" + i, arguments[i]);
                }
            }
            return input;
        }
    };
});;angular.module('Realize.core.filters.toArray', [])
/**
 * Filter to take an object and convert it to an array.  Intended for the
 * case where you have an object that you want to use orderBy with.  For
 * example, given an object like:
 *
 * {
 *      "key1": { a: 0, b: 4 },
 *      "key2": { a: 1, b: 3 },
 *      "key3": { a: 2, b: 2 }
 * }
 *
 * You could still use orderBy like:
 *
 * ng-repeat='item in items | toArray | orderBy:"a"'
 *
 * angular currently does not support orderBy over objects.
 */
.filter("toArray", function() {
    return function(input) {
        if (!input) {
            return;
        }

        if (input instanceof Array) {
            return input;
        }

        return $.map(input, function(val) {
            return val;
        });
    };
});;angular.module('Realize.core.filters.trunc', [])
    .filter("trunc", function() {
        return function(input, len) {
            if (!input || !len) {
                return;
            }

            return input.substr(0, len);
        };
    });;angular.module('Realize.core.filters.underscores', [])
    .filter("underscores", function() {
        return function(input) {
            if (!input) {
                return;
            }

            return input.replace(/ /g, '_');
        };
    });;// the goal of the global config is to allow various variables that are required by common modules
// to be configured to be application specific at runtime, while not needing to provide
// dummy values at code time, and outputting errors when misconfigured
angular.module('Realize.core.globalConfig', [])
    .provider('globalConfig', [
        function() {
            var config = {};

            this.setValue = function(key, value) {
                config[key] = value;
            };

            this.setConfig = function(settings) {
                angular.extend(config, settings);
            };

            this.$get = [
                function() {
                    var gc = {};

                    gc.get = function(key) {
                        var val = config[key];

                        if (angular.isUndefined(val)) {
                            throw new Error('Value ' + key + ' has not been defined! This should be done during the app config phase.');
                        } else {
                            return val;
                        }
                    };

                    return gc;

                    // a set method is purposely left out of this service so that the programmer is not tempted to tweak these configs
                    // at runtime
                }
            ];
        }
    ]);

// all the various constants that need this behavior located below

// the rest path designates the API call prefix required for server calls ex. /rest
angular.module('Realize.core.configs.REST_PATH', ['Realize.core.globalConfig'])
    .provider('REST_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('REST_PATH');
                }
            ];
        }
    ]);

// the script path designates where your script files are located for the various libs
// ex. /js for /js/realize.core/realize.core.js
angular.module('Realize.core.configs.SCRIPT_PATH', ['Realize.core.globalConfig'])
    .provider('SCRIPT_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('SCRIPT_PATH');
                }
            ];
        }
    ]);

// this path is generally the root of where images and other 'media' are located
angular.module('Realize.core.configs.MEDIA_PATH', ['Realize.core.globalConfig'])
    .provider('MEDIA_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('MEDIA_PATH');
                }
            ];
        }
    ]);

// this is designed to be a JSON object of data about the currently signed in user
// in Realize this is output in the main jsp and attached to the window
angular.module('Realize.core.configs.CURRENT_USER', ['Realize.core.globalConfig'])
    .provider('CURRENT_USER', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('CURRENT_USER');
                }
            ];
        }
    ]);

// the root of the application i.e. /community or /
angular.module('Realize.core.configs.ROOT_PATH', ['Realize.core.globalConfig'])
    .provider('ROOT_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('ROOT_PATH');
                }
            ];
        }
    ]);

// configured system wide logout url ex. /j_spring_security_logout
angular.module('Realize.core.configs.LOGOUT_URL', ['Realize.core.globalConfig'])
    .provider('LOGOUT_URL', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('LOGOUT_URL');
                }
            ];
        }
    ]);;// this is a hack for platforms like OLE which have legacy hash control
angular.module('Realize.core.hashchangePrevention', [])
    .config(['$locationProvider', '$browserProvider',
        function($locationProvider, $browserProvider) {
            // HACK!  Disable hash-change hijacking...  Not great
            // that this tries to overload angular internals, but
            // not sure if there is a good workaround...
            var oldBrowserGet = $browserProvider.$get,
                oldBrowserGetFn = oldBrowserGet[oldBrowserGet.length - 1],
                oldLocationGet = $locationProvider.$get,
                oldLocationGetFn = oldLocationGet[oldLocationGet.length - 1];

            // override the default $browser impl to disable URL rewriting and
            // listening for hash change events...  This is very very very
            // very very very very horrible.  Stupid angular...  :-(
            $browserProvider.$get = ['$window', '$log', '$sniffer', '$document',
                function($window, $log, $sniffer, $document) {
                    var ret = oldBrowserGetFn($window, $log, $sniffer, $document);
                    // kill of the onUrlChange handler
                    ret.onUrlChange = function(newUrl) {
                        return;
                    };

                    // don't allow angular to set the URL
                    ret.url = function(val) {
                        if (val) {
                            return;
                        }

                        return $window.location.href.replace(/%27/g, "'");
                    };
                    return ret;
                }
            ];

            // override absUrl in the $location service so that it always
            // returns the current browser url.  Otherwise, we end up with
            // digest problems because it's trying to change it, but nothing
            // actually changes...
            $locationProvider.hashPrefix('');
            $locationProvider.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
                function($rootScope, $browser, $sniffer, $rootElement) {
                    var service = oldLocationGetFn($rootScope, $browser, $sniffer, $rootElement);
                    service.absUrl = function() {
                        return $browser.url();
                    };

                    return service;
                }
            ];
        }
    ]);;// the common API communicates via old school POST params instead of JSON payloads

angular.module('Realize.core.legacyApiSupport', [])
.config(['$httpProvider',
    function($httpProvider) {
        // default POST header to form data rather than JSON for OLE backward compat
        $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
        $httpProvider.defaults.headers.put['Content-Type'] = 'application/x-www-form-urlencoded';

        // override JSON behavior
        $httpProvider.defaults.transformRequest = function(d) {
            if (!angular.isObject(d)) {
                return d;
            }
            var out = {};
            angular.forEach(d, function(value, key) {
                if (!angular.isFunction(value)) {
                    out[key] = value;
                }
            });
            return $.param(out, true);
        };
    }
]);;// in order to be able to cherry pick modules instead of using the full package, the paths must be separated
angular.module('Realize.core.paths', ['Realize.core.configs.SCRIPT_PATH'])
    .provider('REALIZE_CORE_ROOT_PATH', function() {
        return {
            $get: ['SCRIPT_PATH',
                function(SCRIPT_PATH) {
                    return SCRIPT_PATH + '/realize.core';
                }
            ]
        };
    });

// define module to house pre-cached templates
// in order to cherry pick, each module that has a (external) template should have this as a dependency
angular.module('Realize.core.templates', ['Realize.core.paths']);

// todo: deprecated!  no need to do a rollup of these modules.. an individual app can do that themselves if they desier
// convience rollup of complete package
angular.module('Realize.core', [
    'Realize.core.paths',
    'Realize.core.templates',
    'Realize.core.legacyApiSupport',
    'Realize.core.sessionTimeoutInterceptor',
    'Realize.core.directives.htmlUnsafe',
    'Realize.core.filters.fileSize',
    'Realize.core.filters.toArray',
    'Realize.core.filters.capitalizeFirstWord',
    'Realize.core.filters.letterizeNumber',
    'Realize.core.filters.getExtension',
    'Realize.core.filters.removeExtension',
    'Realize.core.filters.underscores',
    'Realize.core.filters.contains',
    'Realize.core.filters.trunc',
    'Realize.core.filters.nospace',
    'Realize.core.filters.ellipses',
    'Realize.core.filters.brStrip',
    'Realize.core.filters.replace',
    'Realize.core.filters.localize',
    'Realize.core.filters.coerce',
    'Realize.core.filters.handleEmptyResponse',
    'Realize.core.services.browserInfo',
    'Realize.core.services.debounce',
    'Realize.core.services.log',
    'Realize.core.services.messages',
    'Realize.core.services.rumbaDataService',
    'Realize.core.services.user',
    'Realize.core.services.userSvc',
    'Realize.core.services.isodate',
    'Realize.core.services.accessibility',
    'Realize.core.services.filesystem'
]);;angular.module('Realize.core.directives.htmlUnsafe', [])
.directive('ngBindHtmlUnsafe', ['$sce', '$log', '$parse', function($sce, $log, $parse) {
        return {
            link: function(scope, element, attrs) {
                element.addClass('ng-binding').data('$binding', attrs.ngBindHtmlUnsafe);

                var parsed = $parse(attrs.ngBindHtmlUnsafe);
                function getStringValue() { return (parsed(scope) || '').toString(); }

                scope.$watch(getStringValue, function ngBindHtmlUnsafeWatchAction(value) {
                    element.html(value);
                });
            }
        };
    }
]);;angular.module('Realize.core.filters.brStrip', [])
    .filter('brStrip', ['$log',
        function($log) {
            return function(input) {
                var output;
                try {
                    output = input.replace(/<br\s*\/?\s*>/g, "");
                } catch (e) {
                    $log.warn("the question/response text is not valid!!", input);
                    output = input;
                }

                return (output);
            };
        }
    ]);;angular.module('Realize.core.filters.capitalizeFirstWord', [])
/*
 * Filter to capitalize the first word of the given string.
 **/
.filter("capitalizeFirstWord", function() {
    return function(input) {
        return input.charAt(0).toUpperCase() + input.substr(1).toLowerCase();
    };
});;angular.module('Realize.core.filters.coerce', [])
    .filter("coerce", [
        '$log',
        '$injector',
        function($log, $injector) {

            return function(data, EntityType_in) {

                if(angular.isUndefined(data) || angular.isUndefined(EntityType_in)) {
                    return;
                }

                var returnData = [],
                    EntityType = angular.isFunction(EntityType_in) ? EntityType_in : $injector.get(EntityType_in);

                if(!EntityType) {
                    return;
                }

                // if it is an array of objects convert each one
                if (angular.isArray(data)) {
                    angular.forEach(data, function(d) {
                        returnData.push(new EntityType(d));
                    });

                    return returnData;
                } else {
                    return new EntityType(data);
                }
            };

        }
    ]);;angular.module('Realize.core.filters.contains', [])
    .filter("contains", function() {
        return function(input, match, flags) {
            if (!input) {
                return false;
            }

            if (!flags) {
                flags = "ig";
            }

            var rx = new RegExp(match, flags);

            return input.search(rx) >= 0;
        };
    });;angular.module('Realize.core.filters.ellipses', [])
    .filter("ellipses", function() {
        return function(input, len, ellipsis) {
            if (!input || !len) {
                return;
            }

            if (!ellipsis) {
                ellipsis = "...";
            }

            if (input.length <= len) {
                return input;
            } else {
                return input.substr(0, len) + ellipsis;
            }
        };
    });;// fileSize.js
angular.module("Realize.core.filters.fileSize", [])
    .filter("fileSize", function() {
        // these methods adapted to angular from OLE's util.js
        var numFormat = function (number, decimals, dec_point, thousands_sep) {
            number = number.toString().replace(',', '').replace(' ', '');

            var n = !isFinite(+number) ? 0 : +number,
                prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),
                sep = thousands_sep ? ',' : thousands_sep,
                dec = dec_point ? '.' : dec_point,
                s = '',
                toFixedFix = function (n, prec) {
                    var k = Math.pow(10, prec);
                    return (Math.round(n * k) / k).toString();
                };

            // Fix for IE parseFloat(0.55).toFixed(0) = 0;
            s = (prec ? toFixedFix(n, prec) : Math.round(n).toString()).split('.');
            if (s[0].length > 3) {
                s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
            }

            if ((s[1] || '').length < prec) {
                s[1] = s[1] || '';
                while(s[1].length < prec) {
                    s[1] += '0';
                }
            }

            return s.join(dec);
        };

        return function(input) {
            var filesize;

            if(!input) { return "N/A"; }

            if (input >= 1073741824) {
                filesize = numFormat(input / 1073741824, 2, '.', '') + ' GB';
            } else {
                if (input >= 1048576) {
                    filesize = numFormat(input / 1048576, 2, '.', '') + ' MB';
                } else {
                    if (input >= 1024) {
                        filesize = numFormat(input / 1024, 0) + ' KB';
                    } else {
                        filesize = numFormat(input, 0) + ' bytes';
                    }
                }
            }

            return filesize;
        };
    });;angular.module('Realize.core.filters.getExtension', [])
    .filter('getExtension', function() {
        return function(input, fallback) {
            var index = input.lastIndexOf("."),
                extension = input.slice(index);

            return (index === -1) ? fallback : extension;
        };
    });;angular.module('Realize.core.filters.handleEmptyResponse', [])
    .filter('handleEmptyResponse', function() {
        return function(input) {
            if (null !== input && input.length === 0) {
                return '-';
            } else {
                return input;
            }
        };
    });;angular.module('Realize.core.filters.letterizeNumber', [])
// convert number to a letter. e.g. show responses of assessment question ordered by 'A', 'B', etc
.filter("letterizeNumber", function() {
    var CHAR_CODE_OF_A = 'A'.charCodeAt(0);
    return function(number) {
        return String.fromCharCode(CHAR_CODE_OF_A + number);
    };
});;angular.module('Realize.core.filters.localize', ['Realize.core.services.messages'])
    .filter("localize", ['Messages',
        function(Messages) {
            /**
             * @filter localize
             * Return a message string from a localized messages file.
             * An optional array of values can be passed to interpolate the values into the string.
             * Example, no interpolation: {{ 'my.localized.string.name' | localize }}
             * Example, with interpolation: {{ 'my.localized.interpolated.string.name' | localize: ['x'] }}
             * Example message string to be interpolated: 'Rob has [0] cats and [1] goats.'
             * @param input {String} - name of message string
             * @param interpolatedValues {Array} - optional. An array of values to be interpolated in the message string.
             */
            return function(input, interpolatedValues) {
                var msg;

                if (angular.isArray(interpolatedValues)) {
                    msg = Messages.getInterpolatedMessage(input, interpolatedValues);
                } else {
                    msg = Messages.getMessage(input);
                }

                return msg;
            };
        }
    ]);;angular.module('Realize.core.filters.nospace', [])
    .filter("nospace", function() {
        return function(input) {
            if (!input) {
                return;
            }

            return input.replace(' ', '');
        };
    });;angular.module('Realize.core.filters.removeExtension', [])
    .filter('removeExtension', ['$filter',
        function($filter) {
            return function(input) {
                var index = input.lastIndexOf(".");

                return (index === -1) ? input : input.substring(0, index);
            };
        }
    ]);;angular.module('Realize.core.filters.replace', [])
// For replacing %# with scope variables in messages_en.json
.filter('replace', function() {
    return function(input) {
        if (!input) {
            return;
        } else {
            if (arguments.length > 1) {
                var i;
                for (i = 1; i < arguments.length; i++) {
                    input = input.replace("%" + i, arguments[i]);
                }
            }
            return input;
        }
    };
});;angular.module('Realize.core.filters.toArray', [])
/**
 * Filter to take an object and convert it to an array.  Intended for the
 * case where you have an object that you want to use orderBy with.  For
 * example, given an object like:
 *
 * {
 *      "key1": { a: 0, b: 4 },
 *      "key2": { a: 1, b: 3 },
 *      "key3": { a: 2, b: 2 }
 * }
 *
 * You could still use orderBy like:
 *
 * ng-repeat='item in items | toArray | orderBy:"a"'
 *
 * angular currently does not support orderBy over objects.
 */
.filter("toArray", function() {
    return function(input) {
        if (!input) {
            return;
        }

        if (input instanceof Array) {
            return input;
        }

        return $.map(input, function(val) {
            return val;
        });
    };
});;angular.module('Realize.core.filters.trunc', [])
    .filter("trunc", function() {
        return function(input, len) {
            if (!input || !len) {
                return;
            }

            return input.substr(0, len);
        };
    });;angular.module('Realize.core.filters.underscores', [])
    .filter("underscores", function() {
        return function(input) {
            if (!input) {
                return;
            }

            return input.replace(/ /g, '_');
        };
    });;// the goal of the global config is to allow various variables that are required by common modules
// to be configured to be application specific at runtime, while not needing to provide
// dummy values at code time, and outputting errors when misconfigured
angular.module('Realize.core.globalConfig', [])
    .provider('globalConfig', [
        function() {
            var config = {};

            this.setValue = function(key, value) {
                config[key] = value;
            };

            this.setConfig = function(settings) {
                angular.extend(config, settings);
            };

            this.$get = [
                function() {
                    var gc = {};

                    gc.get = function(key) {
                        var val = config[key];

                        if (angular.isUndefined(val)) {
                            throw new Error('Value ' + key + ' has not been defined! This should be done during the app config phase.');
                        } else {
                            return val;
                        }
                    };

                    return gc;

                    // a set method is purposely left out of this service so that the programmer is not tempted to tweak these configs
                    // at runtime
                }
            ];
        }
    ]);

// all the various constants that need this behavior located below

// the rest path designates the API call prefix required for server calls ex. /rest
angular.module('Realize.core.configs.REST_PATH', ['Realize.core.globalConfig'])
    .provider('REST_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('REST_PATH');
                }
            ];
        }
    ]);

// the script path designates where your script files are located for the various libs
// ex. /js for /js/realize.core/realize.core.js
angular.module('Realize.core.configs.SCRIPT_PATH', ['Realize.core.globalConfig'])
    .provider('SCRIPT_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('SCRIPT_PATH');
                }
            ];
        }
    ]);

// this path is generally the root of where images and other 'media' are located
angular.module('Realize.core.configs.MEDIA_PATH', ['Realize.core.globalConfig'])
    .provider('MEDIA_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('MEDIA_PATH');
                }
            ];
        }
    ]);

// this is designed to be a JSON object of data about the currently signed in user
// in Realize this is output in the main jsp and attached to the window
angular.module('Realize.core.configs.CURRENT_USER', ['Realize.core.globalConfig'])
    .provider('CURRENT_USER', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('CURRENT_USER');
                }
            ];
        }
    ]);

// the root of the application i.e. /community or /
angular.module('Realize.core.configs.ROOT_PATH', ['Realize.core.globalConfig'])
    .provider('ROOT_PATH', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('ROOT_PATH');
                }
            ];
        }
    ]);

// configured system wide logout url ex. /j_spring_security_logout
angular.module('Realize.core.configs.LOGOUT_URL', ['Realize.core.globalConfig'])
    .provider('LOGOUT_URL', [
        function() {
            this.$get = ['globalConfig',
                function(globalConfig) {
                    return globalConfig.get('LOGOUT_URL');
                }
            ];
        }
    ]);;// this is a hack for platforms like OLE which have legacy hash control
angular.module('Realize.core.hashchangePrevention', [])
    .config(['$locationProvider', '$browserProvider',
        function($locationProvider, $browserProvider) {
            // HACK!  Disable hash-change hijacking...  Not great
            // that this tries to overload angular internals, but
            // not sure if there is a good workaround...
            var oldBrowserGet = $browserProvider.$get,
                oldBrowserGetFn = oldBrowserGet[oldBrowserGet.length - 1],
                oldLocationGet = $locationProvider.$get,
                oldLocationGetFn = oldLocationGet[oldLocationGet.length - 1];

            // override the default $browser impl to disable URL rewriting and
            // listening for hash change events...  This is very very very
            // very very very very horrible.  Stupid angular...  :-(
            $browserProvider.$get = ['$window', '$log', '$sniffer', '$document',
                function($window, $log, $sniffer, $document) {
                    var ret = oldBrowserGetFn($window, $log, $sniffer, $document);
                    // kill of the onUrlChange handler
                    ret.onUrlChange = function(newUrl) {
                        return;
                    };

                    // don't allow angular to set the URL
                    ret.url = function(val) {
                        if (val) {
                            return;
                        }

                        return $window.location.href.replace(/%27/g, "'");
                    };
                    return ret;
                }
            ];

            // override absUrl in the $location service so that it always
            // returns the current browser url.  Otherwise, we end up with
            // digest problems because it's trying to change it, but nothing
            // actually changes...
            $locationProvider.hashPrefix('');
            $locationProvider.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
                function($rootScope, $browser, $sniffer, $rootElement) {
                    var service = oldLocationGetFn($rootScope, $browser, $sniffer, $rootElement);
                    service.absUrl = function() {
                        return $browser.url();
                    };

                    return service;
                }
            ];
        }
    ]);;// the common API communicates via old school POST params instead of JSON payloads

angular.module('Realize.core.legacyApiSupport', [])
.config(['$httpProvider',
    function($httpProvider) {
        // default POST header to form data rather than JSON for OLE backward compat
        $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
        $httpProvider.defaults.headers.put['Content-Type'] = 'application/x-www-form-urlencoded';

        // override JSON behavior
        $httpProvider.defaults.transformRequest = function(d) {
            if (!angular.isObject(d)) {
                return d;
            }
            var out = {};
            angular.forEach(d, function(value, key) {
                if (!angular.isFunction(value)) {
                    out[key] = value;
                }
            });
            return $.param(out, true);
        };
    }
]);;/**
 * Copyright 2014, Pearson Education, Learning Technology Group
 * NOTE: ui.router is not technically needed, but listed as a dependency because we rely on $stateChangeStart events
 */

angular.module('Realize.core.services.NavigationBlocker', ['ui.router'])
    .factory('NavigationBlocker', ['$log', '$rootScope',
        function($log, $rootScope) {

            /*============ FACTORY DEFINITION ============*/

            var NavigationBlocker = function(scopeIn, callBack) {

                /*============ PRIVATE PROPERTIES/METHODS ============*/

                var self = this;
                var shouldBlockNavigation = false;

                var checkNavigationBlocker = function(event, toState, toParams, fromState, fromParams) {

                    if(!shouldBlockNavigation) {return;}

                    // ui-router hasn't implemented any event for when state change was prevented so we fire our own
                    event.preventDefault();
                    $rootScope.$broadcast('$stateChangePrevented', toState, toParams, fromState, fromParams);

                    /**
                     * pass along the intended target, this is helpful if you want to "pause" to pop a modal and then continue
                     * you could also listen to the $stateChangePrevented event above, but it's convenient to pass back to the call back
                     * because if you are using a NavigationBlocker you will be passing a callback anyway
                     */
                    callBack(toState, toParams);
                };


                /*============ PUBLIC PROPERTIES/METHODS ============*/

                self.start = function () {
                    shouldBlockNavigation = true;
                };

                self.stop = function () {
                    shouldBlockNavigation = false;
                };


                /*============ INITIALIZATION ============*/

                scopeIn.$on('$stateChangeStart', checkNavigationBlocker);

            };

            return NavigationBlocker;
        }
    ]);;// accessiblity.svc.js
// perhaps this should be a directive since it manipulates the DOM

angular.module('Realize.core.services.accessibility', [])
    .service("AccessibilityService", ['$log', '$rootScope',
        function($log, $rootScope) {
            // init
            var svc = this;

            var toggleInteractionState = function() {
                $rootScope.isKeyboardInUse = !$rootScope.isKeyboardInUse;

                if ($rootScope.isKeyboardInUse) {
                    // detect mouse interaction
                    angular.element('body').mousedown(function(mouseDetection) {
                        angular.element(this).unbind(mouseDetection);
                        toggleInteractionState();
                        svc.applyStyleToFocusableElements();
                    });
                }
            };

            var setKeyInteractionHandler = function() {
                // detect keyboard interaction
                angular.element('body').keydown(function() {
                    if (!$rootScope.isKeyboardInUse) {
                        toggleInteractionState();
                    }
                    // since we can't easily determine when angular is done building the DOM,
                    // persist the listener on body, re-apply css hooks to newly rendered markup
                    svc.applyStyleToFocusableElements();
                });
            };

            svc.init = function() {
                $rootScope.isKeyboardInUse = false;
                setKeyInteractionHandler();
            };

            svc.setFocusElements = function(elements) {
                svc.keyboardFocusableElements = elements;
            };

            svc.applyStyleToFocusableElements = function() {
                // display visual focus indicators, based on keyboard use
                angular.element(svc.keyboardFocusableElements).toggleClass('kb-mode', $rootScope.isKeyboardInUse);
            };

            $rootScope.skipNav = function(event) {
                event.stopPropagation();
                angular.element('#skipTarget').next("div").find(":focusable").first().focus();
            };

            // if the user is in keyboard mode,
            // elements that have focus on new page views need this in order to see the focus outline
            $rootScope.$on('$viewContentLoaded', function() {
                // $log.log('[$viewContentLoaded]');
                svc.applyStyleToFocusableElements();
            });

            return svc;

        }
    ]);;angular.module('Realize.core.services.browserInfo', [])
    .service('BrowserInfo', [
        '$window',
        function($window) {

            var userAgent = $window.navigator ? angular.lowercase($window.navigator.userAgent) : "";

            this.browser = {};
            this.OS = {};

            // regex patterns taken from https://github.com/ded/bowser/blob/master/bowser.js
            this.browser.isFirefox = /firefox|iceweasel/i.test(userAgent);
            this.browser.isMSIE = /msie|trident/i.test(userAgent);

            if( this.browser.isMSIE ) {
                var match = navigator.userAgent.toLowerCase().match(/(?:msie |trident\/.*; rv:)(\d+)/);
                this.browser.msieVersion = match ? parseInt(match[1], 10) : undefined;
            }

            this.OS.isIOS = /(ipod|iphone|ipad)/i.test(userAgent);
            this.OS.isIOS5 = this.OS.isIOS && /OS 5_[0-9_]+ like Mac OS X/i.test(userAgent);

            this.OS.isIDevice = (
                $window.navigator.platform === 'iPad' ||
                $window.navigator.platform === 'iPhone' ||
                $window.navigator.platform === 'iPad Simulator' ||
                $window.navigator.platform === 'iPhone Simulator'
            );

            this.isRetina = $window.devicePixelRatio >= 2;
        }
    ])
    .run([
        '$rootScope',
        '$window',
        'BrowserInfo',
        function($rootScope, $window, BrowserInfo) {
            var win = angular.element($window);

            $rootScope.isRetina = BrowserInfo.isRetina;

            $rootScope.isIDevice = BrowserInfo.OS.isIDevice;

            // responsive listeners
            var updateOrientation = function() {
                var orientation = $window.orientation;
                if (orientation === 0) {
                    // iPad is in Portrait mode.
                    $rootScope.iOrientation = 'portrait';
                } else if (orientation === 90) {
                    // iPad is in Landscape mode. The screen is turned to the left.
                    $rootScope.iOrientation = 'landscape';
                } else if (orientation === -90) {
                    // iPad is in Landscape mode. The screen is turned to the right.
                    $rootScope.iOrientation = 'landscape';
                } else if (orientation === 180) {
                    // Upside down portrait.
                    $rootScope.iOrientation = 'portrait';
                } else {
                    $rootScope.iOrientation = 'unknown';
                }
            };

            // update rootscope orientation first
            updateOrientation();
            // now set correct iMode; TODO: set 980 configurable?
            $rootScope.iMode = (win.width() <= 980 || $rootScope.iOrientation === 'portrait');

            win.on('resize', function() {
                $rootScope.$apply(function() {
                    updateOrientation();
                    $rootScope.iMode = (win.width() <= 980 || $rootScope.iOrientation === 'portrait');
                });
            });

            win.on('orientationchange', function() {
                $rootScope.$apply(function() {
                    updateOrientation();
                    $rootScope.iMode = (win.width() <= 980 || $rootScope.iOrientation === 'portrait');
                });
            });

            $rootScope.$watch('iMode', function() {
                $rootScope.$broadcast('orientationChange');
            });

            $rootScope.$on('destroy', function() {
                win.off('resize');
                win.off('orientationchange');
            });
        }
    ]);;// debounce.js
// http://unscriptable.com/2009/03/20/debouncing-javascript-methods/

angular.module('Realize.core.services.debounce', [])
    .factory(
        '$debounce', [
            '$rootScope',
            '$browser',
            '$q',
            '$exceptionHandler',
            function($rootScope, $browser, $q, $exceptionHandler) {
                var deferreds = {},
                    methods = {},
                    uuid = 0;

                function debounce(fn, delay, invokeApply) {
                    var deferred = $q.defer(),
                        promise = deferred.promise,
                        skipApply = (angular.isDefined(invokeApply) && !invokeApply),
                        timeoutId, cleanup,
                        methodId, bouncing = false;

                    // check we dont have this method already registered
                    angular.forEach(methods, function(value, key) {
                        if (angular.equals(methods[key].fn, fn)) {
                            bouncing = true;
                            methodId = key;
                        }
                    });

                    // not bouncing, then register new instance
                    if (!bouncing) {
                        methodId = uuid++;
                        methods[methodId] = {
                            fn: fn
                        };
                    } else {
                        // clear the old timeout
                        deferreds[methods[methodId].timeoutId].reject('bounced');
                        $browser.defer.cancel(methods[methodId].timeoutId);
                    }

                    var debounced = function() {
                        // actually executing? clean method bank
                        delete methods[methodId];

                        try {
                            deferred.resolve(fn());
                        } catch (e) {
                            deferred.reject(e);
                            $exceptionHandler(e);
                        }

                        if (!skipApply) {
                            $rootScope.$apply();
                        }
                    };

                    timeoutId = $browser.defer(debounced, delay);

                    // track id with method
                    methods[methodId].timeoutId = timeoutId;

                    cleanup = function(reason) {
                        delete deferreds[promise.$$timeoutId];
                    };

                    promise.$$timeoutId = timeoutId;
                    deferreds[timeoutId] = deferred;
                    promise.then(cleanup, cleanup);

                    return promise;
                }


                // similar to angular's $timeout cancel
                debounce.cancel = function(promise) {
                    if (promise && deferreds.hasOwnProperty(promise.$$timeoutId)) {
                        deferreds[promise.$$timeoutId].reject('canceled');
                        return $browser.defer.cancel(promise.$$timeoutId);
                    }
                    return false;
                };

                return debounce;
            }
        ]
);;// this is generally only used for admin functions, only supports Chrome
angular.module('Realize.core.services.filesystem', [])
    .factory('fileSystem', ['$q', '$timeout', '$window',
        function($q, $timeout, $window) {
            var fsDefer = $q.defer();

            var DEFAULT_QUOTA_MB = 5;

            //wrap resolve/reject in an empty $timeout so it happens within the Angular call stack
            //easier than .apply() since no scope is needed and doesn't error if already within an apply
            function safeResolve(deferred, message) {
                $timeout(function() {
                    deferred.resolve(message);
                });
            }

            function safeReject(deferred, message) {
                $timeout(function() {
                    deferred.reject(message);
                });
            }

            $window.webkitStorageInfo.requestQuota($window.PERSISTENT, DEFAULT_QUOTA_MB * 1024 * 1024, function(grantedBytes) {
                $window.webkitRequestFileSystem($window.PERSISTENT, grantedBytes, function(fs) {
                    safeResolve(fsDefer, fs);
                }, function(e) {
                    safeReject(fsDefer, {
                        text: "Error requesting File System access",
                        obj: e
                    });
                });
            }, function(e) {
                safeReject(fsDefer, {
                    text: "Error requesting Quota",
                    obj: e
                });
            });

            var fileSystem = {
                getCurrentUsage: function() {
                    var def = $q.defer();

                    $window.webkitStorageInfo.queryUsageAndQuota($window.PERSISTENT, function(used, quota) {
                        safeResolve(def, {
                            'used': used,
                            'quota': quota
                        });
                    }, function(e) {
                        safeReject(def, {
                            text: "Error getting quota information",
                            obj: e
                        });
                    });

                    return def.promise;
                },
                requestQuotaIncrease: function(newQuotaMB) {
                    var def = $q.defer();

                    $window.webkitStorageInfo.requestQuota($window.PERSISTENT, newQuotaMB * 1024 * 1024, function(grantedBytes) {
                        safeResolve(def, grantedBytes);
                    }, function(e) {
                        safeReject(def, {
                            text: "Error requesting quota increase",
                            obj: e
                        });
                    });

                    return def.promise;
                },
                getFolderContents: function(dir) {
                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {
                        fs.root.getDirectory(fs.root.fullPath + dir, {}, function(dirEntry) {
                            var dirReader = dirEntry.createReader();
                            dirReader.readEntries(function(entries) {
                                safeResolve(def, entries);
                            }, function(e) {
                                safeReject(def, {
                                    text: "Error reading entries",
                                    obj: e
                                });
                            });
                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting directory",
                                obj: e
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                createFolder: function(path) {
                    //remove leading slash if present
                    path = path.replace(/^\//, "");

                    var def = $q.defer();

                    function createDir(rootDir, folders) {
                        rootDir.getDirectory(folders[0], {
                            create: true
                        }, function(dirEntry) {
                            if (folders.length) {
                                createDir(dirEntry, folders.slice(1));
                            } else {
                                safeResolve(def, dirEntry);
                            }
                        }, function(e) {
                            safeReject(def, {
                                text: "Error creating directory",
                                obj: e
                            });
                        });
                    }

                    fsDefer.promise.then(function(fs) {
                        createDir(fs.root, path.split('/'));
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                deleteFolder: function(path, recursive) {
                    recursive = (typeof recursive === 'undefined' ? false : recursive);

                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {
                        fs.root.getDirectory(path, {}, function(dirEntry) {
                            var success = function() {
                                safeResolve(def, "");
                            };
                            var err = function(e) {
                                safeReject(def, {
                                    text: "Error removing directory",
                                    obj: e
                                });
                            };

                            if (recursive) {
                                dirEntry.removeRecursively(success, err);
                            } else {
                                dirEntry.remove(success, err);
                            }
                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting directory",
                                obj: e
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                writeFileInput: function(filename, file, mimeString) {
                    var def = $q.defer();

                    var reader = new window.FileReader();

                    reader.onload = function(e) {
                        var buf = e.target.result;

                        $timeout(function() {
                            fileSystem.writeArrayBuffer(filename, buf, mimeString).then(function() {
                                safeResolve(def, "");
                            }, function(e) {
                                safeReject(def, e);
                            });
                        });
                    };

                    reader.readAsArrayBuffer(file);

                    return def.promise;
                },
                writeText: function(fileName, contents, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    //create text blob from string
                    var blob = new $window.Blob([contents], {
                        type: 'text/plain'
                    });

                    return fileSystem.writeBlob(fileName, blob, append);
                },
                writeJSON: function(fileName, contents, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    //create text blob from string
                    var blob = new $window.Blob([contents], {
                        type: 'application/json;charset=UTF-8'
                    });

                    return fileSystem.writeBlob(fileName, blob, append);
                },
                writeArrayBuffer: function(fileName, buf, mimeString, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    var blob = new $window.Blob([new window.Uint8Array(buf)], {
                        type: mimeString
                    });

                    return fileSystem.writeBlob(fileName, blob, append);
                },
                writeBlob: function(fileName, blob, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {

                        fs.root.getFile(fileName, {
                            create: true
                        }, function(fileEntry) {

                            fileEntry.createWriter(function(fileWriter) {
                                if (append) {
                                    fileWriter.seek(fileWriter.length);
                                }

                                var truncated = false;
                                fileWriter.onwriteend = function(e) {
                                    //truncate all data after current position
                                    if (!truncated) {
                                        truncated = true;
                                        this.truncate(this.position);
                                        return;
                                    }
                                    safeResolve(def, fileEntry.toURL());
                                };

                                fileWriter.onerror = function(e) {
                                    safeReject(def, {
                                        text: 'Write failed',
                                        obj: e
                                    });
                                };

                                fileWriter.write(blob);

                            }, function(e) {
                                safeReject(def, {
                                    text: "Error creating file",
                                    obj: e
                                });
                            });

                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting file",
                                obj: e
                            });
                        });

                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                readFile: function(fileName, returnType) {
                    var def = $q.defer();

                    returnType = returnType || "text";

                    fsDefer.promise.then(function(fs) {
                        fs.root.getFile(fileName, {}, function(fileEntry) {
                            // Get a File object representing the file,
                            // then use FileReader to read its contents.
                            fileEntry.file(function(file) {
                                var reader = new $window.FileReader();

                                reader.onloadend = function() {
                                    safeResolve(def, this.result);
                                };

                                reader.onerror = function(e) {
                                    safeReject(def, {
                                        text: "Error reading file",
                                        obj: e
                                    });
                                };


                                switch (returnType) {
                                    case 'arraybuffer':
                                        reader.readAsArrayBuffer(file);
                                        break;
                                    case 'binarystring':
                                        reader.readAsBinaryString(file);
                                        break;
                                    case 'dataurl':
                                        reader.readAsDataURL(file);
                                        break;
                                    default:
                                        reader.readAsText(file);
                                }
                            }, function(e) {
                                safeReject(def, {
                                    text: "Error getting file",
                                    obj: e
                                });
                            });
                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting file",
                                obj: e
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                deleteFile: function(fullPath) {
                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {
                        fs.root.getFile(fullPath, {
                            create: false
                        }, function(fileEntry) {
                            fileEntry.remove(function() {
                                safeResolve(def, "");
                            }, function(e) {
                                safeReject(def, {
                                    text: "Error deleting file",
                                    obj: e
                                });
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                }
            };

            return fileSystem;
        }
    ]);;// dep on datejs??

angular.module('Realize.core.services.isodate', [])
    .service("ISODateService", ['$log',
        function($log) {

            this.toDateTimeString = function(date) {
                return date.toString('yyyy-MM-ddTHH:mm:ss') + this.getOffsetFromUTC(date);
            };

            this.toDateString = function(date) {
                return date.toString('yyyy-MM-dd');
            };

            //make sure range includes TZ for this date
            this.toDateStringWithZone = function(date) {
                return date.toString('yyyy-MM-ddT00:00:00') + this.getOffsetFromUTC(date);
            };

            this.toStartOfDayStringWithZone = this.toDateStringWithZone;

            this.toStartOfNextDayStringWithZone = function(date) {
                var dateRolledForward = date.clone().clearTime().add({
                    days: 1
                });
                return this.toDateTimeString(dateRolledForward);
            };

            this.toEndOfDayStringWithZone = function(date) {
                var dateRolledForward = date.clone().clearTime().add({
                    hours: 23,
                    minutes: 59,
                    seconds: 59
                });
                return this.toDateTimeString(dateRolledForward);
            };

            this.getStringForOffset = function(offset) {
                return ((offset < 0 ? '+' : '-') + this.pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + this.pad(Math.abs(offset) % 60, 2));
            };

            this.getOffsetFromUTC = function(date) {
                if (angular.isUndefined(date)) {
                    date = new Date();
                }
                var offset = date.getTimezoneOffset();
                return this.getStringForOffset(offset);
            };

            this.pad = function(number, length, padChar) {
                if (angular.isUndefined(length)) {
                    length = 2;
                }
                if (angular.isUndefined(padChar)) {
                    padChar = '0';
                }
                var str = "";
                str += number;
                while (str.length < length) {
                    str = padChar + str;
                }
                return str;
            };

        }
    ]);;angular.module('Realize.core.services.log', [])
.value('LOG_LEVEL', 5) // to be overridden in index.html
.config(['$provide', function($provide) {
    $provide.decorator('$log', ['LOG_LEVEL', '$delegate', function(LOG_LEVEL, $delegate) {
        var log = $delegate.log,
            debug = $delegate.debug,
            warn = $delegate.warn,
            info = $delegate.info,
            error = $delegate.error;

        $delegate.log = function() {
            if(LOG_LEVEL >= 3) {
                log.apply($delegate, arguments);
            }
        };

        $delegate.debug = function() {
            if(LOG_LEVEL >= 5) {
                debug.apply($delegate, arguments);
            }
        };

        $delegate.warn = function() {
            if(LOG_LEVEL >= 2) {
                warn.apply($delegate, arguments);
            }
        };

        $delegate.info = function() {
            if(LOG_LEVEL >= 4) {
                info.apply($delegate, arguments);
            }
        };

        $delegate.error = function() {
            if(LOG_LEVEL >= 1) {
                error.apply($delegate, arguments);
            }
        };

        return $delegate;
    }]);
}]);
;// messages.js

angular.module('Realize.core.services.messages', [])
    .provider('Messages', [
        function() {
            var languageFilePath,
                provided = {};

            // configure where the .json files are stored
            this.setLanguageFilePath = function(path) {
                languageFilePath = path;
            };

            this.addCache = function (path, codes) {
                provided[path] = codes;
            };

            this.$get = ['$http', '$log', '$q', '$filter', '$cacheFactory',
                function($http, $log, $q, $filter, $cacheFactory) {
                    var svc = this,
                        _codes = {},
                        cache = $cacheFactory.get('$http');

                    _.each(provided, function (val, key) {
                        cache.put(key, val);
                    });

                    if (!languageFilePath) {
                        throw "Error [MessagesProvider]: languageFilePath must be configured!";
                    }

                    svc.load = function(locale, override, update) {
                        locale = locale || 'en';
                        svc.currentLocale = locale;

                        if (!angular.isDefined(update)) {
                            update = true;
                        }

                        var file = languageFilePath + '/messages_' + locale + '.json';
                        $log.log('messages loading file', file, 'override', override, {
                            cache: !! !override
                        });
                        // allow full url override for local "preview" mode
                        if (override) {
                            file = override;
                        }

                        var promise = $http.get(file, {
                            cache: !! !override
                        })
                            .then(function(response) {
                                // might just be loading the data for another purpose.. (admin)
                                if (update) {
                                    angular.copy(response.data, _codes);
                                }

                                return response.data;
                            }, function(err) {
                                $log.warn('error loading locale file!', err);
                                return $q.reject(err);
                            });

                        return promise;
                    };

                    // gets a message from the json obj, using dot notation
                    // 'classes.header.title' === {classes: {header: {title: 'Foo'}}}
                    svc.getMessage = function(code, getJson) {
                        var keys = code.split('.'),
                            result = _codes,
                            o;

                        //$log.log(result);

                        for (o = 0; o < keys.length; o++) {
                            if (result[keys[o]]) {
                                result = result[keys[o]];
                            } else {
                                result = null;
                                break;
                            }
                        }

                        if (getJson) {
                            return result;
                        }

                        // we don't want to allow the actual object chunk returned here...
                        // so an incomplete code will result in null here, only strings!
                        return angular.isString(result) ? result : null;
                    };


                    /**
                     * @method getInterpolatedMessage
                     * @param code {String}
                     * @param values {Array}
                     * @returns {String}
                     */
                    svc.getInterpolatedMessage = function(code, values) {
                        var v,
                            msg = svc.getMessage(code);

                        if (msg === null) {
                            msg = '';
                        }

                        for (v = 0; v < values.length; v += 1) {
                            msg = msg.replace("{" + v + "}", values[v]);
                        }

                        return msg;
                    };

                    svc.getMessageOrDefault = function(key, defaultValue) {
                        var msg = svc.getMessage(key);

                        return msg === null ? defaultValue : msg;
                    };

                    svc.getMessagesAsArray = function(code) {
                        return $filter('toArray')(svc.getMessage(code, true));
                    };

                    return svc;
                }
            ];

        }
    ]);;angular.module('Realize.core.services.poller', [])
    .service('Poller', ['$http', '$q', '$timeout', '$log',
        function($http, $q, $timeout, $log) {
            var polls = {};

            var service = this;

            var doPoll = function(promise, name, method, interval) {
                return promise.then(function(result) {
                        if (polls[name] && polls[name].status === 'polling') {
                            polls[name].poll = $timeout(method, interval);
                            doPoll(polls[name].poll, name, method, interval);
                            polls[name].deferred.notify(result);
                        } else {
                            service.stop(name);
                        }
                    }, function(err) {
                        $log.log(name + ' timeout rejected: ', err);
                        if (polls[name] && polls[name].deferred) {
                            return polls[name].deferred.reject(err);
                        }
                    });
            };

            this.start = function(name, method, interval) {
                var deferred = $q.defer();

                if (polls[name]) {
                    return polls[name].deferred.promise;
                } else {
                    polls[name] = {};
                    polls[name].method = method;
                    polls[name].interval = interval;
                    polls[name].deferred = deferred;
                    polls[name].status = 'polling';

                    polls[name].poll = $timeout(method, interval);
                    doPoll(polls[name].poll, name, method, interval);

                    return polls[name].deferred.promise;
                }
            };

            this.stop = function(name) {
                if (polls[name]) {
                    $timeout.cancel(polls[name].poll);
                    polls[name].status = 'stopped';
                    polls[name].deferred.reject('stopped');
                } else {
                    $log.warn('no poller found: ', name);
                }
            };

            this.list = function() {
                return Object.keys(polls);
            };

            this.$$getPolls = function() {
                return polls;
            };

            this.clearAll = function () {
                var self = this;
                angular.forEach(polls, function(value, key) {
                    self.clear(key);
                });
            };

            this.clear = function(name) {
                this.stop(name);
                delete polls[name];
            };

            this.restart = function(name) {
                if (!polls[name]) {
                    return $q.reject('no poll found');
                }

                var method = polls[name].method;
                var interval = polls[name].interval;

                this.clear(name);

                return this.start(name, method, interval);
            };

        }
    ]);;angular.module('Realize.core.services.rumbaDataService', [
    'Realize.core.configs.REST_PATH'
])
    .service('RumbaDataService', [
        '$http',
        '$q',
        'REST_PATH',
        function($http, $q, restPath) {
            var service = this;

            service.getOrgDetails = function(ids, success) {
                var promise = $http({
                    url: restPath + '/rumba/orgs',
                    method: 'GET',
                    params: {
                        'id[]': ids
                    },
                    cache: true // caching because of search results and also changing shouldn't really happen mid session
                });

                if (success) {
                    promise.success(success);
                }

                return promise;
            };

            // this call is restricted to ROLE_CUSTOMER_ADMIN on the back end
            // it only returns the child orgs of the affiliations that they are CA with
            // it uses the currently signed in user on the back end
            service.getChildOrgs = function() {
                return $http.get(restPath + '/rumba/orgs/children', {
                    cache: true
                }).then(function(response) {
                    return response.data;
                }, function(err) {
                    return $q.reject(err);
                });
            };

            service.checkUsernameAvailability = function(username, success) {
                var promise = $http({
                    url: restPath + '/check_username',
                    method: 'GET',
                    params: {
                        username: username
                    }
                });

                if (success) {
                    promise.success(success);
                }

                return promise;
            };

            service.getProductDetails = function(id, success) {
                var promise = $http({
                    url: restPath + '/rumba/products/' + id,
                    method: 'GET',
                    cache: true // caching because of search results and also changing shouldn't really happen mid session
                });

                if (success) {
                    promise.success(success);
                }

                return promise;
            };

        }
    ]);;angular.module('Realize.core.services.user', [
    'Realize.core.services.rumbaDataService',
    'Realize.core.services.messages',
    'Realize.core.configs.REST_PATH',
    'Realize.core.configs.MEDIA_PATH',
    'Realize.core.configs.CURRENT_USER'
])
    .run([
        'User',
        '$rootScope',
        'CURRENT_USER',
        function(User, $rootScope, CURRENT_USER) {
            $rootScope.currentUser = new User(CURRENT_USER);
        }
    ])
    .factory('User', [
        '$q',
        '$http',
        '$log',
        'REST_PATH',
        'RumbaDataService',
        'MEDIA_PATH',
        '$rootScope',
        'Messages',
        function($q, $http, $log, restPath, Rumba, MEDIA_PATH, $rootScope, Messages) {

            function User(json) {
                var self = this;

                // setup some defaults, they will be overridden if provided
                self.userAttributes = {};

                // create instance using json properties
                if (json) {
                    angular.copy(json, self);
                }

                // need a "emailAddress" attribute for editing, instead of rumbaEmail
                self.emailAddress = self.rumbaEmail;

                // some of the naming vars dont come from server
                self.$updateNames();

                // the affiliations will have an entry for each role they play (CA, T, S)
                // in this case we only want distinct since the oleAffiliations dont have distinguishable differences
                // if you want to know the role within an org, that's self.affiliations
                self.oleAffiliations = _.uniq(self.oleAffiliations, function(affiliation) { return affiliation.organizationId; });

                // need to update org data once
                var orgIds = _.pluck(self.oleAffiliations, 'organizationId');
                if (orgIds.length > 0) {
                    Rumba.getOrgDetails(orgIds, function(response) {
                        angular.forEach(response, function(org) {
                            var affiliatedOrg = _.findWhere(self.oleAffiliations, {organizationId: org.organizationId});

                            if (affiliatedOrg) {
                                affiliatedOrg.orgDetails = org;
                            }
                        });
                    });
                }

                if (self.primaryOrgRole === "Student" && (self.primaryOrgId !== "lti-org-id" && self.primaryOrgId !== "student_center_org_id")) {
                    // Don't build the product details for the LTI Content viewer ('lti-org-id') since
                    // LTI uses a different mechanism for associating products to users.

                    // Build productId-productName map (for etext)
                    Rumba.getProductDetails(self.primaryOrgId, function(response) {
                        self.productIdMap = {};
                        angular.forEach(response, function(org) {
                            self.productIdMap[org.productId] = org.productDisplayName;
                        });

                    });
                }

                // set it to already existing to generate avatarUrl
                self.$setAvatar(self.getAttribute('profile.avatar'));

                self.isLibraryAdmin = self.hasRole("ROLE_LIBRARY_ADMIN");
                self.isTeacher = self.hasRole("ROLE_TEACHER");
                self.isStudent = self.hasRole("ROLE_STUDENT");
                self.isReviewer = self.hasRole("ROLE_REVIEWER");
            }

            User.prototype.$setAvatar = function(avatar) {
                var self = this,
                    deferred = $q.defer();

                self.setAttribute('profile.avatar', avatar, true).then(function(response) {
                    // TODO: make this platform configurable!
                    var avatarUrl = MEDIA_PATH + '/skins/default/images/profile_icons/',
                        avatarAttr = self.getAttribute('profile.avatar');

                    if (self.primaryOrgRole === 'Student') {
                        avatarUrl += avatarAttr || 'default_student';
                        //$log.log('student avatarUrl', avatarUrl, avatarAttr);
                    } else {
                        avatarUrl += avatarAttr || 'default_teacher';
                    }

                    // the avatar url should have the extension omitted, so that retina can be applied
                    self.avatarUrl = avatarUrl + ($rootScope.isRetina ? '@2x.png' : '.png');

                    deferred.resolve(self);

                }, deferred.reject);

                return deferred.promise;
            };

            // specifically set the profile.locale user attribute, and refresh the language
            User.prototype.$setLocale = function(locale) {
                locale = locale || 'en';
                var user = this;
                $log.log('user $setLocale', locale);
                return user.setAttribute('profile.locale', locale)
                    .then(function() {
                        Messages.load(locale, user.getAttribute('admin.previewMode') ? user.getAttribute('admin.localeOverride') : null);
                    });
            };

            User.prototype.$getIpadPreview = function(preview, callback) {
                $http.get(preview.ipadTokenRetrievalUrl).then(function(response) {
                    // Slice to strip beginning and end double quotes
                    var url = preview.ipadUrl.replace("{IPAD_TOKEN}", response.data.slice(1, -1));
                    callback(url);
                });
            };

            // used to toggle boolean type attributes on a specific user
            User.prototype.$toggleAttribute = function(attr) {
                var self = this;

                if (!self.userAttributes) {
                    return;
                }

                if (self.userAttributes[attr]) {
                    self.userAttributes[attr] = false;
                } else {
                    self.userAttributes[attr] = true;
                }

                // update server to match
                var promise = $http.post(restPath + '/user/attribute', $.param({
                    key: attr,
                    val: self.userAttributes[attr]
                }));

                return promise;
            };

            User.prototype.getPrimaryOrg = function () {
                var self = this;
                var primaryOrgId = self.primaryOrgId;
                if(primaryOrgId) {
                    var allOrgs = self.oleAffiliations;
                    return _.findWhere(allOrgs, {"organizationId": primaryOrgId}) || false;
                } else {
                    return false;
                }
            };

            User.prototype.getPrimaryOrgName = function() {
                var self = this;

                var primaryOrg = self.getPrimaryOrg();
                return primaryOrg && primaryOrg.orgDetails ? primaryOrg.orgDetails.name : false;
            };

            User.prototype.setAttribute = function(attr, value, persist) {
                var self = this,
                    deferred = $q.defer();

                if (!angular.isDefined(persist)) {
                    persist = true;
                }

                if (!self.userAttributes || self.getAttribute(attr) === value) {
                    //$log.log('attribute set or invalid', self.userAttributes);
                    deferred.resolve();
                    return deferred.promise;
                }

                // update in-memory value prior to any conversion, memory object should remain usable
                self.userAttributes[attr] = angular.copy(value);

                // convert value to JSON if needed, attributes must be strings
                if (!angular.isString(value)) {
                    value = angular.toJson(value);
                }

                if (persist) {
                    var promise = $http.post(restPath + "/user/attribute", $.param({
                        key: attr,
                        val: value
                    }));

                    return promise;
                } else {
                    // we might not want to persist, in the case we are updating memory object of NOT the current user
                    // back end currently only supports currentuser
                    deferred.resolve();
                    return deferred.promise;
                }
            };

            // get a single attribute from the user attributes
            // if getSync is true, fetch user attribute from server
            User.prototype.getAttribute = function(key, getAsync) {
                var self = this,
                    value;

                if (!self.userAttributes) {
                    return;
                }

                if (getAsync) {
                    var promise = $http.get(restPath + "/user/attribute").then(function(response) {
                        self.userAttributes[key] = response.data[key];
                    });

                    return promise;
                }

                try {
                    // some values are not going to be JSON encoded, hence the try/catch block
                    value = angular.fromJson(self.userAttributes[key]);
                } catch (e) {
                    //$log.warn("User.getAttribute, attribute was not JSON (OK: key, val)", key, this.userAttributes[key]);
                    value = self.userAttributes[key];
                }

                return value;
            };

            User.prototype.hasRole = function(role) {
                return _.contains(this.roles, role);
            };

            User.prototype.$hasCenter = function() {
                var user = this;

                return user.isLibraryAdmin || user.getAttribute('hasCenter');
            };

            // another case of #RESTFAIL
            /*
                    @RequestParam(required = true) String firstName,
                    @RequestParam(required = true) String lastName,
                    @RequestParam(required = true) String userName,
                    @RequestParam(required = true) String password,
                    @RequestParam(value = "orgIds[]", required = true) ArrayList<String> orgIds) {
                */
            // this might also be better as $save that does checking for create/update
            User.prototype.$create = function() {
                var user = this;

                var promise = $http.post(restPath + '/rumba/user/create_user', {
                    firstName: user.firstName,
                    lastName: user.lastName,
                    userName: user.userName,
                    password: user.password,
                    'orgIds[]': [user.organizationId]
                });

                // update user with server info when done
                promise.success(function(response) {
                    angular.extend(user, response);
                });

                return promise;
            };

            User.prototype.$save = function() {
                // if userId is present, update, else new
                var self = this,
                    url = restPath + '/user',
                    isUpdate = false,
                    outData;

                if (angular.isDefined(self.userId) && self.userId.length > 0) {
                    url += '/' + self.userId;
                    isUpdate = true;
                }

                // new user is expecting "orgIds"
                if (self.organizationId) {
                    self.orgIds = [self.organizationId];
                } else if (self.primaryOrgIds && self.primaryOrgIds.length > 0) {
                    self.orgIds = self.primaryOrgIds;
                } else if (self.primaryOrgId && self.primaryOrgId.length > 0) {
                    self.orgIds = [self.primaryOrgId];
                } else {
                    // no org ids given, might be OK if updating
                    self.orgIds = [];
                }

                // copy data so as to not make adjustments for the controller on the actual object
                outData = angular.copy(self);

                if (isUpdate) {
                    outData.password = null; // for some reason the ctrl requires this on the back end.(todo: fix)
                    // also middleName is required
                    if (!outData.middleName) {
                        outData.middleName = null;
                    }
                }

                var promise = $http.post(url, outData)
                    .then(function(response) {
                        $log.log('saved user', response);
                        delete response.data.password;
                        angular.extend(self, response.data);

                        return self;
                    }, function(response) {
                        // RUMBA warning of username automatically generated
                        if (response.errorCode === "ULC0003W") {
                            angular.extend(self, response.data);

                            return self;
                        } else {
                            $log.error('RUMBA creation ERROR:', response);
                            return $q.reject('RUMBA creation ERROR:' + response);
                        }
                    });

                return promise;
            };

            User.prototype.$update = function() {
                var url = restPath + '/user/' + this.userId;

                // todo: move to assignment service? something more specific?
                // tight coupling
                $rootScope.dirtyAssigneesData = true;

                var data = {
                    userName: this.userName,
                    firstName: this.firstName,
                    lastName: this.lastName,
                    emailAddress: this.emailAddress,
                    password: this.password
                };
                if (this.middleName && this.middleName.length > 0) {
                    data.middleName = this.middleName;
                }

                return $http.post(url, data);
            };

            User.prototype.$setPassword = function(password) {
                this.password = password;

                var url = restPath + '/user/' + this.userName + '/password/' + encodeURIComponent(password);

                return $http.post(url);
            };

            User.prototype.$setFirstName = function(name) {
                this.firstName = name;
                this.$updateNames();
            };

            User.prototype.$setLastName = function(name) {
                this.lastName = name;
                this.$updateNames();
            };

            User.prototype.$setMiddleName = function(name) {
                var self = this;

                this.middleName = name;
                this.setAttribute('profile.middleName', name, self.userId === $rootScope.currentUser.userId).then(function() {
                    self.$updateNames();
                });
            };

            User.prototype.$setLastFirst = function(name) {
                // test to prevent errors in split below
                if (!angular.isString(name) || name.search(',') === -1) {
                    return;
                }

                var names = name.split(','),
                    last = $.trim(names[0]),
                    first = $.trim(names[1]);

                this.firstName = first;
                this.lastName = last;

                this.$updateNames();
            };

            User.prototype.$updateNames = function() {
                // middleName doesn't exist at rumba level, it's in the UA
                if (!angular.isString(this.middleName) && this.getAttribute('profile.middleName')) {
                    this.middleName = this.getAttribute('profile.middleName');
                }
                if (this.middleName && $.trim(this.middleName).length > 0) {
                    this.fullName = [this.firstName, this.middleName, this.lastName].join(' ');
                } else {
                    this.fullName = [this.firstName, this.lastName].join(' ');
                }
                this.firstAndLast = [this.firstName, this.lastName].join(' ');
                this.lastFirst = [this.lastName, this.firstName].join(', ');
            };

            // subscribe this user to a list of product names
            // if it's not in availableCourses list it won't work
            User.prototype.$subscribeTo = function(products) {
                var self = this;

                if (!angular.isArray(products)) {
                    products = [products];
                }

                // server needs RESTful update...
                var promise = $http.post(restPath + '/user/subscribe', $.param({
                    'courses[]': products
                }));

                promise.success(function(response) {
                    // the response should be an array of products, update user object
                    self.subscribedCourses = response;
                    angular.forEach(self.oleAffiliations, function(affiliation) {
                        angular.forEach(affiliation.products, function(product) {
                            if (_.indexOf(self.subscribedCourses, product.productName) >= 0) {
                                product.subscribed = true;
                            }
                        });
                    });
                });

                return promise;
            };

            User.prototype.$canCustomizeItems = function() {
                return $rootScope.currentUser.hasRole("ROLE_TEACHER");
            };

            return User;
        }
    ]);;angular.module('Realize.core.services.userSvc', [
    'Realize.core.services.user',
    'Realize.core.configs.REST_PATH'
])
    .service('UserSvc', [
        '$http',
        '$log',
        '$q',
        '$rootScope',
        'User',
        'REST_PATH',
        function($http, $log, $q, $rootScope, User, restPath) {
            // this would just be query, but the backend isn't RESTful yet
            /*
                @RequestParam(value = "firstname", required = false) String firstName,
                @RequestParam(value = "lastname", required = false) String lastName,
                @RequestParam(value = "username", required = false) String userName,
                @RequestParam(value = "organization", required = false) String organizationId,
                @RequestParam(value = "page", required = false, defaultValue = "1") int page,
                @RequestParam(value = "pageSize", required = false, defaultValue = "4") int pageSize,
                @RequestParam(value = "!username[]", required = false) ArrayList<String> notUserNames,
                @RequestParam(value = "!userid[]", required = false) ArrayList<String> notUserIds) {
            */
            this.findStudents = function(params) {
                $log.log('findStudents', params);
                var result = [];

                if (!angular.isDefined(params)) {
                    params = {};
                }

                if (!angular.isDefined(params.pageSize)) {
                    params.pageSize = 15;
                }

                $http.get(restPath + '/student_search', {
                    params: params
                })
                    .success(function(response) {
                        var results = [];

                        angular.forEach(response.users, function(u) {
                            results.push(new User(u.rumbaUser));
                        });

                        // copy to future to preserve reference
                        angular.copy(results, result);
                    });

                return result;
            };

            // query for students
            this.query = function(params, cache) {
                var url = restPath + '/student_search';

                if (!angular.isDefined(params)) {
                    params = {};
                }

                if (!angular.isDefined(params.pageSize)) {
                    params.pageSize = 50; // max users to be found
                }

                // need to add * to query params for name
                if (angular.isDefined(params.firstname)) {
                    params.firstname += '*';
                }
                if (angular.isDefined(params.lastname)) {
                    params.lastname += '*';
                }

                return $http.get(url, {
                        params: params,
                        cache: !!cache
                    })
                    .then(function(response) {
                        var results = [];
                        angular.forEach(response.data.users, function(u) {
                            // copy over the attributes so they get in the ctor
                            u.rumbaUser.userAttributes = u.attributes;
                            results.push(new User(u.rumbaUser));
                        });

                        return results;
                    }, function(err) {
                        return $q.reject(err);
                    });
            };

            // Get student by userId
            this.getUserById = function(userId) {
                var url = restPath + "/user/" + userId;
                return $http.get(url)
                    .then(function(response) {
                        return response.data;
                    }, function(error) {
                        return $q.reject(error);
                    });
            };

            // matches with backend /user/profile
            // needs some refactoring on the back end prolly
            // need to be careful what you send as it's fragile about things like 'profile.password'
            this.updateCurrentUserAttributes = function(attributes) {
                return $http.post(restPath + '/user/profile', attributes)
                    .then(function() {
                        angular.extend($rootScope.currentUser.userAttributes, attributes);
                    }, function(response) {
                        $log.error('error updating user profile', response);
                    });
            };
        }
    ]);;angular.module('Realize.core.sessionTimeoutInterceptor', [])
    .config(['$httpProvider',
        function($httpProvider) {

            var interceptor = ['$rootScope', '$q',
                function($rootScope, $q) {
                    return {

                        response: function(response) {
                            return response;
                        },
                        responseError: function(response) {
                            switch (response.status) {
                                case 401:
                                    $rootScope.$broadcast('httpSessionTimedOut');
                                    return $q.defer().promise;

                                default:
                                    return $q.reject(response);
                            }
                        }
                    };
                }
            ];

            $httpProvider.interceptors.push(interceptor);
        }
    ]);;angular.module("Realize.core.paths",["Realize.core.configs.SCRIPT_PATH"]).provider("REALIZE_CORE_ROOT_PATH",function(){return{$get:["SCRIPT_PATH",function(a){return a+"/realize.core"}]}});angular.module("Realize.core.templates",["Realize.core.paths"]);angular.module("Realize.core","Realize.core.paths,Realize.core.templates,Realize.core.legacyApiSupport,Realize.core.sessionTimeoutInterceptor,Realize.core.directives.htmlUnsafe,Realize.core.filters.fileSize,Realize.core.filters.toArray,Realize.core.filters.capitalizeFirstWord,Realize.core.filters.letterizeNumber,Realize.core.filters.getExtension,Realize.core.filters.removeExtension,Realize.core.filters.underscores,Realize.core.filters.contains,Realize.core.filters.trunc,Realize.core.filters.nospace,Realize.core.filters.ellipses,Realize.core.filters.brStrip,Realize.core.filters.replace,Realize.core.filters.localize,Realize.core.filters.coerce,Realize.core.filters.handleEmptyResponse,Realize.core.services.browserInfo,Realize.core.services.debounce,Realize.core.services.log,Realize.core.services.messages,Realize.core.services.rumbaDataService,Realize.core.services.user,Realize.core.services.userSvc,Realize.core.services.isodate,Realize.core.services.accessibility,Realize.core.services.filesystem".split(","));angular.module("Realize.core.directives.htmlUnsafe",[]).directive("ngBindHtmlUnsafe",["$sce","$log","$parse",function(a,b,c){return{link:function(a,b,f){b.addClass("ng-binding").data("$binding",f.ngBindHtmlUnsafe);var i=c(f.ngBindHtmlUnsafe);a.$watch(function(){return(i(a)||"").toString()},function(a){b.html(a)})}}}]);angular.module("Realize.core.filters.brStrip",[]).filter("brStrip",["$log",function(a){return function(b){var c;try{c=b.replace(/<br\s*\/?\s*>/g,"")}catch(g){a.warn("the question/response text is not valid!!",b),c=b}return c}}]);angular.module("Realize.core.filters.capitalizeFirstWord",[]).filter("capitalizeFirstWord",function(){return function(a){return a.charAt(0).toUpperCase()+a.substr(1).toLowerCase()}});angular.module("Realize.core.filters.coerce",[]).filter("coerce",["$log","$injector",function(a,b){return function(a,g){if(!angular.isUndefined(a)&&!angular.isUndefined(g)){var d=[],f=angular.isFunction(g)?g:b.get(g);if(f)return angular.isArray(a)?(angular.forEach(a,function(a){d.push(new f(a))}),d):new f(a)}}}]);angular.module("Realize.core.filters.contains",[]).filter("contains",function(){return function(a,b,c){if(!a)return!1;c||(c="ig");return 0<=a.search(RegExp(b,c))}});angular.module("Realize.core.filters.ellipses",[]).filter("ellipses",function(){return function(a,b,c){if(a&&b)return c||(c="..."),a.length<=b?a:a.substr(0,b)+c}});angular.module("Realize.core.filters.fileSize",[]).filter("fileSize",function(){var a=function(a,c,g,d){var a=a.toString().replace(",","").replace(" ",""),a=!isFinite(+a)?0:+a,c=!isFinite(+c)?0:Math.abs(c),d=d?",":d,g=g?".":g,f="",f=(c?function(a,c){var b=Math.pow(10,c);return(Math.round(a*b)/b).toString()}(a,c):Math.round(a).toString()).split(".");3<f[0].length&&(f[0]=f[0].replace(/\B(?=(?:\d{3})+(?!\d))/g,d));if((f[1]||"").length<c)for(f[1]=f[1]||"";f[1].length<c;)f[1]+="0";return f.join(g)};return function(b){return!b?
"N/A":1073741824<=b?a(b/1073741824,2,".","")+" GB":1048576<=b?a(b/1048576,2,".","")+" MB":1024<=b?a(b/1024,0)+" KB":a(b,0)+" bytes"}});angular.module("Realize.core.filters.getExtension",[]).filter("getExtension",function(){return function(a,b){var c=a.lastIndexOf("."),g=a.slice(c);return-1===c?b:g}});angular.module("Realize.core.filters.handleEmptyResponse",[]).filter("handleEmptyResponse",function(){return function(a){return null!==a&&0===a.length?"-":a}});angular.module("Realize.core.filters.letterizeNumber",[]).filter("letterizeNumber",function(){return function(a){return String.fromCharCode(65+a)}});angular.module("Realize.core.filters.localize",["Realize.core.services.messages"]).filter("localize",["Messages",function(a){return function(b,c){return angular.isArray(c)?a.getInterpolatedMessage(b,c):a.getMessage(b)}}]);angular.module("Realize.core.filters.nospace",[]).filter("nospace",function(){return function(a){return!a?void 0:a.replace(" ","")}});angular.module("Realize.core.filters.removeExtension",[]).filter("removeExtension",["$filter",function(){return function(a){var b=a.lastIndexOf(".");return-1===b?a:a.substring(0,b)}}]);angular.module("Realize.core.filters.replace",[]).filter("replace",function(){return function(a){if(a){if(1<arguments.length){var b;for(b=1;b<arguments.length;b++)a=a.replace("%"+b,arguments[b])}return a}}});angular.module("Realize.core.filters.toArray",[]).filter("toArray",function(){return function(a){if(a)return a instanceof Array?a:$.map(a,function(a){return a})}});angular.module("Realize.core.filters.trunc",[]).filter("trunc",function(){return function(a,b){return!a||!b?void 0:a.substr(0,b)}});angular.module("Realize.core.filters.underscores",[]).filter("underscores",function(){return function(a){return!a?void 0:a.replace(/ /g,"_")}});angular.module("Realize.core.globalConfig",[]).provider("globalConfig",[function(){var a={};this.setValue=function(b,c){a[b]=c};this.setConfig=function(b){angular.extend(a,b)};this.$get=[function(){return{get:function(b){var c=a[b];if(angular.isUndefined(c))throw Error("Value "+b+" has not been defined! This should be done during the app config phase.");return c}}}]}]);
angular.module("Realize.core.configs.REST_PATH",["Realize.core.globalConfig"]).provider("REST_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("REST_PATH")}]}]);angular.module("Realize.core.configs.SCRIPT_PATH",["Realize.core.globalConfig"]).provider("SCRIPT_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("SCRIPT_PATH")}]}]);
angular.module("Realize.core.configs.MEDIA_PATH",["Realize.core.globalConfig"]).provider("MEDIA_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("MEDIA_PATH")}]}]);angular.module("Realize.core.configs.CURRENT_USER",["Realize.core.globalConfig"]).provider("CURRENT_USER",[function(){this.$get=["globalConfig",function(a){return a.get("CURRENT_USER")}]}]);
angular.module("Realize.core.configs.ROOT_PATH",["Realize.core.globalConfig"]).provider("ROOT_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("ROOT_PATH")}]}]);angular.module("Realize.core.configs.LOGOUT_URL",["Realize.core.globalConfig"]).provider("LOGOUT_URL",[function(){this.$get=["globalConfig",function(a){return a.get("LOGOUT_URL")}]}]);angular.module("Realize.core.hashchangePrevention",[]).config(["$locationProvider","$browserProvider",function(a,b){var c=b.$get,g=c[c.length-1],c=a.$get,d=c[c.length-1];b.$get=["$window","$log","$sniffer","$document",function(a,c,b,h){c=g(a,c,b,h);c.onUrlChange=function(){};c.url=function(e){return e?void 0:a.location.href.replace(/%27/g,"'")};return c}];a.hashPrefix("");a.$get=["$rootScope","$browser","$sniffer","$rootElement",function(a,c,b,h){a=d(a,c,b,h);a.absUrl=function(){return c.url()};return a}]}]);angular.module("Realize.core.legacyApiSupport",[]).config(["$httpProvider",function(a){a.defaults.headers.post["Content-Type"]="application/x-www-form-urlencoded";a.defaults.headers.put["Content-Type"]="application/x-www-form-urlencoded";a.defaults.transformRequest=function(a){if(!angular.isObject(a))return a;var c={};angular.forEach(a,function(a,b){angular.isFunction(a)||(c[b]=a)});return $.param(c,!0)}}]);angular.module("Realize.core.paths",["Realize.core.configs.SCRIPT_PATH"]).provider("REALIZE_CORE_ROOT_PATH",function(){return{$get:["SCRIPT_PATH",function(a){return a+"/realize.core"}]}});angular.module("Realize.core.templates",["Realize.core.paths"]);angular.module("Realize.core","Realize.core.paths,Realize.core.templates,Realize.core.legacyApiSupport,Realize.core.sessionTimeoutInterceptor,Realize.core.directives.htmlUnsafe,Realize.core.filters.fileSize,Realize.core.filters.toArray,Realize.core.filters.capitalizeFirstWord,Realize.core.filters.letterizeNumber,Realize.core.filters.getExtension,Realize.core.filters.removeExtension,Realize.core.filters.underscores,Realize.core.filters.contains,Realize.core.filters.trunc,Realize.core.filters.nospace,Realize.core.filters.ellipses,Realize.core.filters.brStrip,Realize.core.filters.replace,Realize.core.filters.localize,Realize.core.filters.coerce,Realize.core.filters.handleEmptyResponse,Realize.core.services.browserInfo,Realize.core.services.debounce,Realize.core.services.log,Realize.core.services.messages,Realize.core.services.rumbaDataService,Realize.core.services.user,Realize.core.services.userSvc,Realize.core.services.isodate,Realize.core.services.accessibility,Realize.core.services.filesystem".split(","));
angular.module("Realize.core.directives.htmlUnsafe",[]).directive("ngBindHtmlUnsafe",["$sce","$log","$parse",function(a,b,c){return{link:function(a,b,f){b.addClass("ng-binding").data("$binding",f.ngBindHtmlUnsafe);var i=c(f.ngBindHtmlUnsafe);a.$watch(function(){return(i(a)||"").toString()},function(a){b.html(a)})}}}]);
angular.module("Realize.core.filters.brStrip",[]).filter("brStrip",["$log",function(a){return function(b){var c;try{c=b.replace(/<br\s*\/?\s*>/g,"")}catch(g){a.warn("the question/response text is not valid!!",b),c=b}return c}}]);angular.module("Realize.core.filters.capitalizeFirstWord",[]).filter("capitalizeFirstWord",function(){return function(a){return a.charAt(0).toUpperCase()+a.substr(1).toLowerCase()}});
angular.module("Realize.core.filters.coerce",[]).filter("coerce",["$log","$injector",function(a,b){return function(a,g){if(!angular.isUndefined(a)&&!angular.isUndefined(g)){var d=[],f=angular.isFunction(g)?g:b.get(g);if(f)return angular.isArray(a)?(angular.forEach(a,function(a){d.push(new f(a))}),d):new f(a)}}}]);angular.module("Realize.core.filters.contains",[]).filter("contains",function(){return function(a,b,c){if(!a)return!1;c||(c="ig");return 0<=a.search(RegExp(b,c))}});
angular.module("Realize.core.filters.ellipses",[]).filter("ellipses",function(){return function(a,b,c){if(a&&b)return c||(c="..."),a.length<=b?a:a.substr(0,b)+c}});
angular.module("Realize.core.filters.fileSize",[]).filter("fileSize",function(){var a=function(a,c,g,d){var a=a.toString().replace(",","").replace(" ",""),a=!isFinite(+a)?0:+a,c=!isFinite(+c)?0:Math.abs(c),d=d?",":d,g=g?".":g,f="",f=(c?function(a,c){var b=Math.pow(10,c);return(Math.round(a*b)/b).toString()}(a,c):Math.round(a).toString()).split(".");3<f[0].length&&(f[0]=f[0].replace(/\B(?=(?:\d{3})+(?!\d))/g,d));if((f[1]||"").length<c)for(f[1]=f[1]||"";f[1].length<c;)f[1]+="0";return f.join(g)};return function(b){return!b?
"N/A":1073741824<=b?a(b/1073741824,2,".","")+" GB":1048576<=b?a(b/1048576,2,".","")+" MB":1024<=b?a(b/1024,0)+" KB":a(b,0)+" bytes"}});angular.module("Realize.core.filters.getExtension",[]).filter("getExtension",function(){return function(a,b){var c=a.lastIndexOf("."),g=a.slice(c);return-1===c?b:g}});angular.module("Realize.core.filters.handleEmptyResponse",[]).filter("handleEmptyResponse",function(){return function(a){return null!==a&&0===a.length?"-":a}});
angular.module("Realize.core.filters.letterizeNumber",[]).filter("letterizeNumber",function(){return function(a){return String.fromCharCode(65+a)}});angular.module("Realize.core.filters.localize",["Realize.core.services.messages"]).filter("localize",["Messages",function(a){return function(b,c){return angular.isArray(c)?a.getInterpolatedMessage(b,c):a.getMessage(b)}}]);angular.module("Realize.core.filters.nospace",[]).filter("nospace",function(){return function(a){return!a?void 0:a.replace(" ","")}});
angular.module("Realize.core.filters.removeExtension",[]).filter("removeExtension",["$filter",function(){return function(a){var b=a.lastIndexOf(".");return-1===b?a:a.substring(0,b)}}]);angular.module("Realize.core.filters.replace",[]).filter("replace",function(){return function(a){if(a){if(1<arguments.length){var b;for(b=1;b<arguments.length;b++)a=a.replace("%"+b,arguments[b])}return a}}});
angular.module("Realize.core.filters.toArray",[]).filter("toArray",function(){return function(a){if(a)return a instanceof Array?a:$.map(a,function(a){return a})}});angular.module("Realize.core.filters.trunc",[]).filter("trunc",function(){return function(a,b){return!a||!b?void 0:a.substr(0,b)}});angular.module("Realize.core.filters.underscores",[]).filter("underscores",function(){return function(a){return!a?void 0:a.replace(/ /g,"_")}});
angular.module("Realize.core.globalConfig",[]).provider("globalConfig",[function(){var a={};this.setValue=function(b,c){a[b]=c};this.setConfig=function(b){angular.extend(a,b)};this.$get=[function(){return{get:function(b){var c=a[b];if(angular.isUndefined(c))throw Error("Value "+b+" has not been defined! This should be done during the app config phase.");return c}}}]}]);
angular.module("Realize.core.configs.REST_PATH",["Realize.core.globalConfig"]).provider("REST_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("REST_PATH")}]}]);angular.module("Realize.core.configs.SCRIPT_PATH",["Realize.core.globalConfig"]).provider("SCRIPT_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("SCRIPT_PATH")}]}]);
angular.module("Realize.core.configs.MEDIA_PATH",["Realize.core.globalConfig"]).provider("MEDIA_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("MEDIA_PATH")}]}]);angular.module("Realize.core.configs.CURRENT_USER",["Realize.core.globalConfig"]).provider("CURRENT_USER",[function(){this.$get=["globalConfig",function(a){return a.get("CURRENT_USER")}]}]);
angular.module("Realize.core.configs.ROOT_PATH",["Realize.core.globalConfig"]).provider("ROOT_PATH",[function(){this.$get=["globalConfig",function(a){return a.get("ROOT_PATH")}]}]);angular.module("Realize.core.configs.LOGOUT_URL",["Realize.core.globalConfig"]).provider("LOGOUT_URL",[function(){this.$get=["globalConfig",function(a){return a.get("LOGOUT_URL")}]}]);
angular.module("Realize.core.hashchangePrevention",[]).config(["$locationProvider","$browserProvider",function(a,b){var c=b.$get,g=c[c.length-1],c=a.$get,d=c[c.length-1];b.$get=["$window","$log","$sniffer","$document",function(a,c,b,h){c=g(a,c,b,h);c.onUrlChange=function(){};c.url=function(e){return e?void 0:a.location.href.replace(/%27/g,"'")};return c}];a.hashPrefix("");a.$get=["$rootScope","$browser","$sniffer","$rootElement",function(a,c,b,h){a=d(a,c,b,h);a.absUrl=function(){return c.url()};return a}]}]);
angular.module("Realize.core.legacyApiSupport",[]).config(["$httpProvider",function(a){a.defaults.headers.post["Content-Type"]="application/x-www-form-urlencoded";a.defaults.headers.put["Content-Type"]="application/x-www-form-urlencoded";a.defaults.transformRequest=function(a){if(!angular.isObject(a))return a;var c={};angular.forEach(a,function(a,b){angular.isFunction(a)||(c[b]=a)});return $.param(c,!0)}}]);
angular.module("Realize.core.services.NavigationBlocker",["ui.router"]).factory("NavigationBlocker",["$log","$rootScope",function(a,b){return function(a,g){var d=!1;this.start=function(){d=!0};this.stop=function(){d=!1};a.$on("$stateChangeStart",function(a,c,k,h,e){d&&(a.preventDefault(),b.$broadcast("$stateChangePrevented",c,k,h,e),g(c,k))})}}]);
angular.module("Realize.core.services.accessibility",[]).service("AccessibilityService",["$log","$rootScope",function(a,b){var c=this,g=function(){b.isKeyboardInUse=!b.isKeyboardInUse;b.isKeyboardInUse&&angular.element("body").mousedown(function(a){angular.element(this).unbind(a);g();c.applyStyleToFocusableElements()})},d=function(){angular.element("body").keydown(function(){b.isKeyboardInUse||g();c.applyStyleToFocusableElements()})};c.init=function(){b.isKeyboardInUse=!1;d()};c.setFocusElements=
function(a){c.keyboardFocusableElements=a};c.applyStyleToFocusableElements=function(){angular.element(c.keyboardFocusableElements).toggleClass("kb-mode",b.isKeyboardInUse)};b.skipNav=function(a){a.stopPropagation();angular.element("#skipTarget").next("div").find(":focusable").first().focus()};b.$on("$viewContentLoaded",function(){c.applyStyleToFocusableElements()});return c}]);
angular.module("Realize.core.services.browserInfo",[]).service("BrowserInfo",["$window",function(a){var b=a.navigator?angular.lowercase(a.navigator.userAgent):"";this.browser={};this.OS={};this.browser.isFirefox=/firefox|iceweasel/i.test(b);this.browser.isMSIE=/msie|trident/i.test(b);if(this.browser.isMSIE){var c=navigator.userAgent.toLowerCase().match(/(?:msie |trident\/.*; rv:)(\d+)/);this.browser.msieVersion=c?parseInt(c[1],10):void 0}this.OS.isIOS=/(ipod|iphone|ipad)/i.test(b);this.OS.isIOS5=
this.OS.isIOS&&/OS 5_[0-9_]+ like Mac OS X/i.test(b);this.OS.isIDevice="iPad"===a.navigator.platform||"iPhone"===a.navigator.platform||"iPad Simulator"===a.navigator.platform||"iPhone Simulator"===a.navigator.platform;this.isRetina=2<=a.devicePixelRatio}]).run(["$rootScope","$window","BrowserInfo",function(a,b,c){var g=angular.element(b);a.isRetina=c.isRetina;a.isIDevice=c.OS.isIDevice;var d=function(){var c=b.orientation;a.iOrientation=0===c?"portrait":90===c?"landscape":-90===c?"landscape":180===
c?"portrait":"unknown"};d();a.iMode=980>=g.width()||"portrait"===a.iOrientation;g.on("resize",function(){a.$apply(function(){d();a.iMode=980>=g.width()||"portrait"===a.iOrientation})});g.on("orientationchange",function(){a.$apply(function(){d();a.iMode=980>=g.width()||"portrait"===a.iOrientation})});a.$watch("iMode",function(){a.$broadcast("orientationChange")});a.$on("destroy",function(){g.off("resize");g.off("orientationchange")})}]);
angular.module("Realize.core.services.debounce",[]).factory("$debounce",["$rootScope","$browser","$q","$exceptionHandler",function(a,b,c,g){function d(h,e,j){var d=c.defer(),m=d.promise,p=angular.isDefined(j)&&!j,l,o=!1;angular.forEach(i,function(a,e){angular.equals(i[e].fn,h)&&(o=!0,l=e)});o?(f[i[l].timeoutId].reject("bounced"),b.defer.cancel(i[l].timeoutId)):(l=k++,i[l]={fn:h});e=b.defer(function(){delete i[l];try{d.resolve(h())}catch(e){d.reject(e),g(e)}p||a.$apply()},e);i[l].timeoutId=e;j=function(){delete f[m.$$timeoutId]};
m.$$timeoutId=e;f[e]=d;m.then(j,j);return m}var f={},i={},k=0;d.cancel=function(a){return a&&f.hasOwnProperty(a.$$timeoutId)?(f[a.$$timeoutId].reject("canceled"),b.defer.cancel(a.$$timeoutId)):!1};return d}]);
angular.module("Realize.core.services.filesystem",[]).factory("fileSystem",["$q","$timeout","$window",function(a,b,c){function g(a,c){b(function(){a.resolve(c)})}function d(a,c){b(function(){a.reject(c)})}var f=a.defer();c.webkitStorageInfo.requestQuota(c.PERSISTENT,5242880,function(a){c.webkitRequestFileSystem(c.PERSISTENT,a,function(a){g(f,a)},function(a){d(f,{text:"Error requesting File System access",obj:a})})},function(a){d(f,{text:"Error requesting Quota",obj:a})});var i={getCurrentUsage:function(){var b=
a.defer();c.webkitStorageInfo.queryUsageAndQuota(c.PERSISTENT,function(a,e){g(b,{used:a,quota:e})},function(a){d(b,{text:"Error getting quota information",obj:a})});return b.promise},requestQuotaIncrease:function(b){var h=a.defer();c.webkitStorageInfo.requestQuota(c.PERSISTENT,1048576*b,function(a){g(h,a)},function(a){d(h,{text:"Error requesting quota increase",obj:a})});return h.promise},getFolderContents:function(c){var b=a.defer();f.promise.then(function(a){a.root.getDirectory(a.root.fullPath+
c,{},function(a){a.createReader().readEntries(function(a){g(b,a)},function(a){d(b,{text:"Error reading entries",obj:a})})},function(a){d(b,{text:"Error getting directory",obj:a})})},function(a){b.reject(a)});return b.promise},createFolder:function(c){function b(a,c){a.getDirectory(c[0],{create:!0},function(a){c.length?b(a,c.slice(1)):g(e,a)},function(a){d(e,{text:"Error creating directory",obj:a})})}var c=c.replace(/^\//,""),e=a.defer();f.promise.then(function(a){b(a.root,c.split("/"))},function(a){e.reject(a)});
return e.promise},deleteFolder:function(c,b){var b="undefined"===typeof b?!1:b,e=a.defer();f.promise.then(function(a){a.root.getDirectory(c,{},function(a){var c=function(){g(e,"")},j=function(a){d(e,{text:"Error removing directory",obj:a})};b?a.removeRecursively(c,j):a.remove(c,j)},function(a){d(e,{text:"Error getting directory",obj:a})})},function(a){e.reject(a)});return e.promise},writeFileInput:function(c,h,e){var j=a.defer(),n=new window.FileReader;n.onload=function(a){var h=a.target.result;b(function(){i.writeArrayBuffer(c,
h,e).then(function(){g(j,"")},function(a){d(j,a)})})};n.readAsArrayBuffer(h);return j.promise},writeText:function(a,b,e){e="undefined"===typeof e?!1:e;b=new c.Blob([b],{type:"text/plain"});return i.writeBlob(a,b,e)},writeJSON:function(a,b,e){e="undefined"===typeof e?!1:e;b=new c.Blob([b],{type:"application/json;charset=UTF-8"});return i.writeBlob(a,b,e)},writeArrayBuffer:function(a,b,e,j){j="undefined"===typeof j?!1:j;b=new c.Blob([new window.Uint8Array(b)],{type:e});return i.writeBlob(a,b,j)},writeBlob:function(c,
b,e){var e="undefined"===typeof e?!1:e,j=a.defer();f.promise.then(function(a){a.root.getFile(c,{create:!0},function(a){a.createWriter(function(c){e&&c.seek(c.length);var k=!1;c.onwriteend=function(){k?g(j,a.toURL()):(k=!0,this.truncate(this.position))};c.onerror=function(a){d(j,{text:"Write failed",obj:a})};c.write(b)},function(a){d(j,{text:"Error creating file",obj:a})})},function(a){d(j,{text:"Error getting file",obj:a})})},function(a){j.reject(a)});return j.promise},readFile:function(b,h){var e=
a.defer(),h=h||"text";f.promise.then(function(a){a.root.getFile(b,{},function(a){a.file(function(a){var b=new c.FileReader;b.onloadend=function(){g(e,this.result)};b.onerror=function(a){d(e,{text:"Error reading file",obj:a})};switch(h){case "arraybuffer":b.readAsArrayBuffer(a);break;case "binarystring":b.readAsBinaryString(a);break;case "dataurl":b.readAsDataURL(a);break;default:b.readAsText(a)}},function(a){d(e,{text:"Error getting file",obj:a})})},function(a){d(e,{text:"Error getting file",obj:a})})},
function(a){e.reject(a)});return e.promise},deleteFile:function(c){var b=a.defer();f.promise.then(function(a){a.root.getFile(c,{create:!1},function(a){a.remove(function(){g(b,"")},function(a){d(b,{text:"Error deleting file",obj:a})})})},function(a){b.reject(a)});return b.promise}};return i}]);
angular.module("Realize.core.services.isodate",[]).service("ISODateService",["$log",function(){this.toDateTimeString=function(a){return a.toString("yyyy-MM-ddTHH:mm:ss")+this.getOffsetFromUTC(a)};this.toDateString=function(a){return a.toString("yyyy-MM-dd")};this.toStartOfDayStringWithZone=this.toDateStringWithZone=function(a){return a.toString("yyyy-MM-ddT00:00:00")+this.getOffsetFromUTC(a)};this.toStartOfNextDayStringWithZone=function(a){return this.toDateTimeString(a.clone().clearTime().add({days:1}))};
this.toEndOfDayStringWithZone=function(a){return this.toDateTimeString(a.clone().clearTime().add({hours:23,minutes:59,seconds:59}))};this.getStringForOffset=function(a){return(0>a?"+":"-")+this.pad(Math.floor(Math.abs(a)/60),2)+":"+this.pad(Math.abs(a)%60,2)};this.getOffsetFromUTC=function(a){angular.isUndefined(a)&&(a=new Date);return this.getStringForOffset(a.getTimezoneOffset())};this.pad=function(a,b,c){angular.isUndefined(b)&&(b=2);angular.isUndefined(c)&&(c="0");for(a=""+a;a.length<b;)a=c+a;
return a}}]);angular.module("Realize.core.services.log",[]).value("LOG_LEVEL",5).config(["$provide",function(a){a.decorator("$log",["LOG_LEVEL","$delegate",function(a,c){var g=c.log,d=c.debug,f=c.warn,i=c.info,k=c.error;c.log=function(){3<=a&&g.apply(c,arguments)};c.debug=function(){5<=a&&d.apply(c,arguments)};c.warn=function(){2<=a&&f.apply(c,arguments)};c.info=function(){4<=a&&i.apply(c,arguments)};c.error=function(){1<=a&&k.apply(c,arguments)};return c}])}]);
angular.module("Realize.core.services.messages",[]).provider("Messages",[function(){var a,b={};this.setLanguageFilePath=function(c){a=c};this.addCache=function(a,g){b[a]=g};this.$get=["$http","$log","$q","$filter","$cacheFactory",function(c,g,d,f,i){var k=this,h={},e=i.get("$http");_.each(b,function(a,c){e.put(c,a)});if(!a)throw"Error [MessagesProvider]: languageFilePath must be configured!";k.load=function(e,b,f){e=e||"en";k.currentLocale=e;angular.isDefined(f)||(f=!0);e=a+"/messages_"+e+".json";
g.log("messages loading file",e,"override",b,{cache:!b});b&&(e=b);return c.get(e,{cache:!b}).then(function(a){f&&angular.copy(a.data,h);return a.data},function(a){g.warn("error loading locale file!",a);return d.reject(a)})};k.getMessage=function(a,e){var c=a.split("."),b=h,d;for(d=0;d<c.length;d++)if(b[c[d]])b=b[c[d]];else{b=null;break}return e?b:angular.isString(b)?b:null};k.getInterpolatedMessage=function(a,e){var c,b=k.getMessage(a);null===b&&(b="");for(c=0;c<e.length;c+=1)b=b.replace("{"+c+"}",
e[c]);return b};k.getMessageOrDefault=function(a,e){var c=k.getMessage(a);return null===c?e:c};k.getMessagesAsArray=function(a){return f("toArray")(k.getMessage(a,!0))};return k}]}]);
angular.module("Realize.core.services.poller",[]).service("Poller",["$http","$q","$timeout","$log",function(a,b,c,g){var d={},f=this,i=function(a,b,e,j){return a.then(function(a){d[b]&&"polling"===d[b].status?(d[b].poll=c(e,j),i(d[b].poll,b,e,j),d[b].deferred.notify(a)):f.stop(b)},function(a){g.log(b+" timeout rejected: ",a);if(d[b]&&d[b].deferred)return d[b].deferred.reject(a)})};this.start=function(a,h,e){var j=b.defer();if(!d[a])d[a]={},d[a].method=h,d[a].interval=e,d[a].deferred=j,d[a].status=
"polling",d[a].poll=c(h,e),i(d[a].poll,a,h,e);return d[a].deferred.promise};this.stop=function(a){d[a]?(c.cancel(d[a].poll),d[a].status="stopped",d[a].deferred.reject("stopped")):g.warn("no poller found: ",a)};this.list=function(){return Object.keys(d)};this.$$getPolls=function(){return d};this.clearAll=function(){var a=this;angular.forEach(d,function(b,e){a.clear(e)})};this.clear=function(a){this.stop(a);delete d[a]};this.restart=function(a){if(!d[a])return b.reject("no poll found");var c=d[a].method,
e=d[a].interval;this.clear(a);return this.start(a,c,e)}}]);
angular.module("Realize.core.services.rumbaDataService",["Realize.core.configs.REST_PATH"]).service("RumbaDataService",["$http","$q","REST_PATH",function(a,b,c){this.getOrgDetails=function(b,d){var f=a({url:c+"/rumba/orgs",method:"GET",params:{"id[]":b},cache:!0});d&&f.success(d);return f};this.getChildOrgs=function(){return a.get(c+"/rumba/orgs/children",{cache:!0}).then(function(a){return a.data},function(a){return b.reject(a)})};this.checkUsernameAvailability=function(b,d){var f=a({url:c+"/check_username",
method:"GET",params:{username:b}});d&&f.success(d);return f};this.getProductDetails=function(b,d){var f=a({url:c+"/rumba/products/"+b,method:"GET",cache:!0});d&&f.success(d);return f}}]);
angular.module("Realize.core.services.user",["Realize.core.services.rumbaDataService","Realize.core.services.messages","Realize.core.configs.REST_PATH","Realize.core.configs.MEDIA_PATH","Realize.core.configs.CURRENT_USER"]).run(["User","$rootScope","CURRENT_USER",function(a,b,c){b.currentUser=new a(c)}]).factory("User",["$q","$http","$log","REST_PATH","RumbaDataService","MEDIA_PATH","$rootScope","Messages",function(a,b,c,g,d,f,i,k){function h(a){var b=this;b.userAttributes={};a&&angular.copy(a,b);
b.emailAddress=b.rumbaEmail;b.$updateNames();b.oleAffiliations=_.uniq(b.oleAffiliations,function(a){return a.organizationId});a=_.pluck(b.oleAffiliations,"organizationId");0<a.length&&d.getOrgDetails(a,function(a){angular.forEach(a,function(a){var e=_.findWhere(b.oleAffiliations,{organizationId:a.organizationId});if(e)e.orgDetails=a})});"Student"===b.primaryOrgRole&&"lti-org-id"!==b.primaryOrgId&&"student_center_org_id"!==b.primaryOrgId&&d.getProductDetails(b.primaryOrgId,function(a){b.productIdMap=
{};angular.forEach(a,function(a){b.productIdMap[a.productId]=a.productDisplayName})});b.$setAvatar(b.getAttribute("profile.avatar"));b.isLibraryAdmin=b.hasRole("ROLE_LIBRARY_ADMIN");b.isTeacher=b.hasRole("ROLE_TEACHER");b.isStudent=b.hasRole("ROLE_STUDENT");b.isReviewer=b.hasRole("ROLE_REVIEWER")}h.prototype.$setAvatar=function(e){var b=this,c=a.defer();b.setAttribute("profile.avatar",e,!0).then(function(){var a=f+"/skins/default/images/profile_icons/",e=b.getAttribute("profile.avatar"),a="Student"===
b.primaryOrgRole?a+(e||"default_student"):a+(e||"default_teacher");b.avatarUrl=a+(i.isRetina?"@2x.png":".png");c.resolve(b)},c.reject);return c.promise};h.prototype.$setLocale=function(a){var a=a||"en",b=this;c.log("user $setLocale",a);return b.setAttribute("profile.locale",a).then(function(){k.load(a,b.getAttribute("admin.previewMode")?b.getAttribute("admin.localeOverride"):null)})};h.prototype.$getIpadPreview=function(a,c){b.get(a.ipadTokenRetrievalUrl).then(function(b){b=a.ipadUrl.replace("{IPAD_TOKEN}",
b.data.slice(1,-1));c(b)})};h.prototype.$toggleAttribute=function(a){if(this.userAttributes)return this.userAttributes[a]=this.userAttributes[a]?!1:!0,b.post(g+"/user/attribute",$.param({key:a,val:this.userAttributes[a]}))};h.prototype.getPrimaryOrg=function(){var a=this.primaryOrgId;return a?_.findWhere(this.oleAffiliations,{organizationId:a})||!1:!1};h.prototype.getPrimaryOrgName=function(){var a=this.getPrimaryOrg();return a&&a.orgDetails?a.orgDetails.name:!1};h.prototype.setAttribute=function(e,
c,d){var h=a.defer();angular.isDefined(d)||(d=!0);if(!this.userAttributes||this.getAttribute(e)===c)return h.resolve(),h.promise;this.userAttributes[e]=angular.copy(c);angular.isString(c)||(c=angular.toJson(c));if(d)return b.post(g+"/user/attribute",$.param({key:e,val:c}));h.resolve();return h.promise};h.prototype.getAttribute=function(a,c){var d=this,h;if(d.userAttributes){if(c)return b.get(g+"/user/attribute").then(function(b){d.userAttributes[a]=b.data[a]});try{h=angular.fromJson(d.userAttributes[a])}catch(f){h=
d.userAttributes[a]}return h}};h.prototype.hasRole=function(a){return _.contains(this.roles,a)};h.prototype.$hasCenter=function(){return this.isLibraryAdmin||this.getAttribute("hasCenter")};h.prototype.$create=function(){var a=this,c=b.post(g+"/rumba/user/create_user",{firstName:a.firstName,lastName:a.lastName,userName:a.userName,password:a.password,"orgIds[]":[a.organizationId]});c.success(function(b){angular.extend(a,b)});return c};h.prototype.$save=function(){var e=this,d=g+"/user",h=!1,f;angular.isDefined(e.userId)&&
0<e.userId.length&&(d+="/"+e.userId,h=!0);e.orgIds=e.organizationId?[e.organizationId]:e.primaryOrgIds&&0<e.primaryOrgIds.length?e.primaryOrgIds:e.primaryOrgId&&0<e.primaryOrgId.length?[e.primaryOrgId]:[];f=angular.copy(e);if(h&&(f.password=null,!f.middleName))f.middleName=null;return b.post(d,f).then(function(a){c.log("saved user",a);delete a.data.password;angular.extend(e,a.data);return e},function(b){if("ULC0003W"===b.errorCode)return angular.extend(e,b.data),e;c.error("RUMBA creation ERROR:",
b);return a.reject("RUMBA creation ERROR:"+b)})};h.prototype.$update=function(){var a=g+"/user/"+this.userId;i.dirtyAssigneesData=!0;var c={userName:this.userName,firstName:this.firstName,lastName:this.lastName,emailAddress:this.emailAddress,password:this.password};if(this.middleName&&0<this.middleName.length)c.middleName=this.middleName;return b.post(a,c)};h.prototype.$setPassword=function(a){this.password=a;a=g+"/user/"+this.userName+"/password/"+encodeURIComponent(a);return b.post(a)};h.prototype.$setFirstName=
function(a){this.firstName=a;this.$updateNames()};h.prototype.$setLastName=function(a){this.lastName=a;this.$updateNames()};h.prototype.$setMiddleName=function(a){var b=this;this.middleName=a;this.setAttribute("profile.middleName",a,b.userId===i.currentUser.userId).then(function(){b.$updateNames()})};h.prototype.$setLastFirst=function(a){if(angular.isString(a)&&-1!==a.search(",")){var a=a.split(","),b=$.trim(a[0]);this.firstName=$.trim(a[1]);this.lastName=b;this.$updateNames()}};h.prototype.$updateNames=
function(){if(!angular.isString(this.middleName)&&this.getAttribute("profile.middleName"))this.middleName=this.getAttribute("profile.middleName");this.fullName=this.middleName&&0<$.trim(this.middleName).length?[this.firstName,this.middleName,this.lastName].join(" "):[this.firstName,this.lastName].join(" ");this.firstAndLast=[this.firstName,this.lastName].join(" ");this.lastFirst=[this.lastName,this.firstName].join(", ")};h.prototype.$subscribeTo=function(a){var c=this;angular.isArray(a)||(a=[a]);
a=b.post(g+"/user/subscribe",$.param({"courses[]":a}));a.success(function(a){c.subscribedCourses=a;angular.forEach(c.oleAffiliations,function(a){angular.forEach(a.products,function(a){if(0<=_.indexOf(c.subscribedCourses,a.productName))a.subscribed=!0})})});return a};h.prototype.$canCustomizeItems=function(){return i.currentUser.hasRole("ROLE_TEACHER")};return h}]);
angular.module("Realize.core.services.userSvc",["Realize.core.services.user","Realize.core.configs.REST_PATH"]).service("UserSvc",["$http","$log","$q","$rootScope","User","REST_PATH",function(a,b,c,g,d,f){this.findStudents=function(c){b.log("findStudents",c);var g=[];angular.isDefined(c)||(c={});if(!angular.isDefined(c.pageSize))c.pageSize=15;a.get(f+"/student_search",{params:c}).success(function(a){var b=[];angular.forEach(a.users,function(a){b.push(new d(a.rumbaUser))});angular.copy(b,g)});return g};
this.query=function(b,g){var h=f+"/student_search";angular.isDefined(b)||(b={});if(!angular.isDefined(b.pageSize))b.pageSize=50;angular.isDefined(b.firstname)&&(b.firstname+="*");angular.isDefined(b.lastname)&&(b.lastname+="*");return a.get(h,{params:b,cache:!!g}).then(function(a){var b=[];angular.forEach(a.data.users,function(a){a.rumbaUser.userAttributes=a.attributes;b.push(new d(a.rumbaUser))});return b},function(a){return c.reject(a)})};this.getUserById=function(b){return a.get(f+"/user/"+b).then(function(a){return a.data},
function(a){return c.reject(a)})};this.updateCurrentUserAttributes=function(c){return a.post(f+"/user/profile",c).then(function(){angular.extend(g.currentUser.userAttributes,c)},function(a){b.error("error updating user profile",a)})}}]);
angular.module("Realize.core.sessionTimeoutInterceptor",[]).config(["$httpProvider",function(a){a.interceptors.push(["$rootScope","$q",function(a,c){return{response:function(a){return a},responseError:function(g){switch(g.status){case 401:return a.$broadcast("httpSessionTimedOut"),c.defer().promise;default:return c.reject(g)}}}}])}]);angular.module("Realize.core.services.NavigationBlocker",["ui.router"]).factory("NavigationBlocker",["$log","$rootScope",function(a,b){return function(a,g){var d=!1;this.start=function(){d=!0};this.stop=function(){d=!1};a.$on("$stateChangeStart",function(a,c,k,h,e){d&&(a.preventDefault(),b.$broadcast("$stateChangePrevented",c,k,h,e),g(c,k))})}}]);angular.module("Realize.core.services.accessibility",[]).service("AccessibilityService",["$log","$rootScope",function(a,b){var c=this,g=function(){b.isKeyboardInUse=!b.isKeyboardInUse;b.isKeyboardInUse&&angular.element("body").mousedown(function(a){angular.element(this).unbind(a);g();c.applyStyleToFocusableElements()})},d=function(){angular.element("body").keydown(function(){b.isKeyboardInUse||g();c.applyStyleToFocusableElements()})};c.init=function(){b.isKeyboardInUse=!1;d()};c.setFocusElements=
function(a){c.keyboardFocusableElements=a};c.applyStyleToFocusableElements=function(){angular.element(c.keyboardFocusableElements).toggleClass("kb-mode",b.isKeyboardInUse)};b.skipNav=function(a){a.stopPropagation();angular.element("#skipTarget").next("div").find(":focusable").first().focus()};b.$on("$viewContentLoaded",function(){c.applyStyleToFocusableElements()});return c}]);angular.module("Realize.core.services.browserInfo",[]).service("BrowserInfo",["$window",function(a){var b=a.navigator?angular.lowercase(a.navigator.userAgent):"";this.browser={};this.OS={};this.browser.isFirefox=/firefox|iceweasel/i.test(b);this.browser.isMSIE=/msie|trident/i.test(b);if(this.browser.isMSIE){var c=navigator.userAgent.toLowerCase().match(/(?:msie |trident\/.*; rv:)(\d+)/);this.browser.msieVersion=c?parseInt(c[1],10):void 0}this.OS.isIOS=/(ipod|iphone|ipad)/i.test(b);this.OS.isIOS5=
this.OS.isIOS&&/OS 5_[0-9_]+ like Mac OS X/i.test(b);this.OS.isIDevice="iPad"===a.navigator.platform||"iPhone"===a.navigator.platform||"iPad Simulator"===a.navigator.platform||"iPhone Simulator"===a.navigator.platform;this.isRetina=2<=a.devicePixelRatio}]).run(["$rootScope","$window","BrowserInfo",function(a,b,c){var g=angular.element(b);a.isRetina=c.isRetina;a.isIDevice=c.OS.isIDevice;var d=function(){var c=b.orientation;a.iOrientation=0===c?"portrait":90===c?"landscape":-90===c?"landscape":180===
c?"portrait":"unknown"};d();a.iMode=980>=g.width()||"portrait"===a.iOrientation;g.on("resize",function(){a.$apply(function(){d();a.iMode=980>=g.width()||"portrait"===a.iOrientation})});g.on("orientationchange",function(){a.$apply(function(){d();a.iMode=980>=g.width()||"portrait"===a.iOrientation})});a.$watch("iMode",function(){a.$broadcast("orientationChange")});a.$on("destroy",function(){g.off("resize");g.off("orientationchange")})}]);angular.module("Realize.core.services.debounce",[]).factory("$debounce",["$rootScope","$browser","$q","$exceptionHandler",function(a,b,c,g){function d(d,e,j){var n=c.defer(),m=n.promise,p=angular.isDefined(j)&&!j,l,o=!1;angular.forEach(i,function(a,b){angular.equals(i[b].fn,d)&&(o=!0,l=b)});o?(f[i[l].timeoutId].reject("bounced"),b.defer.cancel(i[l].timeoutId)):(l=k++,i[l]={fn:d});e=b.defer(function(){delete i[l];try{n.resolve(d())}catch(b){n.reject(b),g(b)}p||a.$apply()},e);i[l].timeoutId=e;j=function(){delete f[m.$$timeoutId]};
m.$$timeoutId=e;f[e]=n;m.then(j,j);return m}var f={},i={},k=0;d.cancel=function(a){return a&&f.hasOwnProperty(a.$$timeoutId)?(f[a.$$timeoutId].reject("canceled"),b.defer.cancel(a.$$timeoutId)):!1};return d}]);angular.module("Realize.core.services.filesystem",[]).factory("fileSystem",["$q","$timeout","$window",function(a,b,c){function g(a,c){b(function(){a.resolve(c)})}function d(a,c){b(function(){a.reject(c)})}var f=a.defer();c.webkitStorageInfo.requestQuota(c.PERSISTENT,5242880,function(a){c.webkitRequestFileSystem(c.PERSISTENT,a,function(a){g(f,a)},function(a){d(f,{text:"Error requesting File System access",obj:a})})},function(a){d(f,{text:"Error requesting Quota",obj:a})});var i={getCurrentUsage:function(){var b=
a.defer();c.webkitStorageInfo.queryUsageAndQuota(c.PERSISTENT,function(a,c){g(b,{used:a,quota:c})},function(a){d(b,{text:"Error getting quota information",obj:a})});return b.promise},requestQuotaIncrease:function(b){var h=a.defer();c.webkitStorageInfo.requestQuota(c.PERSISTENT,1048576*b,function(a){g(h,a)},function(a){d(h,{text:"Error requesting quota increase",obj:a})});return h.promise},getFolderContents:function(b){var c=a.defer();f.promise.then(function(a){a.root.getDirectory(a.root.fullPath+
b,{},function(a){a.createReader().readEntries(function(a){g(c,a)},function(a){d(c,{text:"Error reading entries",obj:a})})},function(a){d(c,{text:"Error getting directory",obj:a})})},function(a){c.reject(a)});return c.promise},createFolder:function(b){function c(a,b){a.getDirectory(b[0],{create:!0},function(a){b.length?c(a,b.slice(1)):g(e,a)},function(a){d(e,{text:"Error creating directory",obj:a})})}var b=b.replace(/^\//,""),e=a.defer();f.promise.then(function(a){c(a.root,b.split("/"))},function(a){e.reject(a)});
return e.promise},deleteFolder:function(b,c){var c="undefined"===typeof c?!1:c,e=a.defer();f.promise.then(function(a){a.root.getDirectory(b,{},function(a){var b=function(){g(e,"")},j=function(a){d(e,{text:"Error removing directory",obj:a})};c?a.removeRecursively(b,j):a.remove(b,j)},function(a){d(e,{text:"Error getting directory",obj:a})})},function(a){e.reject(a)});return e.promise},writeFileInput:function(c,h,e){var j=a.defer(),f=new window.FileReader;f.onload=function(a){var h=a.target.result;b(function(){i.writeArrayBuffer(c,
h,e).then(function(){g(j,"")},function(a){d(j,a)})})};f.readAsArrayBuffer(h);return j.promise},writeText:function(a,b,e){e="undefined"===typeof e?!1:e;b=new c.Blob([b],{type:"text/plain"});return i.writeBlob(a,b,e)},writeJSON:function(a,b,e){e="undefined"===typeof e?!1:e;b=new c.Blob([b],{type:"application/json;charset=UTF-8"});return i.writeBlob(a,b,e)},writeArrayBuffer:function(a,b,e,d){d="undefined"===typeof d?!1:d;b=new c.Blob([new window.Uint8Array(b)],{type:e});return i.writeBlob(a,b,d)},writeBlob:function(b,
c,e){var e="undefined"===typeof e?!1:e,j=a.defer();f.promise.then(function(a){a.root.getFile(b,{create:!0},function(a){a.createWriter(function(b){e&&b.seek(b.length);var f=!1;b.onwriteend=function(){f?g(j,a.toURL()):(f=!0,this.truncate(this.position))};b.onerror=function(a){d(j,{text:"Write failed",obj:a})};b.write(c)},function(a){d(j,{text:"Error creating file",obj:a})})},function(a){d(j,{text:"Error getting file",obj:a})})},function(a){j.reject(a)});return j.promise},readFile:function(b,h){var e=
a.defer(),h=h||"text";f.promise.then(function(a){a.root.getFile(b,{},function(a){a.file(function(a){var b=new c.FileReader;b.onloadend=function(){g(e,this.result)};b.onerror=function(a){d(e,{text:"Error reading file",obj:a})};switch(h){case "arraybuffer":b.readAsArrayBuffer(a);break;case "binarystring":b.readAsBinaryString(a);break;case "dataurl":b.readAsDataURL(a);break;default:b.readAsText(a)}},function(a){d(e,{text:"Error getting file",obj:a})})},function(a){d(e,{text:"Error getting file",obj:a})})},
function(a){e.reject(a)});return e.promise},deleteFile:function(b){var c=a.defer();f.promise.then(function(a){a.root.getFile(b,{create:!1},function(a){a.remove(function(){g(c,"")},function(a){d(c,{text:"Error deleting file",obj:a})})})},function(a){c.reject(a)});return c.promise}};return i}]);angular.module("Realize.core.services.isodate",[]).service("ISODateService",["$log",function(){this.toDateTimeString=function(a){return a.toString("yyyy-MM-ddTHH:mm:ss")+this.getOffsetFromUTC(a)};this.toDateString=function(a){return a.toString("yyyy-MM-dd")};this.toStartOfDayStringWithZone=this.toDateStringWithZone=function(a){return a.toString("yyyy-MM-ddT00:00:00")+this.getOffsetFromUTC(a)};this.toStartOfNextDayStringWithZone=function(a){return this.toDateTimeString(a.clone().clearTime().add({days:1}))};
this.toEndOfDayStringWithZone=function(a){return this.toDateTimeString(a.clone().clearTime().add({hours:23,minutes:59,seconds:59}))};this.getStringForOffset=function(a){return(0>a?"+":"-")+this.pad(Math.floor(Math.abs(a)/60),2)+":"+this.pad(Math.abs(a)%60,2)};this.getOffsetFromUTC=function(a){angular.isUndefined(a)&&(a=new Date);return this.getStringForOffset(a.getTimezoneOffset())};this.pad=function(a,b,c){angular.isUndefined(b)&&(b=2);angular.isUndefined(c)&&(c="0");for(a=""+a;a.length<b;)a=c+a;
return a}}]);angular.module("Realize.core.services.log",[]).value("LOG_LEVEL",5).config(["$provide",function(a){a.decorator("$log",["LOG_LEVEL","$delegate",function(a,c){var g=c.log,d=c.debug,f=c.warn,i=c.info,k=c.error;c.log=function(){3<=a&&g.apply(c,arguments)};c.debug=function(){5<=a&&d.apply(c,arguments)};c.warn=function(){2<=a&&f.apply(c,arguments)};c.info=function(){4<=a&&i.apply(c,arguments)};c.error=function(){1<=a&&k.apply(c,arguments)};return c}])}]);angular.module("Realize.core.services.messages",[]).provider("Messages",[function(){var a,b={};this.setLanguageFilePath=function(b){a=b};this.addCache=function(a,g){b[a]=g};this.$get=["$http","$log","$q","$filter","$cacheFactory",function(c,g,d,f,i){var k=this,h={},e=i.get("$http");_.each(b,function(a,b){e.put(b,a)});if(!a)throw"Error [MessagesProvider]: languageFilePath must be configured!";k.load=function(b,e,f){b=b||"en";k.currentLocale=b;angular.isDefined(f)||(f=!0);b=a+"/messages_"+b+".json";
g.log("messages loading file",b,"override",e,{cache:!e});e&&(b=e);return c.get(b,{cache:!e}).then(function(a){f&&angular.copy(a.data,h);return a.data},function(a){g.warn("error loading locale file!",a);return d.reject(a)})};k.getMessage=function(a,b){var c=a.split("."),e=h,d;for(d=0;d<c.length;d++)if(e[c[d]])e=e[c[d]];else{e=null;break}return b?e:angular.isString(e)?e:null};k.getInterpolatedMessage=function(a,b){var c,e=k.getMessage(a);null===e&&(e="");for(c=0;c<b.length;c+=1)e=e.replace("{"+c+"}",
b[c]);return e};k.getMessageOrDefault=function(a,b){var c=k.getMessage(a);return null===c?b:c};k.getMessagesAsArray=function(a){return f("toArray")(k.getMessage(a,!0))};return k}]}]);angular.module("Realize.core.services.poller",[]).service("Poller",["$http","$q","$timeout","$log",function(a,b,c,g){var d={},f=this,i=function(a,b,e,j){return a.then(function(a){d[b]&&"polling"===d[b].status?(d[b].poll=c(e,j),i(d[b].poll,b,e,j),d[b].deferred.notify(a)):f.stop(b)},function(a){g.log(b+" timeout rejected: ",a);if(d[b]&&d[b].deferred)return d[b].deferred.reject(a)})};this.start=function(a,g,e){var f=b.defer();if(!d[a])d[a]={},d[a].method=g,d[a].interval=e,d[a].deferred=f,d[a].status=
"polling",d[a].poll=c(g,e),i(d[a].poll,a,g,e);return d[a].deferred.promise};this.stop=function(a){d[a]?(c.cancel(d[a].poll),d[a].status="stopped",d[a].deferred.reject("stopped")):g.warn("no poller found: ",a)};this.list=function(){return Object.keys(d)};this.$$getPolls=function(){return d};this.clearAll=function(){var a=this;angular.forEach(d,function(b,c){a.clear(c)})};this.clear=function(a){this.stop(a);delete d[a]};this.restart=function(a){if(!d[a])return b.reject("no poll found");var c=d[a].method,
e=d[a].interval;this.clear(a);return this.start(a,c,e)}}]);angular.module("Realize.core.services.rumbaDataService",["Realize.core.configs.REST_PATH"]).service("RumbaDataService",["$http","$q","REST_PATH",function(a,b,c){this.getOrgDetails=function(b,d){var f=a({url:c+"/rumba/orgs",method:"GET",params:{"id[]":b},cache:!0});d&&f.success(d);return f};this.getChildOrgs=function(){return a.get(c+"/rumba/orgs/children",{cache:!0}).then(function(a){return a.data},function(a){return b.reject(a)})};this.checkUsernameAvailability=function(b,d){var f=a({url:c+"/check_username",
method:"GET",params:{username:b}});d&&f.success(d);return f};this.getProductDetails=function(b,d){var f=a({url:c+"/rumba/products/"+b,method:"GET",cache:!0});d&&f.success(d);return f}}]);angular.module("Realize.core.services.user",["Realize.core.services.rumbaDataService","Realize.core.services.messages","Realize.core.configs.REST_PATH","Realize.core.configs.MEDIA_PATH","Realize.core.configs.CURRENT_USER"]).run(["User","$rootScope","CURRENT_USER",function(a,b,c){b.currentUser=new a(c)}]).factory("User",["$q","$http","$log","REST_PATH","RumbaDataService","MEDIA_PATH","$rootScope","Messages",function(a,b,c,g,d,f,i,k){function h(a){var b=this;b.userAttributes={};a&&angular.copy(a,b);
b.emailAddress=b.rumbaEmail;b.$updateNames();b.oleAffiliations=_.uniq(b.oleAffiliations,function(a){return a.organizationId});a=_.pluck(b.oleAffiliations,"organizationId");0<a.length&&d.getOrgDetails(a,function(a){angular.forEach(a,function(a){var c=_.findWhere(b.oleAffiliations,{organizationId:a.organizationId});if(c)c.orgDetails=a})});"Student"===b.primaryOrgRole&&"lti-org-id"!==b.primaryOrgId&&"student_center_org_id"!==b.primaryOrgId&&d.getProductDetails(b.primaryOrgId,function(a){b.productIdMap=
{};angular.forEach(a,function(a){b.productIdMap[a.productId]=a.productDisplayName})});b.$setAvatar(b.getAttribute("profile.avatar"));b.isLibraryAdmin=b.hasRole("ROLE_LIBRARY_ADMIN");b.isTeacher=b.hasRole("ROLE_TEACHER");b.isStudent=b.hasRole("ROLE_STUDENT");b.isReviewer=b.hasRole("ROLE_REVIEWER")}h.prototype.$setAvatar=function(b){var c=this,d=a.defer();c.setAttribute("profile.avatar",b,!0).then(function(){var a=f+"/skins/default/images/profile_icons/",b=c.getAttribute("profile.avatar"),a="Student"===
c.primaryOrgRole?a+(b||"default_student"):a+(b||"default_teacher");c.avatarUrl=a+(i.isRetina?"@2x.png":".png");d.resolve(c)},d.reject);return d.promise};h.prototype.$setLocale=function(a){var a=a||"en",b=this;c.log("user $setLocale",a);return b.setAttribute("profile.locale",a).then(function(){k.load(a,b.getAttribute("admin.previewMode")?b.getAttribute("admin.localeOverride"):null)})};h.prototype.$getIpadPreview=function(a,c){b.get(a.ipadTokenRetrievalUrl).then(function(b){b=a.ipadUrl.replace("{IPAD_TOKEN}",
b.data.slice(1,-1));c(b)})};h.prototype.$toggleAttribute=function(a){if(this.userAttributes)return this.userAttributes[a]=this.userAttributes[a]?!1:!0,b.post(g+"/user/attribute",$.param({key:a,val:this.userAttributes[a]}))};h.prototype.getPrimaryOrg=function(){var a=this.primaryOrgId;return a?_.findWhere(this.oleAffiliations,{organizationId:a})||!1:!1};h.prototype.getPrimaryOrgName=function(){var a=this.getPrimaryOrg();return a&&a.orgDetails?a.orgDetails.name:!1};h.prototype.setAttribute=function(c,
d,f){var h=a.defer();angular.isDefined(f)||(f=!0);if(!this.userAttributes||this.getAttribute(c)===d)return h.resolve(),h.promise;this.userAttributes[c]=angular.copy(d);angular.isString(d)||(d=angular.toJson(d));if(f)return b.post(g+"/user/attribute",$.param({key:c,val:d}));h.resolve();return h.promise};h.prototype.getAttribute=function(a,c){var d=this,f;if(d.userAttributes){if(c)return b.get(g+"/user/attribute").then(function(b){d.userAttributes[a]=b.data[a]});try{f=angular.fromJson(d.userAttributes[a])}catch(h){f=
d.userAttributes[a]}return f}};h.prototype.hasRole=function(a){return _.contains(this.roles,a)};h.prototype.$hasCenter=function(){return this.isLibraryAdmin||this.getAttribute("hasCenter")};h.prototype.$create=function(){var a=this,c=b.post(g+"/rumba/user/create_user",{firstName:a.firstName,lastName:a.lastName,userName:a.userName,password:a.password,"orgIds[]":[a.organizationId]});c.success(function(b){angular.extend(a,b)});return c};h.prototype.$save=function(){var e=this,d=g+"/user",f=!1,h;angular.isDefined(e.userId)&&
0<e.userId.length&&(d+="/"+e.userId,f=!0);e.orgIds=e.organizationId?[e.organizationId]:e.primaryOrgIds&&0<e.primaryOrgIds.length?e.primaryOrgIds:e.primaryOrgId&&0<e.primaryOrgId.length?[e.primaryOrgId]:[];h=angular.copy(e);if(f&&(h.password=null,!h.middleName))h.middleName=null;return b.post(d,h).then(function(a){c.log("saved user",a);delete a.data.password;angular.extend(e,a.data);return e},function(b){if("ULC0003W"===b.errorCode)return angular.extend(e,b.data),e;c.error("RUMBA creation ERROR:",
b);return a.reject("RUMBA creation ERROR:"+b)})};h.prototype.$update=function(){var a=g+"/user/"+this.userId;i.dirtyAssigneesData=!0;var c={userName:this.userName,firstName:this.firstName,lastName:this.lastName,emailAddress:this.emailAddress,password:this.password};if(this.middleName&&0<this.middleName.length)c.middleName=this.middleName;return b.post(a,c)};h.prototype.$setPassword=function(a){this.password=a;a=g+"/user/"+this.userName+"/password/"+encodeURIComponent(a);return b.post(a)};h.prototype.$setFirstName=
function(a){this.firstName=a;this.$updateNames()};h.prototype.$setLastName=function(a){this.lastName=a;this.$updateNames()};h.prototype.$setMiddleName=function(a){var b=this;this.middleName=a;this.setAttribute("profile.middleName",a,b.userId===i.currentUser.userId).then(function(){b.$updateNames()})};h.prototype.$setLastFirst=function(a){if(angular.isString(a)&&-1!==a.search(",")){var a=a.split(","),b=$.trim(a[0]);this.firstName=$.trim(a[1]);this.lastName=b;this.$updateNames()}};h.prototype.$updateNames=
function(){if(!angular.isString(this.middleName)&&this.getAttribute("profile.middleName"))this.middleName=this.getAttribute("profile.middleName");this.fullName=this.middleName&&0<$.trim(this.middleName).length?[this.firstName,this.middleName,this.lastName].join(" "):[this.firstName,this.lastName].join(" ");this.firstAndLast=[this.firstName,this.lastName].join(" ");this.lastFirst=[this.lastName,this.firstName].join(", ")};h.prototype.$subscribeTo=function(a){var c=this;angular.isArray(a)||(a=[a]);
a=b.post(g+"/user/subscribe",$.param({"courses[]":a}));a.success(function(a){c.subscribedCourses=a;angular.forEach(c.oleAffiliations,function(a){angular.forEach(a.products,function(a){if(0<=_.indexOf(c.subscribedCourses,a.productName))a.subscribed=!0})})});return a};h.prototype.$canCustomizeItems=function(){return i.currentUser.hasRole("ROLE_TEACHER")};return h}]);angular.module("Realize.core.services.userSvc",["Realize.core.services.user","Realize.core.configs.REST_PATH"]).service("UserSvc",["$http","$log","$q","$rootScope","User","REST_PATH",function(a,b,c,g,d,f){this.findStudents=function(c){b.log("findStudents",c);var g=[];angular.isDefined(c)||(c={});if(!angular.isDefined(c.pageSize))c.pageSize=15;a.get(f+"/student_search",{params:c}).success(function(a){var b=[];angular.forEach(a.users,function(a){b.push(new d(a.rumbaUser))});angular.copy(b,g)});return g};
this.query=function(b,g){var h=f+"/student_search";angular.isDefined(b)||(b={});if(!angular.isDefined(b.pageSize))b.pageSize=50;angular.isDefined(b.firstname)&&(b.firstname+="*");angular.isDefined(b.lastname)&&(b.lastname+="*");return a.get(h,{params:b,cache:!!g}).then(function(a){var b=[];angular.forEach(a.data.users,function(a){a.rumbaUser.userAttributes=a.attributes;b.push(new d(a.rumbaUser))});return b},function(a){return c.reject(a)})};this.getUserById=function(b){return a.get(f+"/user/"+b).then(function(a){return a.data},
function(a){return c.reject(a)})};this.updateCurrentUserAttributes=function(c){return a.post(f+"/user/profile",c).then(function(){angular.extend(g.currentUser.userAttributes,c)},function(a){b.error("error updating user profile",a)})}}]);angular.module("Realize.core.sessionTimeoutInterceptor",[]).config(["$httpProvider",function(a){a.interceptors.push(["$rootScope","$q",function(a,c){return{response:function(a){return a},responseError:function(g){switch(g.status){case 401:return a.$broadcast("httpSessionTimedOut"),c.defer().promise;default:return c.reject(g)}}}}])}]);;/**
 * Copyright 2014, Pearson Education, Learning Technology Group
 * NOTE: ui.router is not technically needed, but listed as a dependency because we rely on $stateChangeStart events
 */

angular.module('Realize.core.services.NavigationBlocker', ['ui.router'])
    .factory('NavigationBlocker', ['$log', '$rootScope',
        function($log, $rootScope) {

            /*============ FACTORY DEFINITION ============*/

            var NavigationBlocker = function(scopeIn, callBack) {

                /*============ PRIVATE PROPERTIES/METHODS ============*/

                var self = this;
                var shouldBlockNavigation = false;

                var checkNavigationBlocker = function(event, toState, toParams, fromState, fromParams) {

                    if(!shouldBlockNavigation) {return;}

                    // ui-router hasn't implemented any event for when state change was prevented so we fire our own
                    event.preventDefault();
                    $rootScope.$broadcast('$stateChangePrevented', toState, toParams, fromState, fromParams);

                    /**
                     * pass along the intended target, this is helpful if you want to "pause" to pop a modal and then continue
                     * you could also listen to the $stateChangePrevented event above, but it's convenient to pass back to the call back
                     * because if you are using a NavigationBlocker you will be passing a callback anyway
                     */
                    callBack(toState, toParams);
                };


                /*============ PUBLIC PROPERTIES/METHODS ============*/

                self.start = function () {
                    shouldBlockNavigation = true;
                };

                self.stop = function () {
                    shouldBlockNavigation = false;
                };


                /*============ INITIALIZATION ============*/

                scopeIn.$on('$stateChangeStart', checkNavigationBlocker);

            };

            return NavigationBlocker;
        }
    ]);;// accessiblity.svc.js
// perhaps this should be a directive since it manipulates the DOM

angular.module('Realize.core.services.accessibility', [])
    .service("AccessibilityService", ['$log', '$rootScope',
        function($log, $rootScope) {
            // init
            var svc = this;

            var toggleInteractionState = function() {
                $rootScope.isKeyboardInUse = !$rootScope.isKeyboardInUse;

                if ($rootScope.isKeyboardInUse) {
                    // detect mouse interaction
                    angular.element('body').mousedown(function(mouseDetection) {
                        angular.element(this).unbind(mouseDetection);
                        toggleInteractionState();
                        svc.applyStyleToFocusableElements();
                    });
                }
            };

            var setKeyInteractionHandler = function() {
                // detect keyboard interaction
                angular.element('body').keydown(function() {
                    if (!$rootScope.isKeyboardInUse) {
                        toggleInteractionState();
                    }
                    // since we can't easily determine when angular is done building the DOM,
                    // persist the listener on body, re-apply css hooks to newly rendered markup
                    svc.applyStyleToFocusableElements();
                });
            };

            svc.init = function() {
                $rootScope.isKeyboardInUse = false;
                setKeyInteractionHandler();
            };

            svc.setFocusElements = function(elements) {
                svc.keyboardFocusableElements = elements;
            };

            svc.applyStyleToFocusableElements = function() {
                // display visual focus indicators, based on keyboard use
                angular.element(svc.keyboardFocusableElements).toggleClass('kb-mode', $rootScope.isKeyboardInUse);
            };

            $rootScope.skipNav = function(event) {
                event.stopPropagation();
                angular.element('#skipTarget').next("div").find(":focusable").first().focus();
            };

            // if the user is in keyboard mode,
            // elements that have focus on new page views need this in order to see the focus outline
            $rootScope.$on('$viewContentLoaded', function() {
                // $log.log('[$viewContentLoaded]');
                svc.applyStyleToFocusableElements();
            });

            return svc;

        }
    ]);;angular.module('Realize.core.services.browserInfo', [])
    .service('BrowserInfo', [
        '$window',
        function($window) {

            var userAgent = $window.navigator ? angular.lowercase($window.navigator.userAgent) : "";

            this.browser = {};
            this.OS = {};

            // regex patterns taken from https://github.com/ded/bowser/blob/master/bowser.js
            this.browser.isFirefox = /firefox|iceweasel/i.test(userAgent);
            this.browser.isMSIE = /msie|trident/i.test(userAgent);

            if( this.browser.isMSIE ) {
                var match = navigator.userAgent.toLowerCase().match(/(?:msie |trident\/.*; rv:)(\d+)/);
                this.browser.msieVersion = match ? parseInt(match[1], 10) : undefined;
            }

            this.OS.isIOS = /(ipod|iphone|ipad)/i.test(userAgent);
            this.OS.isIOS5 = this.OS.isIOS && /OS 5_[0-9_]+ like Mac OS X/i.test(userAgent);

            this.OS.isIDevice = (
                $window.navigator.platform === 'iPad' ||
                $window.navigator.platform === 'iPhone' ||
                $window.navigator.platform === 'iPad Simulator' ||
                $window.navigator.platform === 'iPhone Simulator'
            );

            this.isRetina = $window.devicePixelRatio >= 2;
        }
    ])
    .run([
        '$rootScope',
        '$window',
        'BrowserInfo',
        function($rootScope, $window, BrowserInfo) {
            var win = angular.element($window);

            $rootScope.isRetina = BrowserInfo.isRetina;

            $rootScope.isIDevice = BrowserInfo.OS.isIDevice;

            // responsive listeners
            var updateOrientation = function() {
                var orientation = $window.orientation;
                if (orientation === 0) {
                    // iPad is in Portrait mode.
                    $rootScope.iOrientation = 'portrait';
                } else if (orientation === 90) {
                    // iPad is in Landscape mode. The screen is turned to the left.
                    $rootScope.iOrientation = 'landscape';
                } else if (orientation === -90) {
                    // iPad is in Landscape mode. The screen is turned to the right.
                    $rootScope.iOrientation = 'landscape';
                } else if (orientation === 180) {
                    // Upside down portrait.
                    $rootScope.iOrientation = 'portrait';
                } else {
                    $rootScope.iOrientation = 'unknown';
                }
            };

            // update rootscope orientation first
            updateOrientation();
            // now set correct iMode; TODO: set 980 configurable?
            $rootScope.iMode = (win.width() <= 980 || $rootScope.iOrientation === 'portrait');

            win.on('resize', function() {
                $rootScope.$apply(function() {
                    updateOrientation();
                    $rootScope.iMode = (win.width() <= 980 || $rootScope.iOrientation === 'portrait');
                });
            });

            win.on('orientationchange', function() {
                $rootScope.$apply(function() {
                    updateOrientation();
                    $rootScope.iMode = (win.width() <= 980 || $rootScope.iOrientation === 'portrait');
                });
            });

            $rootScope.$watch('iMode', function() {
                $rootScope.$broadcast('orientationChange');
            });

            $rootScope.$on('destroy', function() {
                win.off('resize');
                win.off('orientationchange');
            });
        }
    ]);;// debounce.js
// http://unscriptable.com/2009/03/20/debouncing-javascript-methods/

angular.module('Realize.core.services.debounce', [])
    .factory(
        '$debounce', [
            '$rootScope',
            '$browser',
            '$q',
            '$exceptionHandler',
            function($rootScope, $browser, $q, $exceptionHandler) {
                var deferreds = {},
                    methods = {},
                    uuid = 0;

                function debounce(fn, delay, invokeApply) {
                    var deferred = $q.defer(),
                        promise = deferred.promise,
                        skipApply = (angular.isDefined(invokeApply) && !invokeApply),
                        timeoutId, cleanup,
                        methodId, bouncing = false;

                    // check we dont have this method already registered
                    angular.forEach(methods, function(value, key) {
                        if (angular.equals(methods[key].fn, fn)) {
                            bouncing = true;
                            methodId = key;
                        }
                    });

                    // not bouncing, then register new instance
                    if (!bouncing) {
                        methodId = uuid++;
                        methods[methodId] = {
                            fn: fn
                        };
                    } else {
                        // clear the old timeout
                        deferreds[methods[methodId].timeoutId].reject('bounced');
                        $browser.defer.cancel(methods[methodId].timeoutId);
                    }

                    var debounced = function() {
                        // actually executing? clean method bank
                        delete methods[methodId];

                        try {
                            deferred.resolve(fn());
                        } catch (e) {
                            deferred.reject(e);
                            $exceptionHandler(e);
                        }

                        if (!skipApply) {
                            $rootScope.$apply();
                        }
                    };

                    timeoutId = $browser.defer(debounced, delay);

                    // track id with method
                    methods[methodId].timeoutId = timeoutId;

                    cleanup = function(reason) {
                        delete deferreds[promise.$$timeoutId];
                    };

                    promise.$$timeoutId = timeoutId;
                    deferreds[timeoutId] = deferred;
                    promise.then(cleanup, cleanup);

                    return promise;
                }


                // similar to angular's $timeout cancel
                debounce.cancel = function(promise) {
                    if (promise && deferreds.hasOwnProperty(promise.$$timeoutId)) {
                        deferreds[promise.$$timeoutId].reject('canceled');
                        return $browser.defer.cancel(promise.$$timeoutId);
                    }
                    return false;
                };

                return debounce;
            }
        ]
);;// this is generally only used for admin functions, only supports Chrome
angular.module('Realize.core.services.filesystem', [])
    .factory('fileSystem', ['$q', '$timeout', '$window',
        function($q, $timeout, $window) {
            var fsDefer = $q.defer();

            var DEFAULT_QUOTA_MB = 5;

            //wrap resolve/reject in an empty $timeout so it happens within the Angular call stack
            //easier than .apply() since no scope is needed and doesn't error if already within an apply
            function safeResolve(deferred, message) {
                $timeout(function() {
                    deferred.resolve(message);
                });
            }

            function safeReject(deferred, message) {
                $timeout(function() {
                    deferred.reject(message);
                });
            }

            $window.webkitStorageInfo.requestQuota($window.PERSISTENT, DEFAULT_QUOTA_MB * 1024 * 1024, function(grantedBytes) {
                $window.webkitRequestFileSystem($window.PERSISTENT, grantedBytes, function(fs) {
                    safeResolve(fsDefer, fs);
                }, function(e) {
                    safeReject(fsDefer, {
                        text: "Error requesting File System access",
                        obj: e
                    });
                });
            }, function(e) {
                safeReject(fsDefer, {
                    text: "Error requesting Quota",
                    obj: e
                });
            });

            var fileSystem = {
                getCurrentUsage: function() {
                    var def = $q.defer();

                    $window.webkitStorageInfo.queryUsageAndQuota($window.PERSISTENT, function(used, quota) {
                        safeResolve(def, {
                            'used': used,
                            'quota': quota
                        });
                    }, function(e) {
                        safeReject(def, {
                            text: "Error getting quota information",
                            obj: e
                        });
                    });

                    return def.promise;
                },
                requestQuotaIncrease: function(newQuotaMB) {
                    var def = $q.defer();

                    $window.webkitStorageInfo.requestQuota($window.PERSISTENT, newQuotaMB * 1024 * 1024, function(grantedBytes) {
                        safeResolve(def, grantedBytes);
                    }, function(e) {
                        safeReject(def, {
                            text: "Error requesting quota increase",
                            obj: e
                        });
                    });

                    return def.promise;
                },
                getFolderContents: function(dir) {
                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {
                        fs.root.getDirectory(fs.root.fullPath + dir, {}, function(dirEntry) {
                            var dirReader = dirEntry.createReader();
                            dirReader.readEntries(function(entries) {
                                safeResolve(def, entries);
                            }, function(e) {
                                safeReject(def, {
                                    text: "Error reading entries",
                                    obj: e
                                });
                            });
                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting directory",
                                obj: e
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                createFolder: function(path) {
                    //remove leading slash if present
                    path = path.replace(/^\//, "");

                    var def = $q.defer();

                    function createDir(rootDir, folders) {
                        rootDir.getDirectory(folders[0], {
                            create: true
                        }, function(dirEntry) {
                            if (folders.length) {
                                createDir(dirEntry, folders.slice(1));
                            } else {
                                safeResolve(def, dirEntry);
                            }
                        }, function(e) {
                            safeReject(def, {
                                text: "Error creating directory",
                                obj: e
                            });
                        });
                    }

                    fsDefer.promise.then(function(fs) {
                        createDir(fs.root, path.split('/'));
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                deleteFolder: function(path, recursive) {
                    recursive = (typeof recursive === 'undefined' ? false : recursive);

                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {
                        fs.root.getDirectory(path, {}, function(dirEntry) {
                            var success = function() {
                                safeResolve(def, "");
                            };
                            var err = function(e) {
                                safeReject(def, {
                                    text: "Error removing directory",
                                    obj: e
                                });
                            };

                            if (recursive) {
                                dirEntry.removeRecursively(success, err);
                            } else {
                                dirEntry.remove(success, err);
                            }
                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting directory",
                                obj: e
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                writeFileInput: function(filename, file, mimeString) {
                    var def = $q.defer();

                    var reader = new window.FileReader();

                    reader.onload = function(e) {
                        var buf = e.target.result;

                        $timeout(function() {
                            fileSystem.writeArrayBuffer(filename, buf, mimeString).then(function() {
                                safeResolve(def, "");
                            }, function(e) {
                                safeReject(def, e);
                            });
                        });
                    };

                    reader.readAsArrayBuffer(file);

                    return def.promise;
                },
                writeText: function(fileName, contents, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    //create text blob from string
                    var blob = new $window.Blob([contents], {
                        type: 'text/plain'
                    });

                    return fileSystem.writeBlob(fileName, blob, append);
                },
                writeJSON: function(fileName, contents, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    //create text blob from string
                    var blob = new $window.Blob([contents], {
                        type: 'application/json;charset=UTF-8'
                    });

                    return fileSystem.writeBlob(fileName, blob, append);
                },
                writeArrayBuffer: function(fileName, buf, mimeString, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    var blob = new $window.Blob([new window.Uint8Array(buf)], {
                        type: mimeString
                    });

                    return fileSystem.writeBlob(fileName, blob, append);
                },
                writeBlob: function(fileName, blob, append) {
                    append = (typeof append === 'undefined' ? false : append);

                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {

                        fs.root.getFile(fileName, {
                            create: true
                        }, function(fileEntry) {

                            fileEntry.createWriter(function(fileWriter) {
                                if (append) {
                                    fileWriter.seek(fileWriter.length);
                                }

                                var truncated = false;
                                fileWriter.onwriteend = function(e) {
                                    //truncate all data after current position
                                    if (!truncated) {
                                        truncated = true;
                                        this.truncate(this.position);
                                        return;
                                    }
                                    safeResolve(def, fileEntry.toURL());
                                };

                                fileWriter.onerror = function(e) {
                                    safeReject(def, {
                                        text: 'Write failed',
                                        obj: e
                                    });
                                };

                                fileWriter.write(blob);

                            }, function(e) {
                                safeReject(def, {
                                    text: "Error creating file",
                                    obj: e
                                });
                            });

                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting file",
                                obj: e
                            });
                        });

                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                readFile: function(fileName, returnType) {
                    var def = $q.defer();

                    returnType = returnType || "text";

                    fsDefer.promise.then(function(fs) {
                        fs.root.getFile(fileName, {}, function(fileEntry) {
                            // Get a File object representing the file,
                            // then use FileReader to read its contents.
                            fileEntry.file(function(file) {
                                var reader = new $window.FileReader();

                                reader.onloadend = function() {
                                    safeResolve(def, this.result);
                                };

                                reader.onerror = function(e) {
                                    safeReject(def, {
                                        text: "Error reading file",
                                        obj: e
                                    });
                                };


                                switch (returnType) {
                                    case 'arraybuffer':
                                        reader.readAsArrayBuffer(file);
                                        break;
                                    case 'binarystring':
                                        reader.readAsBinaryString(file);
                                        break;
                                    case 'dataurl':
                                        reader.readAsDataURL(file);
                                        break;
                                    default:
                                        reader.readAsText(file);
                                }
                            }, function(e) {
                                safeReject(def, {
                                    text: "Error getting file",
                                    obj: e
                                });
                            });
                        }, function(e) {
                            safeReject(def, {
                                text: "Error getting file",
                                obj: e
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                },
                deleteFile: function(fullPath) {
                    var def = $q.defer();

                    fsDefer.promise.then(function(fs) {
                        fs.root.getFile(fullPath, {
                            create: false
                        }, function(fileEntry) {
                            fileEntry.remove(function() {
                                safeResolve(def, "");
                            }, function(e) {
                                safeReject(def, {
                                    text: "Error deleting file",
                                    obj: e
                                });
                            });
                        });
                    }, function(err) {
                        def.reject(err);
                    });

                    return def.promise;
                }
            };

            return fileSystem;
        }
    ]);;// dep on datejs??

angular.module('Realize.core.services.isodate', [])
    .service("ISODateService", ['$log',
        function($log) {

            this.toDateTimeString = function(date) {
                return date.toString('yyyy-MM-ddTHH:mm:ss') + this.getOffsetFromUTC(date);
            };

            this.toDateString = function(date) {
                return date.toString('yyyy-MM-dd');
            };

            //make sure range includes TZ for this date
            this.toDateStringWithZone = function(date) {
                return date.toString('yyyy-MM-ddT00:00:00') + this.getOffsetFromUTC(date);
            };

            this.toStartOfDayStringWithZone = this.toDateStringWithZone;

            this.toStartOfNextDayStringWithZone = function(date) {
                var dateRolledForward = date.clone().clearTime().add({
                    days: 1
                });
                return this.toDateTimeString(dateRolledForward);
            };

            this.toEndOfDayStringWithZone = function(date) {
                var dateRolledForward = date.clone().clearTime().add({
                    hours: 23,
                    minutes: 59,
                    seconds: 59
                });
                return this.toDateTimeString(dateRolledForward);
            };

            this.getStringForOffset = function(offset) {
                return ((offset < 0 ? '+' : '-') + this.pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + this.pad(Math.abs(offset) % 60, 2));
            };

            this.getOffsetFromUTC = function(date) {
                if (angular.isUndefined(date)) {
                    date = new Date();
                }
                var offset = date.getTimezoneOffset();
                return this.getStringForOffset(offset);
            };

            this.pad = function(number, length, padChar) {
                if (angular.isUndefined(length)) {
                    length = 2;
                }
                if (angular.isUndefined(padChar)) {
                    padChar = '0';
                }
                var str = "";
                str += number;
                while (str.length < length) {
                    str = padChar + str;
                }
                return str;
            };

        }
    ]);;angular.module('Realize.core.services.log', [])
.value('LOG_LEVEL', 5) // to be overridden in index.html
.config(['$provide', function($provide) {
    $provide.decorator('$log', ['LOG_LEVEL', '$delegate', function(LOG_LEVEL, $delegate) {
        var log = $delegate.log,
            debug = $delegate.debug,
            warn = $delegate.warn,
            info = $delegate.info,
            error = $delegate.error;

        $delegate.log = function() {
            if(LOG_LEVEL >= 3) {
                log.apply($delegate, arguments);
            }
        };

        $delegate.debug = function() {
            if(LOG_LEVEL >= 5) {
                debug.apply($delegate, arguments);
            }
        };

        $delegate.warn = function() {
            if(LOG_LEVEL >= 2) {
                warn.apply($delegate, arguments);
            }
        };

        $delegate.info = function() {
            if(LOG_LEVEL >= 4) {
                info.apply($delegate, arguments);
            }
        };

        $delegate.error = function() {
            if(LOG_LEVEL >= 1) {
                error.apply($delegate, arguments);
            }
        };

        return $delegate;
    }]);
}]);
;// messages.js

angular.module('Realize.core.services.messages', [])
    .provider('Messages', [
        function() {
            var languageFilePath,
                provided = {};

            // configure where the .json files are stored
            this.setLanguageFilePath = function(path) {
                languageFilePath = path;
            };

            this.addCache = function (path, codes) {
                provided[path] = codes;
            };

            this.$get = ['$http', '$log', '$q', '$filter', '$cacheFactory',
                function($http, $log, $q, $filter, $cacheFactory) {
                    var svc = this,
                        _codes = {},
                        cache = $cacheFactory.get('$http');

                    _.each(provided, function (val, key) {
                        cache.put(key, val);
                    });

                    if (!languageFilePath) {
                        throw "Error [MessagesProvider]: languageFilePath must be configured!";
                    }

                    svc.load = function(locale, override, update) {
                        locale = locale || 'en';
                        svc.currentLocale = locale;

                        if (!angular.isDefined(update)) {
                            update = true;
                        }

                        var file = languageFilePath + '/messages_' + locale + '.json';
                        $log.log('messages loading file', file, 'override', override, {
                            cache: !! !override
                        });
                        // allow full url override for local "preview" mode
                        if (override) {
                            file = override;
                        }

                        var promise = $http.get(file, {
                            cache: !! !override
                        })
                            .then(function(response) {
                                // might just be loading the data for another purpose.. (admin)
                                if (update) {
                                    angular.copy(response.data, _codes);
                                }

                                return response.data;
                            }, function(err) {
                                $log.warn('error loading locale file!', err);
                                return $q.reject(err);
                            });

                        return promise;
                    };

                    // gets a message from the json obj, using dot notation
                    // 'classes.header.title' === {classes: {header: {title: 'Foo'}}}
                    svc.getMessage = function(code, getJson) {
                        var keys = code.split('.'),
                            result = _codes,
                            o;

                        //$log.log(result);

                        for (o = 0; o < keys.length; o++) {
                            if (result[keys[o]]) {
                                result = result[keys[o]];
                            } else {
                                result = null;
                                break;
                            }
                        }

                        if (getJson) {
                            return result;
                        }

                        // we don't want to allow the actual object chunk returned here...
                        // so an incomplete code will result in null here, only strings!
                        return angular.isString(result) ? result : null;
                    };


                    /**
                     * @method getInterpolatedMessage
                     * @param code {String}
                     * @param values {Array}
                     * @returns {String}
                     */
                    svc.getInterpolatedMessage = function(code, values) {
                        var v,
                            msg = svc.getMessage(code);

                        if (msg === null) {
                            msg = '';
                        }

                        for (v = 0; v < values.length; v += 1) {
                            msg = msg.replace("{" + v + "}", values[v]);
                        }

                        return msg;
                    };

                    svc.getMessageOrDefault = function(key, defaultValue) {
                        var msg = svc.getMessage(key);

                        return msg === null ? defaultValue : msg;
                    };

                    svc.getMessagesAsArray = function(code) {
                        return $filter('toArray')(svc.getMessage(code, true));
                    };

                    return svc;
                }
            ];

        }
    ]);;angular.module('Realize.core.services.poller', [])
    .service('Poller', ['$http', '$q', '$timeout', '$log',
        function($http, $q, $timeout, $log) {
            var polls = {};

            var service = this;

            var doPoll = function(promise, name, method, interval) {
                return promise.then(function(result) {
                        if (polls[name] && polls[name].status === 'polling') {
                            polls[name].poll = $timeout(method, interval);
                            doPoll(polls[name].poll, name, method, interval);
                            polls[name].deferred.notify(result);
                        } else {
                            service.stop(name);
                        }
                    }, function(err) {
                        $log.log(name + ' timeout rejected: ', err);
                        if (polls[name] && polls[name].deferred) {
                            return polls[name].deferred.reject(err);
                        }
                    });
            };

            this.start = function(name, method, interval) {
                var deferred = $q.defer();

                if (polls[name]) {
                    return polls[name].deferred.promise;
                } else {
                    polls[name] = {};
                    polls[name].method = method;
                    polls[name].interval = interval;
                    polls[name].deferred = deferred;
                    polls[name].status = 'polling';

                    polls[name].poll = $timeout(method, interval);
                    doPoll(polls[name].poll, name, method, interval);

                    return polls[name].deferred.promise;
                }
            };

            this.stop = function(name) {
                if (polls[name]) {
                    $timeout.cancel(polls[name].poll);
                    polls[name].status = 'stopped';
                    polls[name].deferred.reject('stopped');
                } else {
                    $log.warn('no poller found: ', name);
                }
            };

            this.list = function() {
                return Object.keys(polls);
            };

            this.$$getPolls = function() {
                return polls;
            };

            this.clearAll = function () {
                var self = this;
                angular.forEach(polls, function(value, key) {
                    self.clear(key);
                });
            };

            this.clear = function(name) {
                this.stop(name);
                delete polls[name];
            };

            this.restart = function(name) {
                if (!polls[name]) {
                    return $q.reject('no poll found');
                }

                var method = polls[name].method;
                var interval = polls[name].interval;

                this.clear(name);

                return this.start(name, method, interval);
            };

        }
    ]);;angular.module('Realize.core.services.rumbaDataService', [
    'Realize.core.configs.REST_PATH'
])
    .service('RumbaDataService', [
        '$http',
        '$q',
        'REST_PATH',
        function($http, $q, restPath) {
            var service = this;

            service.getOrgDetails = function(ids, success) {
                var promise = $http({
                    url: restPath + '/rumba/orgs',
                    method: 'GET',
                    params: {
                        'id[]': ids
                    },
                    cache: true // caching because of search results and also changing shouldn't really happen mid session
                });

                if (success) {
                    promise.success(success);
                }

                return promise;
            };

            // this call is restricted to ROLE_CUSTOMER_ADMIN on the back end
            // it only returns the child orgs of the affiliations that they are CA with
            // it uses the currently signed in user on the back end
            service.getChildOrgs = function() {
                return $http.get(restPath + '/rumba/orgs/children', {
                    cache: true
                }).then(function(response) {
                    return response.data;
                }, function(err) {
                    return $q.reject(err);
                });
            };

            service.checkUsernameAvailability = function(username, success) {
                var promise = $http({
                    url: restPath + '/check_username',
                    method: 'GET',
                    params: {
                        username: username
                    }
                });

                if (success) {
                    promise.success(success);
                }

                return promise;
            };

            service.getProductDetails = function(id, success) {
                var promise = $http({
                    url: restPath + '/rumba/products/' + id,
                    method: 'GET',
                    cache: true // caching because of search results and also changing shouldn't really happen mid session
                });

                if (success) {
                    promise.success(success);
                }

                return promise;
            };

        }
    ]);;angular.module('Realize.core.services.user', [
    'Realize.core.services.rumbaDataService',
    'Realize.core.services.messages',
    'Realize.core.configs.REST_PATH',
    'Realize.core.configs.MEDIA_PATH',
    'Realize.core.configs.CURRENT_USER'
])
    .run([
        'User',
        '$rootScope',
        'CURRENT_USER',
        function(User, $rootScope, CURRENT_USER) {
            $rootScope.currentUser = new User(CURRENT_USER);
        }
    ])
    .factory('User', [
        '$q',
        '$http',
        '$log',
        'REST_PATH',
        'RumbaDataService',
        'MEDIA_PATH',
        '$rootScope',
        'Messages',
        function($q, $http, $log, restPath, Rumba, MEDIA_PATH, $rootScope, Messages) {

            function User(json) {
                var self = this;

                // setup some defaults, they will be overridden if provided
                self.userAttributes = {};

                // create instance using json properties
                if (json) {
                    angular.copy(json, self);
                }

                // need a "emailAddress" attribute for editing, instead of rumbaEmail
                self.emailAddress = self.rumbaEmail;

                // some of the naming vars dont come from server
                self.$updateNames();

                // the affiliations will have an entry for each role they play (CA, T, S)
                // in this case we only want distinct since the oleAffiliations dont have distinguishable differences
                // if you want to know the role within an org, that's self.affiliations
                self.oleAffiliations = _.uniq(self.oleAffiliations, function(affiliation) { return affiliation.organizationId; });

                // need to update org data once
                var orgIds = _.pluck(self.oleAffiliations, 'organizationId');
                if (orgIds.length > 0) {
                    Rumba.getOrgDetails(orgIds, function(response) {
                        angular.forEach(response, function(org) {
                            var affiliatedOrg = _.findWhere(self.oleAffiliations, {organizationId: org.organizationId});

                            if (affiliatedOrg) {
                                affiliatedOrg.orgDetails = org;
                            }
                        });
                    });
                }

                if (self.primaryOrgRole === "Student" && (self.primaryOrgId !== "lti-org-id" && self.primaryOrgId !== "student_center_org_id")) {
                    // Don't build the product details for the LTI Content viewer ('lti-org-id') since
                    // LTI uses a different mechanism for associating products to users.

                    // Build productId-productName map (for etext)
                    Rumba.getProductDetails(self.primaryOrgId, function(response) {
                        self.productIdMap = {};
                        angular.forEach(response, function(org) {
                            self.productIdMap[org.productId] = org.productDisplayName;
                        });

                    });
                }

                // set it to already existing to generate avatarUrl
                self.$setAvatar(self.getAttribute('profile.avatar'));

                self.isLibraryAdmin = self.hasRole("ROLE_LIBRARY_ADMIN");
                self.isTeacher = self.hasRole("ROLE_TEACHER");
                self.isStudent = self.hasRole("ROLE_STUDENT");
                self.isReviewer = self.hasRole("ROLE_REVIEWER");
            }

            User.prototype.$setAvatar = function(avatar) {
                var self = this,
                    deferred = $q.defer();

                self.setAttribute('profile.avatar', avatar, true).then(function(response) {
                    // TODO: make this platform configurable!
                    var avatarUrl = MEDIA_PATH + '/skins/default/images/profile_icons/',
                        avatarAttr = self.getAttribute('profile.avatar');

                    if (self.primaryOrgRole === 'Student') {
                        avatarUrl += avatarAttr || 'default_student';
                        //$log.log('student avatarUrl', avatarUrl, avatarAttr);
                    } else {
                        avatarUrl += avatarAttr || 'default_teacher';
                    }

                    // the avatar url should have the extension omitted, so that retina can be applied
                    self.avatarUrl = avatarUrl + ($rootScope.isRetina ? '@2x.png' : '.png');

                    deferred.resolve(self);

                }, deferred.reject);

                return deferred.promise;
            };

            // specifically set the profile.locale user attribute, and refresh the language
            User.prototype.$setLocale = function(locale) {
                locale = locale || 'en';
                var user = this;
                $log.log('user $setLocale', locale);
                return user.setAttribute('profile.locale', locale)
                    .then(function() {
                        Messages.load(locale, user.getAttribute('admin.previewMode') ? user.getAttribute('admin.localeOverride') : null);
                    });
            };

            User.prototype.$getIpadPreview = function(preview, callback) {
                $http.get(preview.ipadTokenRetrievalUrl).then(function(response) {
                    // Slice to strip beginning and end double quotes
                    var url = preview.ipadUrl.replace("{IPAD_TOKEN}", response.data.slice(1, -1));
                    callback(url);
                });
            };

            // used to toggle boolean type attributes on a specific user
            User.prototype.$toggleAttribute = function(attr) {
                var self = this;

                if (!self.userAttributes) {
                    return;
                }

                if (self.userAttributes[attr]) {
                    self.userAttributes[attr] = false;
                } else {
                    self.userAttributes[attr] = true;
                }

                // update server to match
                var promise = $http.post(restPath + '/user/attribute', $.param({
                    key: attr,
                    val: self.userAttributes[attr]
                }));

                return promise;
            };

            User.prototype.getPrimaryOrg = function () {
                var self = this;
                var primaryOrgId = self.primaryOrgId;
                if(primaryOrgId) {
                    var allOrgs = self.oleAffiliations;
                    return _.findWhere(allOrgs, {"organizationId": primaryOrgId}) || false;
                } else {
                    return false;
                }
            };

            User.prototype.getPrimaryOrgName = function() {
                var self = this;

                var primaryOrg = self.getPrimaryOrg();
                return primaryOrg && primaryOrg.orgDetails ? primaryOrg.orgDetails.name : false;
            };

            User.prototype.setAttribute = function(attr, value, persist) {
                var self = this,
                    deferred = $q.defer();

                if (!angular.isDefined(persist)) {
                    persist = true;
                }

                if (!self.userAttributes || self.getAttribute(attr) === value) {
                    //$log.log('attribute set or invalid', self.userAttributes);
                    deferred.resolve();
                    return deferred.promise;
                }

                // update in-memory value prior to any conversion, memory object should remain usable
                self.userAttributes[attr] = angular.copy(value);

                // convert value to JSON if needed, attributes must be strings
                if (!angular.isString(value)) {
                    value = angular.toJson(value);
                }

                if (persist) {
                    var promise = $http.post(restPath + "/user/attribute", $.param({
                        key: attr,
                        val: value
                    }));

                    return promise;
                } else {
                    // we might not want to persist, in the case we are updating memory object of NOT the current user
                    // back end currently only supports currentuser
                    deferred.resolve();
                    return deferred.promise;
                }
            };

            // get a single attribute from the user attributes
            // if getSync is true, fetch user attribute from server
            User.prototype.getAttribute = function(key, getAsync) {
                var self = this,
                    value;

                if (!self.userAttributes) {
                    return;
                }

                if (getAsync) {
                    var promise = $http.get(restPath + "/user/attribute").then(function(response) {
                        self.userAttributes[key] = response.data[key];
                    });

                    return promise;
                }

                try {
                    // some values are not going to be JSON encoded, hence the try/catch block
                    value = angular.fromJson(self.userAttributes[key]);
                } catch (e) {
                    //$log.warn("User.getAttribute, attribute was not JSON (OK: key, val)", key, this.userAttributes[key]);
                    value = self.userAttributes[key];
                }

                return value;
            };

            User.prototype.hasRole = function(role) {
                return _.contains(this.roles, role);
            };

            User.prototype.$hasCenter = function() {
                var user = this;

                return user.isLibraryAdmin || user.getAttribute('hasCenter');
            };

            // another case of #RESTFAIL
            /*
                    @RequestParam(required = true) String firstName,
                    @RequestParam(required = true) String lastName,
                    @RequestParam(required = true) String userName,
                    @RequestParam(required = true) String password,
                    @RequestParam(value = "orgIds[]", required = true) ArrayList<String> orgIds) {
                */
            // this might also be better as $save that does checking for create/update
            User.prototype.$create = function() {
                var user = this;

                var promise = $http.post(restPath + '/rumba/user/create_user', {
                    firstName: user.firstName,
                    lastName: user.lastName,
                    userName: user.userName,
                    password: user.password,
                    'orgIds[]': [user.organizationId]
                });

                // update user with server info when done
                promise.success(function(response) {
                    angular.extend(user, response);
                });

                return promise;
            };

            User.prototype.$save = function() {
                // if userId is present, update, else new
                var self = this,
                    url = restPath + '/user',
                    isUpdate = false,
                    outData;

                if (angular.isDefined(self.userId) && self.userId.length > 0) {
                    url += '/' + self.userId;
                    isUpdate = true;
                }

                // new user is expecting "orgIds"
                if (self.organizationId) {
                    self.orgIds = [self.organizationId];
                } else if (self.primaryOrgIds && self.primaryOrgIds.length > 0) {
                    self.orgIds = self.primaryOrgIds;
                } else if (self.primaryOrgId && self.primaryOrgId.length > 0) {
                    self.orgIds = [self.primaryOrgId];
                } else {
                    // no org ids given, might be OK if updating
                    self.orgIds = [];
                }

                // copy data so as to not make adjustments for the controller on the actual object
                outData = angular.copy(self);

                if (isUpdate) {
                    outData.password = null; // for some reason the ctrl requires this on the back end.(todo: fix)
                    // also middleName is required
                    if (!outData.middleName) {
                        outData.middleName = null;
                    }
                }

                var promise = $http.post(url, outData)
                    .then(function(response) {
                        $log.log('saved user', response);
                        delete response.data.password;
                        angular.extend(self, response.data);

                        return self;
                    }, function(response) {
                        // RUMBA warning of username automatically generated
                        if (response.errorCode === "ULC0003W") {
                            angular.extend(self, response.data);

                            return self;
                        } else {
                            $log.error('RUMBA creation ERROR:', response);
                            return $q.reject('RUMBA creation ERROR:' + response);
                        }
                    });

                return promise;
            };

            User.prototype.$update = function() {
                var url = restPath + '/user/' + this.userId;

                // todo: move to assignment service? something more specific?
                // tight coupling
                $rootScope.dirtyAssigneesData = true;

                var data = {
                    userName: this.userName,
                    firstName: this.firstName,
                    lastName: this.lastName,
                    emailAddress: this.emailAddress,
                    password: this.password
                };
                if (this.middleName && this.middleName.length > 0) {
                    data.middleName = this.middleName;
                }

                return $http.post(url, data);
            };

            User.prototype.$setPassword = function(password) {
                this.password = password;

                var url = restPath + '/user/' + this.userName + '/password/' + encodeURIComponent(password);

                return $http.post(url);
            };

            User.prototype.$setFirstName = function(name) {
                this.firstName = name;
                this.$updateNames();
            };

            User.prototype.$setLastName = function(name) {
                this.lastName = name;
                this.$updateNames();
            };

            User.prototype.$setMiddleName = function(name) {
                var self = this;

                this.middleName = name;
                this.setAttribute('profile.middleName', name, self.userId === $rootScope.currentUser.userId).then(function() {
                    self.$updateNames();
                });
            };

            User.prototype.$setLastFirst = function(name) {
                // test to prevent errors in split below
                if (!angular.isString(name) || name.search(',') === -1) {
                    return;
                }

                var names = name.split(','),
                    last = $.trim(names[0]),
                    first = $.trim(names[1]);

                this.firstName = first;
                this.lastName = last;

                this.$updateNames();
            };

            User.prototype.$updateNames = function() {
                // middleName doesn't exist at rumba level, it's in the UA
                if (!angular.isString(this.middleName) && this.getAttribute('profile.middleName')) {
                    this.middleName = this.getAttribute('profile.middleName');
                }
                if (this.middleName && $.trim(this.middleName).length > 0) {
                    this.fullName = [this.firstName, this.middleName, this.lastName].join(' ');
                } else {
                    this.fullName = [this.firstName, this.lastName].join(' ');
                }
                this.firstAndLast = [this.firstName, this.lastName].join(' ');
                this.lastFirst = [this.lastName, this.firstName].join(', ');
            };

            // subscribe this user to a list of product names
            // if it's not in availableCourses list it won't work
            User.prototype.$subscribeTo = function(products) {
                var self = this;

                if (!angular.isArray(products)) {
                    products = [products];
                }

                // server needs RESTful update...
                var promise = $http.post(restPath + '/user/subscribe', $.param({
                    'courses[]': products
                }));

                promise.success(function(response) {
                    // the response should be an array of products, update user object
                    self.subscribedCourses = response;
                    angular.forEach(self.oleAffiliations, function(affiliation) {
                        angular.forEach(affiliation.products, function(product) {
                            if (_.indexOf(self.subscribedCourses, product.productName) >= 0) {
                                product.subscribed = true;
                            }
                        });
                    });
                });

                return promise;
            };

            User.prototype.$canCustomizeItems = function() {
                return $rootScope.currentUser.hasRole("ROLE_TEACHER");
            };

            return User;
        }
    ]);;angular.module('Realize.core.services.userSvc', [
    'Realize.core.services.user',
    'Realize.core.configs.REST_PATH'
])
    .service('UserSvc', [
        '$http',
        '$log',
        '$q',
        '$rootScope',
        'User',
        'REST_PATH',
        function($http, $log, $q, $rootScope, User, restPath) {
            // this would just be query, but the backend isn't RESTful yet
            /*
                @RequestParam(value = "firstname", required = false) String firstName,
                @RequestParam(value = "lastname", required = false) String lastName,
                @RequestParam(value = "username", required = false) String userName,
                @RequestParam(value = "organization", required = false) String organizationId,
                @RequestParam(value = "page", required = false, defaultValue = "1") int page,
                @RequestParam(value = "pageSize", required = false, defaultValue = "4") int pageSize,
                @RequestParam(value = "!username[]", required = false) ArrayList<String> notUserNames,
                @RequestParam(value = "!userid[]", required = false) ArrayList<String> notUserIds) {
            */
            this.findStudents = function(params) {
                $log.log('findStudents', params);
                var result = [];

                if (!angular.isDefined(params)) {
                    params = {};
                }

                if (!angular.isDefined(params.pageSize)) {
                    params.pageSize = 15;
                }

                $http.get(restPath + '/student_search', {
                    params: params
                })
                    .success(function(response) {
                        var results = [];

                        angular.forEach(response.users, function(u) {
                            results.push(new User(u.rumbaUser));
                        });

                        // copy to future to preserve reference
                        angular.copy(results, result);
                    });

                return result;
            };

            // query for students
            this.query = function(params, cache) {
                var url = restPath + '/student_search';

                if (!angular.isDefined(params)) {
                    params = {};
                }

                if (!angular.isDefined(params.pageSize)) {
                    params.pageSize = 50; // max users to be found
                }

                // need to add * to query params for name
                if (angular.isDefined(params.firstname)) {
                    params.firstname += '*';
                }
                if (angular.isDefined(params.lastname)) {
                    params.lastname += '*';
                }

                return $http.get(url, {
                        params: params,
                        cache: !!cache
                    })
                    .then(function(response) {
                        var results = [];
                        angular.forEach(response.data.users, function(u) {
                            // copy over the attributes so they get in the ctor
                            u.rumbaUser.userAttributes = u.attributes;
                            results.push(new User(u.rumbaUser));
                        });

                        return results;
                    }, function(err) {
                        return $q.reject(err);
                    });
            };

            // Get student by userId
            this.getUserById = function(userId) {
                var url = restPath + "/user/" + userId;
                return $http.get(url)
                    .then(function(response) {
                        return response.data;
                    }, function(error) {
                        return $q.reject(error);
                    });
            };

            // matches with backend /user/profile
            // needs some refactoring on the back end prolly
            // need to be careful what you send as it's fragile about things like 'profile.password'
            this.updateCurrentUserAttributes = function(attributes) {
                return $http.post(restPath + '/user/profile', attributes)
                    .then(function() {
                        angular.extend($rootScope.currentUser.userAttributes, attributes);
                    }, function(response) {
                        $log.error('error updating user profile', response);
                    });
            };
        }
    ]);;angular.module('Realize.core.sessionTimeoutInterceptor', [])
    .config(['$httpProvider',
        function($httpProvider) {

            var interceptor = ['$rootScope', '$q',
                function($rootScope, $q) {
                    return {

                        response: function(response) {
                            return response;
                        },
                        responseError: function(response) {
                            switch (response.status) {
                                case 401:
                                    $rootScope.$broadcast('httpSessionTimedOut');
                                    return $q.defer().promise;

                                default:
                                    return $q.reject(response);
                            }
                        }
                    };
                }
            ];

            $httpProvider.interceptors.push(interceptor);
        }
    ]);