UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Config',
    initArgs: ['UXF.Common.ConfigFactory'],
    initFunc: function(configFactory) {
        'use strict';

        return configFactory();
    }
});
;UXF.Module.define('UXF.AssessmentBuilder.Constants', function() {
    'use strict';

    return function() {
        return {
            modePreviewAnswerKey: 'assessment_builder_print_test_answer',
            modePreview:  'assessment_builder_print_test',
            ASSESSMENT_TYPE: {
                PREP: 'PREP',
                TEST: 'TEST',
                PRACTICE: 'PRACTICE',
                HOMEWORK: 'HOMEWORK'
            },
            QUESTION_TYPE: {
                XML: 'xml-question', //TestNav
                MATHXL: 'mathxl-question',
                MULTIPLE_CHOICE: 'multiple-choice',
                GRIDDED_RESPONSE: 'gridded-response'
            },
            XML_SCHEMA: {
                QTI_1_2: 'QTI_1_2',
                QTI_2_1: 'QTI_2_1',
                CARTRIDGE: 'CARTRIDGE'
            }
        };
    };
});
;UXF.Module.define({
    dependencies: ['jQuery.fn.assessmentBuilder'],
    name: 'UXF.AssessmentBuilder.Directives.AssessmentBuilder',
    initArgs: [
        'angular',
        'jQuery',
        'window',
        'UXF.AssessmentBuilder.Config',
        'debug',
        'UXF.Common.i18n',
        'UXF.AssessmentBuilder.Constants'
    ],
    initFunc: function(angular, $, window, config, debug, i18n, Constants) {
        'use strict';

        var module, apply, CONSTANT = new Constants();

        apply = function(scope, fn) {
            if (scope.$$phase || (scope.$root && scope.$root.$$phase)) {
                fn();
            } else {
                scope.$apply(fn);
            }
        };

        module = angular.module('AssessmentServices.Builder.Directives.Builder', []);

        /**
         * Helper service to load an assessment.
         */
        module.factory('AssessmentBuilderService', ['$http', '$q', '$log', function($http, $q, $log) {
            var ret = {},
                restPath = config('contextPath');

            ret.getAssessmentSession = function(itemId, itemVersion) {
                var url = restPath + '/assessment/session';
                return $http.post(url, {
                    equellaId: itemId,
                    equellaVersion: itemVersion
                }).then(function(response) {
                    return response.data;
                });
            };

            ret.getAssessmentSummary = function(sessionId) {
                var url = restPath + '/assessment/' + sessionId + '/summary';
                return $http.get(url).then(function(response) {
                    return response.data;
                });
            };

            ret.getPreviewSessionSummary = function(itemId, itemVersion) {
                return ret.getAssessmentSession(itemId, itemVersion).then(function(sessionResponse) {
                    return ret.getAssessmentSummary(sessionResponse).then(function(summaryResponse) {
                        return angular.extend({}, {
                            summary: summaryResponse
                        }, {
                            previewSession: sessionResponse
                        });
                    }, function(err) {
                        debug.error('Failed to get assessment summary with session' + sessionResponse);
                        return $q.reject(err);
                    });
                }, function(err) {
                    debug.error('Failed to get assessment session with item ' + itemId + ' version ' + itemVersion);
                    return $q.reject(err);
                });
            };

            ret.loadAssessment = function(assessmentId, itemId, itemVersion, itemLanguage) {
                var opts,
                    skillsLocaleDescription = function(skill) {
                        if ((itemLanguage === 'Spanish' || i18n.getLang() === 'es') &&
                            (skill.spanishDescription !== '' && skill.spanishDescription !== null)) {
                            skill.description = skill.spanishDescription;
                        }
                    },
                    setSkillsLocaleDescription = function(response) {
                        var results = [];
                        angular.forEach(response.data.questions, function(question) {
                            angular.forEach(question.skillDetails, function(skill) {
                                skillsLocaleDescription(skill);
                            });
                        });
                        return response;
                    },
                    promise = null;

                opts = {
                    method: 'GET',
                    url: restPath + '/assessment/load/' + assessmentId + '.json'
                };
                promise = $http(opts)
                    .then(setSkillsLocaleDescription, function(err) {
                        debug.error('builder-directive:  Assessment ' + assessmentId + ' not found');
                        return $q.reject(err);
                    })
                    .then(function(response) {
                        if (!response.data.nativeAssessment &&
                            angular.isDefined(itemId) && angular.isDefined(itemVersion)) {
                            return ret.getPreviewSessionSummary(itemId, itemVersion)
                                    .then(function(previewSessionSummary) {
                                var i, questionCount = response.data.questions.length;
                                for (i = 0; i < questionCount; i++) {
                                    response.data.questions[i].pafId = previewSessionSummary.summary.questionIds[i];
                                    response.data.questions[i].isPaf = true;
                                }
                                return angular.extend(response.data, {
                                    sequence: previewSessionSummary.summary.sequence,
                                    previewSession: previewSessionSummary.previewSession
                                });
                            });
                        } else {
                            return response.data;
                        }
                    });
                return promise;
            };
            return ret;
        }]);

        module.controller('AssessmentBuilderController', ['$scope', '$window', function($scope, $window) {
            /**
             * @param errorType is one of:
             *  <ol>
             *      <li> assessment-builder.summary.validation-error - either Summary Title or
             *            Description is blank
             *       </li>
             *      <li> assessment-builder.question.validation-error.blank-fields - question or answer
             *            text is blank
             *        </li>
             *      <li> assessment-builder.question.validation-error.no-correct-answer -
             *           no correct answer is selected
             *      </li>
             *      <li> assessment-builder.question.validation-error.fields-too-long - question or answer text is
             *           too long
             *      </li>
             *      <li> assessment-builder.question.validation-error.too-few-responses - at least two responses are
             *           not present
             *      </li>
             *      <li> assessment-builder.success (generic success) </li>
             *      <li> assessment-builder.error (generic error) </li>
             * </ol>
             * @param errorMessage is the internationalized message
             * @param errorMessageElement - where the message will be displayed by the host application
             **/
            $scope.builderErrorReceiver = function(errorType, errorMessage, errorMessageElement) {
                var opts, handledFn;

                opts = {
                    messageType: errorType,
                    // default localized message passed to the host web app
                    message: errorMessage,
                    element: errorMessageElement
                };

                handledFn = $scope.builderErrorHandler;

                if (angular.isFunction(handledFn)) {
                    apply($scope, handledFn(opts));
                } else {
                    // If the host app doesn't override then they get the windows default alert.
                    $window.alert(opts.message);
                }
            };
        }]);

        module.directive('uxfAssessmentBuilder', ['AssessmentBuilderService', function(service) {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    // function to be invoked to report errors, e.g. validation error
                    builderErrorHandler: '=builderErrorHandler',
                    assessmentId: '@assessmentId',
                    itemLanguage: '@itemLanguage',
                    // the assessment builder widget configuration options received from  the host web app
                    configOptions: '=configOptions',
                    // watch this scope property to toggle between 'question' mode and 'reorder' mode
                    mode: '=mode',
                    create: '=create',
                    itemId: '=',
                    itemVersion: '='
                },
                templateUrl: config('templateRoot') + '/builder.html',
                controller: 'AssessmentBuilderController',
                link: {
                    post: function(scope, element, attrs) {
                        scope.$watch('assessmentId', function(newVal) {
                            var widgetOptions, triggerStart, triggerModified, triggerFactory, setupWidget;

                            if (!newVal && !scope.create) {
                                // the realize web app sets the assessment id asynchronously
                                //and by that time the builder may get loaded
                                return;
                            }

                            triggerStart = function() {
                                apply(scope, function() {
                                    scope.$emit('builder:modifying-assessment');
                                });
                            };

                            triggerFactory = function(evt) {
                                return function(e, data) {
                                    apply(scope, function() {
                                        // refire myself...
                                        scope.$emit(evt, data);
                                        // then notify the world that the assessment has been modified...
                                        scope.$emit('builder:assessment-modified');
                                    });
                                };
                            };

                            widgetOptions = {
                                'assessment:create:success': triggerFactory('assessment:create:success'),
                                'assessment:questionbanks:success': triggerFactory('assessment:questionbanks:success'),
                                'summary:save:success': triggerFactory('summary:save:success'),
                                'question:save:success': triggerFactory('question:save:success'),
                                'question:remove:success': triggerFactory('question:remove:success'),
                                'question:reorder:success': triggerFactory('question:reorder:success'),
                                'question:reorder:error': triggerFactory('question:reorder:error'),
                                'question:reorder:before': triggerFactory('question:reorder:before'),
                                'assessment:create:before': triggerStart,
                                'assessment:questionbanks:before': triggerStart,
                                'question:save:before': triggerStart,
                                'summary:save:before': triggerStart,
                                'navigation': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('builder:navigation', data);
                                    });
                                },
                                'builder-question:put:success': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('assessmentBuilder.questionCollectionView.putSuccess', data);
                                    });
                                },
                                'builder-question:get:printList': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('assessmentBuilder.get.printList', data);
                                    });
                                },
                                'builder-question:hideReorder:success': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('assessmentBuilder.hideReorder.success', data);
                                    });
                                },
                                'builder-question:unhideReorder:success': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('assessmentBuilder.unhideReorder.success', data);
                                    });
                                },
                                'builder-question:hidePrintButton:success': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('assessmentBuilder.hidePrintButton.success', data);
                                    });
                                },
                                'builder-question:showPrintButton:success': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('assessmentBuilder.showPrintButton.success', data);
                                    });
                                },
                                'builder-question:count:changed': function(e, size) {
                                    apply(scope, function() {
                                        scope.$emit('question:count:changed', size);
                                    });
                                },
                                'assessment-builder:create:cancelled': function(e, data) {
                                    apply(scope, function() {
                                        scope.$emit('builder:create:cancelled', data);
                                    });
                                },
                                'assessment-builder:question:enterEdit': function(e, data) {
                                    apply(scope, function() {
                                        debug.log('EnterEdit');
                                        scope.$emit('builder:question:enterEdit', data);
                                    });
                                },
                                'assessment-builder:question:leaveEdit': function(e, data) {
                                    apply(scope, function() {
                                        debug.log('LeaveEdit');
                                        scope.$emit('builder:question:leaveEdit', data);
                                    });
                                },
                                'assessment-builder.navigate.addQuestionFromBank': function(e, position) {
                                    apply(scope, function() {
                                        debug.log('Request addQuestionBank at position ' + position);
                                        scope.$emit('builder.navigate.addQuestionBank', position);
                                    });
                                },
                                'assessment-builder:exit': function(e, eventName) {
                                    apply(scope, function() {
                                        debug.log('exit builder');
                                        scope.$emit('builder.navigate.exitBuilder', eventName);
                                    });
                                }
                            };

                            debug.log('builder-directive: got assessment id: ' + newVal);
                            setupWidget = function(data) {
                                var isMutableAssessmentLoaded = true;

                                data = data || {};

                                if (false === data.mutable) {
                                    // assessment is locked because it may have been assigned to a class
                                    debug.log('builder-directive: got assessment which is immutable');

                                    // TODO short term fix for Release 2 to make those assessments
                                    //which have been assigned as readonly
                                    // http://jira.pearsoncmg.com/jira/browse/RGHT-518
                                    if (!scope.configOptions) {
                                        scope.configOptions = {};
                                    }
                                    if (false === scope.configOptions.isReadOnly) {
                                        isMutableAssessmentLoaded = false;
                                    }
                                    scope.configOptions.isReadOnly = true;
                                }
                                if (scope.configOptions) {
                                    angular.extend(widgetOptions, scope.configOptions);
                                }

                                widgetOptions.assessment = data || {};
                                widgetOptions.create = !!scope.create;
                                widgetOptions.callbackFn = scope.builderErrorReceiver;
                                element.assessmentBuilder(widgetOptions);
                                scope.element = element;
                                apply(scope, function() {
                                    if (isMutableAssessmentLoaded) {
                                        scope.$emit('builder:assessment-loaded');
                                    } else {
                                        // inform host app that an immutable assessment was loaded
                                        scope.$emit('builder:immutable-assessment-loaded');
                                    }
                                });
                            };

                            if (!scope.create) {
                                service.loadAssessment(scope.assessmentId, scope.itemId, scope.itemVersion,
                                    scope.itemLanguage).then(setupWidget);
                            } else {
                                setupWidget();
                            }
                        });

                        scope.$watch('mode', function(newVal) {
                            if (scope.element) {
                                scope.element.assessmentBuilder('setMode', newVal);
                            }
                        });

                        /*
                         * The host app broadcasts preNavigationChange before navigating away from the builder
                         */
                        scope.$on('preNavigationChange', function(event) {
                            $(element).assessmentBuilder('stopAudio');
                        });
                    }
                }
            };
        }]);

        /**
         * Directive for showing the print preview for an assessment.
         */
        module.directive('uxfAssessmentPrint', ['AssessmentBuilderService', function(service) {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    assessmentId: '@assessmentId',
                    showAnswers: '@showAnswers',
                    itemLanguage: '@itemLanguage',
                    correctResponseImageUrl: '@correctResponseImageUrl',
                    hiddenPosition: '@hiddenPosition'
                },
                templateUrl: config('templateRoot') + '/builder.html',
                controller: 'AssessmentBuilderController',
                link: {
                    post: function(scope, element, attrs) {
                        scope.$watch('assessmentId', function(newVal) {
                            if (!newVal) {
                                // the realize web app sets the assessment id asynchronously
                                //  and by that time the builder may get loaded
                                return;
                            }

                            debug.log('builder-directive: got assessment id: ' + newVal);
                            service.loadAssessment(scope.assessmentId, null, null, scope.itemLanguage)
                                .then(function(data) {

                                    var widgetOptions = {
                                        assessment: data,
                                        correctResponseImgUrl: scope.correctResponseImageUrl,
                                        mode: scope.showAnswers === 'true' ?
                                            'assessment_builder_print_test_answer' : 'assessment_builder_print_test'
                                    },
                                    positions = [],
                                    questions = [],
                                    pos;

                                    if (scope.hiddenPosition) {
                                        positions = scope.hiddenPosition.split(',');
                                        for (pos = 0; pos < data.questions.length; ++pos) {
                                            if (positions.indexOf((data.questions[pos].position - 1).toString()) < 0) {
                                                questions.push(data.questions[pos]);
                                            }
                                        }
                                        widgetOptions.assessment.questions = questions;
                                    }
                                    element.assessmentBuilder(widgetOptions);
                                });
                        });
                    }
                }
            };
        }]);

        module.run(['$rootScope', function($rootScope) {
            var setup, handleAuthenticationError, handlePermissionError, defaultFailHandler;

            handleAuthenticationError = function() {
                apply($rootScope, function() {
                    $rootScope.$broadcast('builder:unauthorized:access');
                });
            };

            handlePermissionError = function() {
                apply($rootScope, function() {
                    $rootScope.$broadcast('builder:permission:error');
                });
            };

            defaultFailHandler = function(jqXHR, textStatus, errorThrown) {
                if (this && this.statusCode && this.statusCode.hasOwnProperty(jqXHR.status)) {
                    // don't do anything, the error is being handled elsewhere...
                    return;
                }
                // note... not taking any default action here for the builder
            };

            setup = $.ajaxSetup();
            setup = setup || {};
            setup.statusCode = setup.statusCode || {};
            setup.statusCode[401] = setup.statusCode[401] || handleAuthenticationError;
            setup.statusCode[403] = setup.statusCode[403] || handlePermissionError;

            $.ajaxPrefilter(function(opts, originalOpts, jqXHR) {
                if (opts.unhandledStatus) {
                    jqXHR.fail(opts.unhandledStatus);
                } else {
                    jqXHR.fail(defaultFailHandler);
                }
            });

            $.ajaxSetup(setup);
        }]);
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.AssessmentModel',
    initArgs: [
        'Backbone',
        '_',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Models.QuestionCollection',
        'debug',
        'UXF.AssessmentBuilder.Constants'
    ],
    initFunc: function(Backbone, _, EventBus, QuestionCollection, debug, Constants) {
        'use strict';

        var CONSTANT = new Constants(),
            Model = Backbone.Model.extend({
                defaults: {
                    assetTitle: '',
                    assetDescription: '',
                    type: null,
                    mastery: null,
                    questions: null
                },

                initialize: function() {
                    // listening to myself, so no need to detach listener...
                    this.on('change:type', this._notifyTypeChange, this);
                    this.on('change:questions', this._questionCountChanged, this);

                    if (!this.get('questions')) {
                        this.set('questions', this.QuestionCollection.newInstance());
                    }
                },

                normalize: function(data) {
                    if (data.questions) {
                        var currentQuestions = this.get('questions');
                        if (_.isArray(data.questions)) {
                            // if we already have a question collection defined, update it instead
                            if (currentQuestions && currentQuestions.length === data.questions.length) {
                                debug.log('[assessmentmodel : normalize : updating]', currentQuestions, data.questions);

                                currentQuestions.each(function(question, index) {
                                    // new question array should match order
                                    question.set(data.questions[index]);
                                });
                                // remove data.questions now to prevent further updates...
                                delete data.questions;
                            } else {
                                data.questions = QuestionCollection.newInstance(data.questions);
                            }
                        }
                    // don't let questions get set to null... (unset)
                    } else if (data.questions === null) {
                        data.questions = QuestionCollection.newInstance();
                    } else if (data.type) {
                        data.type = data.type.toUpperCase();
                    }
                },

                // In QuestionModel.js we temporarily store the value of added question ids
                // (retrieved from the server when
                // the user does an 'Add question') in this.id.  We can't set it in the model during normalize() because
                // it causes an infinite loop.  Therefore, we take care of it here.
                updateAddedQuestionIds: function() {
                    var currentQuestions = this.get('questions');
                    _.each(currentQuestions.models, function(model, idx) {
                        if (model.id && !model.get('id')) {
                            model.set('id', model.id);
                        }
                    });
                },

                validate: function(attrs) {
                    if (!(attrs.questions instanceof QuestionCollection)) {
                        return 'questions attribute must be a QuestionCollection object';
                    }

                    //attrs.type can be undefined in the case of user creating new test, and we don't want error
                    if (attrs.type && !_.contains(CONSTANT.ASSESSMENT_TYPE, attrs.type)) {
                        return 'Unexpected assessment type: ' + attrs.type;
                    }
                },

                isNew: function() {
                    return !this.get('id');
                },

                containsFeedback: function() {
                    var count = 0,
                            questions;

                    questions = this.get('questions');
                    if (!questions || questions.length === 0) {
                        return false;
                    }

                    questions.each(function(q) {
                        var responses = q.get('responses');
                        if (!responses || responses.length === 0) {
                            return;
                        }

                        if (q.get('questionType') === 'multiple-choice') {
                            responses.each(function(r) {
                                var feedback = r.get('feedback');
                                if (feedback && feedback !== '') {
                                    count++;
                                }
                            });
                        }
                    });

                    return count > 0;
                },

                /**
                 * Not really model data.  Info needed to track where to insert questions.
                 * Putting it in the model muddies up the entities though, so just attach
                 *it to the model object instead.
                 * @param pos
                 */
                setInsertPosition: function(pos) {
                    this._insertPosition = pos;
                },

                getInsertPosition: function() {
                    return this._insertPosition;
                },

                /**
                 * Globally notify the world about type changes.  Necessary because the responses don't
                 * necessarily have access to the assessment model.
                 *
                 * @private
                 */
                _notifyTypeChange: function() {
                    var feedbackSupported = !(/test/i.test(this.get('type')));
                    EventBus.trigger('assessment-builder:feedback-supported', feedbackSupported);
                },

                _questionCountChanged: function() {
                    var questions = this.get('questions');
                    // should never be null, but just in case...
                    if (questions) {
                        questions.questionCountChanged();
                    }
                }
            });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.QuestionBanksItemModel',
    initArgs: ['jQuery', '_', 'Backbone'],
    initFunc: function($, _, Backbone) {
        'use strict';

        var Model = Backbone.Model.extend({
            defaults: {
                isChecked: false,
                isImported: false
            },
            idAttribute: 'assessmentId'
        });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.QuestionBanksCollection',
    initArgs: [
        'jQuery',
        '_',
        'Backbone',
        'UXF.AssessmentBuilder.Models.QuestionBanksItemModel'
    ],
    initFunc: function($, _, Backbone, QuestionBankItemModel) {
        'use strict';

        var Collection;

        Collection = Backbone.Collection.extend({
            model: QuestionBankItemModel
        });

        Collection.newInstance = function(opts) {
            return new Collection(opts);
        };

        return Collection;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.QuestionBanksModel',
    initArgs: [
        'jQuery',
        '_',
        'debug',
        'Backbone',
        'UXF.AssessmentBuilder.Models.QuestionBanksCollection',
        'UXF.AssessmentBuilder.Models.QuestionBanksItemModel'
    ],
    initFunc: function($, _, debug, Backbone, QuestionBanksCollection, QuestionBanksItemModel) {
        'use strict';

        var Model = Backbone.Model.extend({
            defaults: {
                page: 0,
                total: 0,
                questionBanks: null
            },

            initialize: function() {
                if (!this.get('questionBanks')) {
                    this.set('questionsBanks', QuestionBanksCollection.newInstance());
                }
            },

            normalize: function(data) {
                if (typeof data.questionBanks !== 'undefined') {
                    if (_.isArray(data.questionBanks)) {
                        data.questionBanks = new QuestionBanksCollection.newInstance(data.questionBanks);
                    } else {
                        data.questionBanks = new QuestionBanksCollection.newInstance();
                    }
                }
            },

            selectImported: function(ids) {
                if (!ids) {
                    return;
                }

                this.get('questionBanks').each(function(qb) {
                    var id = qb.get('assessmentId');
                    if (_.indexOf(ids, id) > -1) {
                        qb.set({isImported: true, isChecked: true});
                    }
                });
            },

            getCheckedIds: function() {
                var results = [];

                this.get('questionBanks').each(function(qb) {
                    if (qb.get('isChecked')) {
                        results.push(qb.get('assessmentId'));
                    }
                });

                return results;
            }
        });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.QuestionCollection',
    initArgs: ['Backbone', '_', 'UXF.AssessmentBuilder.Models.QuestionModel',
                'UXF.AssessmentBuilder.Models.ResponseModel',
               'UXF.Common.EventBus'],
    initFunc:  function(Backbone, _, QuestionModel, ResponseModel, EventBus) {
        'use strict';

        var Collection = Backbone.Collection.extend({
            model: QuestionModel,

            constructor: function() {
                Backbone.Collection.apply(this, arguments);

                this._renumberQuestions();
                this.trigger('initialized');
            },

            initialize: function() {
                this.bind('add', this._renumberQuestions, this);
                this.bind('remove', this._renumberQuestions, this);
                this.bind('reset', this._renumberQuestions, this);

                this.bind('add', this.questionCountChanged, this);
                this.bind('remove', this.questionCountChanged, this);
                this.bind('reset', this.questionCountChanged, this);
                this.bind('initialized', this.questionCountChanged, this);
                this.bind('change:id', this._questionCommitted, this);
            },

            comparator: function(q) {
                return q.get('position');
            },

            /**
             * Add a new question.
             * @param opts list of options.   Valid options:
             *      position:  (int) the position for this question
             *      griddedResponse:  (boolean) set if the new question should
             *                          be a gridded response question
             *
             * @return the new question model
             */
            addNewQuestion: function(opts) {
                var newQuestion, response;

                if (opts && opts.questionType === 'gridded-response') {
                    newQuestion = QuestionModel.newInstance({text: '', questionType: 'gridded-response'});
                    response = ResponseModel.newInstance({
                        responseType: 'gridded-response',
                        boxes: 1,
                        delim: null,
                        delimPosition: -1,
                        currencySymbol: null,
                        plusMinus: false,
                        correctVal: ''
                    });
                    newQuestion.get('responses').reset([response]);

                } else {
                    newQuestion = QuestionModel.newInstance({text: '', questionType: 'multiple-choice'});
                    newQuestion.get('responses').createEmptyResponses(4);
                }

                if (opts && isNaN(opts.position) === false) {
                    newQuestion.set('position', opts.position);
                }

                this.add(newQuestion, _.extend({
                        autoEdit: true
                    }, opts
                ));

                return newQuestion;
            },

            getNonNewQuestionCount: function() {
                var count = 0;

                this.each(function(question) {
                    if (!question.isNew()) {
                        count++;
                    }
                });

                return count;
            },

            /**
             * Notify the world if the question count changes.  Note this is called from a couple of different places
             * so it's public.
             */
            questionCountChanged: function() {
                var count = this.getNonNewQuestionCount();
                if (this._lastQuestionCount !== count) {
                    EventBus.trigger('assessment-builder:question-count-changed', { questionsSize: count });
                    this._lastQuestionCount = count;
                }
            },

            _renumberQuestions: function() {
                var newPositionCounter = 0;
                this.each(function(question, idx) {
                    if (_.isUndefined(question.isRemovedFlag) || !question.isRemovedFlag) {
                        newPositionCounter++;
                        question.setNewPosition(newPositionCounter);
                    } else {
                        question.setNewPosition(-1);
                    }
                    question.set('position', idx + 1);
                }, this);
            },

            /**
             * Watch for changes to the question id.  If id goes from null to non-null, then the question is
             * transitioning from new to existing and we need to update the question count.
             *
             * @param model
             * @param val
             * @private
             */
            _questionCommitted: function(model, val) {
                var old = model.previous('id');

                // if old is null and val is not null then the question has been committed so it can be counted
                // now.  Just recount the questions and notify the world of the new count...
                if (!old && val) {
                    this.questionCountChanged();
                }
            }
        });

        Collection.newInstance = function(opts) {
            return new Collection(opts);
        };

        return Collection;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.QuestionModel',
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.AssessmentBuilder.Models.ResponseCollection',
                'UXF.AssessmentBuilder.Models.SkillCollection',
                'debug', 'UXF.AssessmentBuilder.Constants'],
    initFunc: function($, Backbone, _, ResponseCollection, SkillCollection, debug, Constants) {
        'use strict';

        var CONSTANT = new Constants(),
            Model = Backbone.Model.extend({
                // tracks if a save request has been made
                isSavePending: false,
                isRemovedFlag: false,
                newPosition: 0,

                defaults: {
                    id: null,
                    text: '',
                    title: '',
                    questionType: 'multiple-choice',
                    responses: null,
                    skillDetails: null,
                    audioType: null,
                    audioId: null,
                    audioAssessmentId: null
                },

                constants: {
                    MAX_LENGTH: 3900
                },

                initialize: function() {
                    if (!this.get('responses')) {
                        this.set('responses', ResponseCollection.newInstance());
                    }

                    if (!this.get('skillDetails')) {
                        this.set('skillDetails', SkillCollection.newInstance());
                    }
                },

                isNew: function() {
                    // a new question has no id and no pending save request
                    return (!this.get('id') && !this.isSavePending);
                },

                savePending: function() {
                    this.isSavePending = true;
                },

                setRemoveFlag: function(val) {
                    this.isRemovedFlag = val;
                },

                setNewPosition: function(val) {
                    this.newPosition = val;
                },

                /**
                 * Attempt to convert incoming data to the correct format.  Allows for
                 * easily supporting alternate forms for set or construction.  (eg. can
                 * convert strings to ints, or arrays to collections, etc...)
                 *
                 * @param data the list of attributes that is changing.
                 */
                normalize: function(data) {
                    var currentResponses, currentSkills;
                    if (data.responses) {

                        currentResponses = this.get('responses');
                        if (_.isArray(data.responses)) {
                            // if we already have a response collection defined, update it instead
                            if (currentResponses && currentResponses.length === data.responses.length) {
                                debug.log('[questionmodel : normalize : updating]', currentResponses, data.responses);

                                currentResponses.each(function(response, index) {
                                    // new response array should match order
                                    response.set(data.responses[index]);
                                });
                                // remove data.questions now to prevent further updates...
                                delete data.responses;
                            } else {
                                data.responses = ResponseCollection.newInstance(data.responses);
                            }
                        }
                    } else if (data.responses === null) {
                        data.responses = ResponseCollection.newInstance();
                    }

                    if (data.skillDetails) {
                        currentSkills = this.get('skillDetails');
                        if (_.isArray(data.skillDetails)) {
                            // if we already have a skill collection defined, update it instead
                            if (currentSkills && currentSkills.length === data.skillDetails.length) {
                                debug.log('[questionmodel : skillDetails : normalize : updating]',
                                    currentSkills, data.skillDetails);

                                currentSkills.each(function(skill, index) {
                                    // new response array should match order
                                    skill.set(data.skillDetails[index]);
                                });
                                // remove data.questions now to prevent further updates...
                                delete data.skillDetails;
                            } else {
                                data.skillDetails = SkillCollection.newInstance(data.skillDetails);
                            }
                        }
                    } else if (data.skillDetails === null) {
                        data.skillDetails = SkillCollection.newInstance();
                    }

                    if (data.id) {
                        // for 'add question' we need to set the id returned from the server
                        if (this.isSavePending && !this.get('id')) {
                            // Don't use: this.set('id', data.id);  don't use set() here,
                            // which will cause an infinite loop. However, the model won't work properly if we
                            // Don't use set() eventually. As a work-around
                            // we'll store the new question id in this.id, and use that later to set the
                            // question id in the model. Specifically, in AssessmentModel.updateAddedQuestionIds().
                            this.id = data.id;
                        }
                        this.isSavePending = false;
                        this.newPosition = this.newPosition || 0;
                    }
                },

                validate: function(attrs) {
                    if (!(attrs.responses instanceof ResponseCollection)) {
                        return 'responses attribute must be a ResponseCollection object';
                    }

                    if (!(attrs.skillDetails instanceof SkillCollection)) {
                        return 'skillDetails attribute must be a SkillCollection object';
                    }

                    if (!attrs.questionType || !_.contains(CONSTANT.QUESTION_TYPE, attrs.questionType)) {
                        return 'Unexpected questionType: ' + attrs.questionType;
                    }
                },

                removeEmptyResponses: function() {
                    var self = this,
                        responses = this.get('responses'),
                        empties = [];

                    empties = responses.reject(function(response) {
                        return (response.get('text') && response.get('text').trim().length > 0);
                    });

                    if ('multiple-choice' === this.get('questionType')) {
                        responses.remove(empties);
                    }
                },

                _isQuestionComplete: function() {
                    var isTextBlank = !this.get('text') || $.trim(this.get('text')) === '';

                    return !isTextBlank;
                },

                _isQuestionTooLong: function() {
                    if (this.get('text') && this.get('text').length > this.constants.MAX_LENGTH) {
                        return true;
                    } else {
                        return false;
                    }
                },

                /**
                 * 1. triggers notification
                 * 2. triggers validation on question (filtered by notification)
                 * 3. triggers validation on responses (filtered by notification)
                 *
                 * * @return false if there was an error, true otherwise
                 */
                triggerValidation: function() {
                    var notifiedError;

                    // trigger notification
                    notifiedError = this._getNotification();
                    this._triggerNotification(notifiedError);
                    this._triggerValidation(notifiedError);

                    // trigger validation on responses (filtered by the notified error)
                    this.get('responses').triggerValidation(notifiedError);
                    return (notifiedError ? false : true);
                },

                /**
                 * Broadcast validation event to associated view
                 *
                 * param notifiedError if there was an error, null otherwise
                 */
                _triggerValidation: function(notifiedError) {

                    if (notifiedError) {
                        // trigger validation on question (filtered by the notified error)
                        if (notifiedError === 'assessment-builder.question.validation-error.fields-too-long') {
                            this.trigger('validation', { isValid: (!this._isQuestionTooLong()) });
                        } else if (notifiedError === 'assessment-builder.question.validation-error.blank-fields') {
                            this.trigger('validation', { isValid: this._isQuestionComplete() });
                        } else {
                            // case when the user entered answer in grid widget is not valid
                            this.trigger('validation', { isValid: true });
                        }
                    } else {
                        this.trigger('validation', { isValid: true });
                    }
                },

                /**
                 * Triggers notification with appropriate error, or none
                 * if there is no error
                 *
                 * param notifiedError if there was an error, null otherwise
                 */
                _triggerNotification: function(code) {

                    if (code) {
                        this.trigger('notification', {code: code});

                    // no errors
                    } else {
                        // notification event with no error signifies no errors
                        this.trigger('notification', {});
                    }
                },

                /**
                 * Validate the model and create error notifications
                 *
                 * @return notifiedError if there was an error, null otherwise
                 */
                _getNotification: function() {
                    var notifiedError = null,
                        correctAnswerCount = 0,
                        responseNotEmptyCount = 0,
                        existsBlankFields = false,
                        existsFieldsTooLong = false,
                        i, errors, grErrorCode;

                    this.get('responses').each(function(response) {
                        if (response.isEmpty() === false) {
                            responseNotEmptyCount++;
                        }
                        if ('text-option' === response.get('responseType')) {
                            errors = response.getTextErrors();
                            errors = errors.concat(response.getFeedbackErrors());
                            for (i = 0; i < errors.length; i++) {
                                if (errors[i] === 'assessment-builder.question.validation-error.blank-fields') {
                                    existsBlankFields = true;
                                } else if (errors[i] ===
                                    'assessment-builder.question.validation-error.fields-too-long') {
                                    existsFieldsTooLong = true;
                                }
                            }
                        } else if ('gridded-response' === response.get('responseType')) {
                            // a GR type question has only one response model and
                            //hence we wont we overwriting the grErrorCode variable
                            grErrorCode = response.getGriddedResponseError();
                        }

                        if (response.get('score') !== 0) {
                            correctAnswerCount++;
                        }
                    });

                    // notifications triggered in priority order

                    // ERROR: Fields too long
                    if (this._isQuestionTooLong() === true || existsFieldsTooLong) {
                        notifiedError = 'assessment-builder.question.validation-error.fields-too-long';

                    // ERROR: Blank fields
                    } else if (this._isQuestionComplete() === false || existsBlankFields) {
                        notifiedError = 'assessment-builder.question.validation-error.blank-fields';
                    } else if ('multiple-choice' === this.get('questionType')) {
                        // ERROR: too few responses
                        if (responseNotEmptyCount < 2) {
                            notifiedError = 'assessment-builder.question.validation-error.too-few-responses';
                        // ERROR: must be one answer
                        } else if (correctAnswerCount !== 1) {
                            notifiedError = 'assessment-builder.question.validation-error.no-correct-answer';
                        }
                    } else if ('gridded-response' === this.get('questionType')) {
                        // the grid has invalid data
                        if (grErrorCode && grErrorCode !== '') {
                            notifiedError = grErrorCode;
                        }
                    }

                    return notifiedError;
                },

                removeAudio: function() {
                    this.set({'audioId': null, 'audioAssessmentId': null, 'audioType': null});
                    this.get('responses').removeAudio();
                },

                /**
                 * check if the question and/or the associated responses has audio
                 * @param checkQuestionOnly - if true, check only the question model for audio and
                 * if false also check the associated responses for audio
                 */
                hasAudio: function(checkQuestionOnly) {

                    if (this.get('audioId')) {
                        return true;
                    } else if (checkQuestionOnly) {
                        return false;
                    }
                    // check responses for audio
                    return this.get('responses').hasAudio();
                }
            });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.ResponseCollection',
    initArgs: ['Backbone', 'UXF.AssessmentBuilder.Models.ResponseModel'],
    initFunc: function(Backbone, ResponseModel) {
        'use strict';

        var Model = Backbone.Collection.extend({
            model: ResponseModel,

            constructor: function() {
                Backbone.Collection.apply(this, arguments);
                this._reLabelResponses();
            },

            initialize: function() {
                // since I'm binding to myself, no need to worry about unbinding.
                this.bind('change:score', this._ensureSingleSelection, this);
                this.bind('add', this._reLabelResponses, this);
                this.bind('remove', this._reLabelResponses, this);
                this.bind('reset', this._reLabelResponses, this);
            },

            _ensureSingleSelection: function(item) {
                // de-selecting... don't care...
                if (!item.isCorrect()) {
                    return;
                }

                // if selecting an item, make sure all other items are deselected.
                // this is actually not ideal -- the reason they have a "score"
                // field is to support partial credit, but that's not really
                // supported by our builder yet.  For now, so only allow credit for a
                // single "correct" answer.
                this.each(function(i) {
                    if (i.cid !== item.cid) {
                        i.set({
                            score: 0
                        });
                    }
                });
            },

            _reLabelResponses: function() {
                this.each(function(i, idx) {
                    var label = String.fromCharCode('A'.charCodeAt(0) + idx);
                    i.set('label', label);
                });
            },

            createEmptyResponses: function(count) {
                var i;
                for (i = 0; i < count; i++) {
                    this.add(new ResponseModel());
                }
            },

            /**
             * removes audio from the response collection
             */
            removeAudio: function() {
                this.each(function(response, index) {
                    response.removeAudio();
                });
            },

            /**
             * checks if any one response model has audio
             */
            hasAudio: function() {
                var hasAudio = false;
                this.each(function(response, index) {
                    if (response.hasAudio()) {
                        hasAudio = true;
                        // break the loop
                        return false;
                    }
                });

                return hasAudio;
            },

            /**
             * Triggers validation on children (passing errorFilter)
             */
            triggerValidation: function(errorFilter) {
                this.each(function(i, idx) {
                    i.triggerValidation(errorFilter);
                });
            }
        });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.ResponseModel',
    initArgs: ['jQuery', '_', 'Backbone', 'debug'],
    initFunc: function($, _, Backbone, debug) {
        'use strict';

        var Model = Backbone.Model.extend({
            defaults: {
                id: null,
                label: 'A',
                text: '',
                feedback: '',
                score: 0,
                responseType: 'text-option',
                boxes: 5,
                currencySymbol: null,
                delim: null,
                delimPosition: '0',
                correctVal: '',
                plusMinus: false,
                audioType: null,
                audioId: null,
                audioAssessmentId: null
            },
            constants: {
                MAX_LENGTH: 3900
            },

            normalize: function(data) {
                if (data.hasOwnProperty('score')) {
                    // for now, only support scores of 0 and 1...
                    if (data.score !== 0) {
                        data.score = 1;
                    }
                }

                if (data.hasOwnProperty('feedback') && data.feedback === null) {
                    data.feedback = '';
                }
            },

            /**
             * Sets a custom validator for those response views which have not yet synced the user
             * response with data with its response model instance
             * e.g. A Gridded Response view must invoke validate on the grid widget contained in it to get the user
             * enetered correct answer
             */
            setViewValidator: function(context, responseViewValidator) {
                // the context in which the validator function will be invoked
                this._responseViewValidatorContext = context;
                this._responseViewValidator = responseViewValidator;
            },

            validate: function(attrs) {
                if (attrs.responseType &&
                    attrs.responseType !== 'gridded-response' &&
                    attrs.responseType !== 'text-option') {
                    return 'responseType must be one of "gridded-response" or "text-option"';
                }
            },

            /**
             *  return a string with value:
             *   - an error code indicating the type of validation error in the grid
             *   - empty string if the grid has valid data
             */
            getGriddedResponseError: function() {
                if (_.isFunction(this._responseViewValidator)) {
                    // for GR use the custom view validator function to validate the grid data
                    return this._responseViewValidator.call(this._responseViewValidatorContext);
                } else {
                    debug.error('Responseviewvalidator was not set on response model for GR.' +
                        'Please set it to validate the grid widget');
                    throw new Error('Responseviewvalidator was not set on response model for GR.' +
                        ' Please set it to validate the grid widget');
                }
            },

            /**
             * Returns an array of applicable error codes for the text field
             */
            getTextErrors: function() {
                var errors = [];

                // if (response) text is complete
                if (this._isTextComplete()) {
                    // valid if less than the max length
                    if (this.get('text').length > this.constants.MAX_LENGTH) {
                        errors.push('assessment-builder.question.validation-error.fields-too-long');
                    }
                } else {
                    // if text is blank, the entire response must be empty
                    if (!this.isEmpty()) {
                        errors.push('assessment-builder.question.validation-error.blank-fields');
                    }
                }
                return errors;
            },

            /**
             * Returns an array of applicable error codes for the feedback field
             */
            getFeedbackErrors: function() {
                var errors = [];

                if (this.get('feedback') && this.get('feedback').length > this.constants.MAX_LENGTH) {
                    // completed feedback must be less than max length
                    errors.push('assessment-builder.question.validation-error.fields-too-long');
                }
                return errors;
            },

            isEmpty: function() {
                return !this._isTextComplete() &&
                    !this._isFeedbackComplete() &&
                    this.get('score') === 0;
            },

            isCorrect: function() {
                return this.get('score') !== 0;
            },

            setAsCorrect: function() {
                this.set({
                    score: 1
                });
            },

            setAsIncorrect: function() {
                this.set({
                    score: 0
                });
            },

            _isTextComplete: function() {
                var isResponseBlank = !this.get('text') || $.trim(this.get('text')) === '';

                return !isResponseBlank;
            },

            _isFeedbackComplete: function() {
                var isFeedbackBlank = !this.get('feedback') || $.trim(this.get('feedback')) === '';

                return !isFeedbackBlank;
            },

            removeAudio: function() {
                this.set({
                    'audioId': null,
                    'audioAssessmentId': null,
                    'audioType': null
                });
            },

            hasAudio: function() {
                if (this.get('audioId')) {
                    return true;
                }
                return false;
            },

            triggerValidation: function(errorFilter) {
                var errors, errorCode,
                    i,
                    isTextValid = true,
                    isFeedbackValid = true,
                    isGridValid = true;

                if ('text-option' === this.get('responseType')) {
                    // loop through the text errors
                    errors = this.getTextErrors();
                    for (i = 0; i < errors.length; i++) {
                        if (errors[i] === errorFilter) {
                            isTextValid = false;
                            break;
                        }
                    }
                    // loop through the feedback errors
                    errors = this.getFeedbackErrors();
                    for (i = 0; i < errors.length; i++) {
                        if (errors[i] === errorFilter) {
                            isFeedbackValid = false;
                            break;
                        }
                    }
                    // trigger the validation
                    this.trigger('validation', {
                        isTextValid: isTextValid,
                        isFeedbackValid: isFeedbackValid
                    });
                } else if ('gridded-response' === this.get('responseType')) {
                    errorCode = this.getGriddedResponseError();
                    if (errorCode && (errorCode !== '') && (errorCode === errorFilter)) {
                        /**
                         * A not-null errorFilter can mean either:
                         * 1. the question text has validation errors, or
                         * 2. the grid widget had validation error
                         * Hence, send the  error validation event to the response view only if the grid
                         * has validation error and the question model is okay
                         * For example we do not want to show a validation icon on the grid widget if it is empty and
                         * the question text is also empty because the messages are different in both the cases.
                         * This is how the validation logic had been implemented for MC
                         */
                        isGridValid = false;
                    }

                    // trigger the validation
                    this.trigger('validation', {
                        isGridValid: isGridValid
                    });
                }

            }
        });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.SkillCollection',
    initArgs: ['Backbone', 'UXF.AssessmentBuilder.Models.SkillModel'],
    initFunc: function(Backbone, SkillModel) {
        'use strict';

        var Model = Backbone.Collection.extend({
            model: SkillModel,

            exportJSON: function() {
                // custom export that just removes all skills that are flagged
                // for removal...
                var data = [];
                this.each(function(skill) {
                    var item = skill.exportJSON();
                    if (item.isFlaggedForRemoval !== true) {
                        delete item.isFlaggedForRemoval;
                        data.push(item);
                    }
                });

                return data;
            }
        });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Models.SkillModel',
    initArgs: [
        'jQuery',
        '_',
        'Backbone'
    ],
    initFunc: function($, _, Backbone) {
        'use strict';

        var Model = Backbone.Model.extend({

            defaults: {
                id: '',
                description: '', //true - can undo-remove(undo template will be displayed)
                isFlaggedForRemoval: false // false - can remove(remove template will be displayed),
            },

            setFlaggedForRemoval: function(val) {
                this.set({
                    isFlaggedForRemoval: val
                });
            }

        });

        Model.newInstance = function(opts) {
            return new Model(opts);
        };

        return Model;
    }
});
;/*
 * Copyright 2013, Pearson Education, Learning Technology Group
 *
 * builder-service.js
 */

/*globals UXF, setTimeout */

UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Services.Builder',
    initArgs: [
        'jQuery',
        '_',
        'debug',
        'UXF.Common.i18n',
        'UXF.AssessmentBuilder.Config',
        'UXF.Common.EventBus'
    ],
    initFunc:function($, _, debug, i18n, config, EventBus) {
        'use strict';

        var commands = {},
                defaultImpl = {},
                customImpl,
                savedSelf,
                service;

        // private...
        defaultImpl._trigger = function(id, data) {
            EventBus.trigger('assessment-builder:publish-event', { event: id, data: data });
        };

        defaultImpl._fireEvents = function(promise, success, error) {
            var self = this, factory, successFn, errorFn;

            factory = function(evt, fail) {
                return function(d) {
                    self._trigger(evt, d);
                    return fail === true ? d : $.Deferred().reject(d);
                };
            };

            successFn = success ? factory(success) : null;
            errorFn = error ? factory(error, true) : null;

            promise.then(successFn, errorFn);
        };

        defaultImpl._buildPath = function() {
            var args = $.makeArray(arguments);
            args.unshift(config('contextPath'));

            return args.join('/') + '.json';
        };

        /**
         * Default impl for making ajax calls
         */
        defaultImpl._ajax = function(opts) {
            return $.ajax(opts);
        };

        /**
         * Default impl for displaying a dialog.  Depends on jquery UI and is not very smart.
         * Not intended for production use.
         */
        defaultImpl._dialog = function(opts) {
            var dialogOpts, buttons = [];

            // fix for a bug in the jquery-ui dialog.
            if ($.attrFn) { $.attrFn.text = true; }

            if ($('#uxf-dialog').length === 0) {
                $('body').append('<div id="uxf-dialog"><</div>');
            }

            _.each(opts.buttons, function(button) {
                buttons.push({
                    text: button.title,
                    click: function() {
                        button.clickHandler();
                        if ($('#uxf-dialog').dialog('isOpen')) {
                            $('#uxf-dialog').dialog('close');
                        }
                    }
                });
            });

            $('#uxf-dialog').text(opts.body);
            dialogOpts = {
                title: opts.title,
                modal: true,
                buttons: buttons,
                beforeClose: opts.closeClickHandler
            };

            $('#uxf-dialog').dialog(dialogOpts).dialog('open');
        };

        /**
         * Default implementation for displaying inline alerts.
         * Not intended for production.
         */
        defaultImpl._showAlert = function(type, message, el) {
            var alertClasses = {
                'SUCCESS': 'uxf-alert-success',
                'INFO': 'uxf-alert-info',
                'WARNING': 'uxf-alert-warning',
                'ERROR': 'uxf-alert-error'
            };

            $(el).removeClass(_.values(alertClasses).join(' '));

            $(el).addClass(alertClasses[type])
                    .html(message);
        };

        defaultImpl._successTimeout = 5000;
        /**
         * Default animation for the success indicator.
         *
         * @param successEl the element that shows the success message.
         * @param defaultEl the element the success msg replaces.
         * @returns {*}
         * @private
         */
        defaultImpl._successAnimation = function(successEl, defaultEl) {
            var defer = $.Deferred();

            $(successEl).show();
            if (defaultEl) {
                $(defaultEl).hide();
            }

            setTimeout(function() {
                $(successEl).fadeOut('slow', function() {
                    $(defaultEl).show();
                    defer.resolve();
                });
            }, defaultImpl._successTimeout);

            return defer.promise();
        };

        /* override setters */
        /**
         * Set the ajax implementation to use.
         *
         * Ajax method.  In theory, it may be possible to replace this method and use
         * another ajax backend (eg. angular -- would allow e2e tests to work in the builder)
         * If you try though be very careful because there are some slight differences
         * between jQuery's deferreds and $q in angular.
         *
         * @param opts jquery style $.ajax options.
         * @returns {*} a promise.  To be safe, assume it only supports then(success, error).
         * To be *really* safe wrap any non-jquery promise in a jquery one since that's
         * what the builder expects.
         */
        defaultImpl.setAjaxImpl = function(fn) {
            defaultImpl._ajax = fn;
        };

        /**
         * Override the implementation for displaying inline alerts.  The alert method must
         * accept 3 arguments:
         * - type: type of error (ERROR|WARN|INFO|SUCCESS)
         * - message: the message to display
         * - el: the element to write message into.
         */
        defaultImpl.setAlertImpl = function(fn) {
            defaultImpl._showAlert = fn;
        };

        /**
         * Override the success animation.
         * @param fn The function to execute.  Expects 2 args:
         * - successEl: the element that contains the success message
         * - defaultEl: the element that contains the normal display
         */
        defaultImpl.setSuccessAnimationImpl = function(fn) {
            defaultImpl._successAnimation = fn;
        };

        /**
         * Set the timeout for the success animation.
         * @param timeout
         */
        defaultImpl.setSuccessAnimationTimeout = function(timeout) {
            defaultImpl._successTimeout = timeout;
        };

        /**
         * Set the dialog implemention.  This is to allow the platform to define the method used to
         * displaying dialogs.
         *
         * The dialog function takes 1 argument.  An object that defines, the title, body, and buttons
         * on the dialog.
         */
        defaultImpl.setDialogImpl = function(fn) {
            defaultImpl._dialog = fn;
        };

        /* public methods intended to be called by the builder or to interact with the builder */
        /**
         * Create an assessment.
         *
         * @param assessment the assessment
         * @returns {*} a promise
         */
        defaultImpl.createAssessment = function(assessment) {
            var promise;

            this._trigger('assessment:create:before', assessment);

            promise = this._ajax({
                url: this._buildPath('assessments'),
                type: 'POST',
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                data: JSON.stringify(assessment)
            });

            this._fireEvents(promise, 'assessment:create:success', 'assessment:create:error');

            return promise;
        };

        defaultImpl.updateQuestionBanks = function(assessmentId, questionBanks, position) {
            var promise, url;

            this._trigger('assessment:questionbanks:before', questionBanks);

            url = this._buildPath('assessments', assessmentId, 'questionbanks') +
                '?positionAtWhichToInsertQuestions=' + position;
            promise = this._ajax({
                url: url,
                type: 'PUT',
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                data: JSON.stringify(questionBanks)
            });

            this._fireEvents(promise, 'assessment:questionbanks:success', 'assessment:questionbanks:error');

            return promise;
        };

        defaultImpl.saveSelf = function(selfObj) {
            savedSelf = _.extend({}, selfObj); // do deep copy
        };

        defaultImpl.restoreSelf = function() {
            return savedSelf;
        };

        defaultImpl.saveSummary = function(assessmentId, summary) {
            var promise;

            this._trigger('summary:save:before', summary);

            // remove some unnecessary stuff...
            delete summary.mutable;
            delete summary.questions;
            delete summary.previewSession; //Don't need PAF preview here
            delete summary.sequence;

            promise = this._ajax({
                url: this._buildPath('assessments', assessmentId, 'summary'),
                type: 'PUT',
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                data: JSON.stringify(summary)
            });

            this._fireEvents(promise, 'summary:save:success', 'summary:save:error');

            return promise;
        };

        defaultImpl.saveQuestion = function(assessmentId, question) {
            var promise,
                    type = 'PUT',
                    url;

            this._trigger('question:save:before', question);

            // update or create...
            if (question.id) {
                url = this._buildPath('assessments', assessmentId, 'questions', question.id);
            } else {
                url = this._buildPath('assessments', assessmentId, 'questions');
                type = 'POST';
            }

            promise = this._ajax({
                url: url,
                type: type,
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                data: JSON.stringify(question)
            });

            this._fireEvents(promise, 'question:save:success', 'question:save:error');

            return promise;
        };

        defaultImpl.removeQuestion = function(assessmentId, questionId) {
            var promise;

            this._trigger('question:remove:before', questionId);

            promise = this._ajax({
                url: this._buildPath('assessments', assessmentId, 'questions', questionId),
                type: 'DELETE'
            });

            this._fireEvents(promise, 'question:remove:success', 'question:remove:error');

            return promise;
        };

        defaultImpl.putQuestionsInAssessment = function(assessmentId, questions, isQuestionListChanged) {
            var promise;

            if (isQuestionListChanged) {
                this._trigger('question:remove:success');
            }

            promise = this._ajax({
                url: this._buildPath('assessments', assessmentId, 'questions'),
                type: 'PUT',
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                data: JSON.stringify(questions)
            });

            return promise;
        };

        defaultImpl.getQuestionIdList = function(questionsList) {

            questionsList = _.map(questionsList, function(question) {
                if (question.newPosition >= 0) {
                    return {
                        originalQuestionId: question.id || '',
                        sourceQuestionId: question.sourceQuestionId || '',
                        sourceQuestionBankId: question.sourceQuestionBankId || ''
                    };
                }
            });
            return questionsList;
        };

        defaultImpl.reorder = function(assessmentId, questionIds) {
            var promise;

            this._trigger('question:reorder:before', questionIds);

            promise = this._ajax({
                url: this._buildPath('assessments', assessmentId, 'questions/order'),
                type: 'PUT',
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                data: JSON.stringify(questionIds)
            });

            this._fireEvents(promise, 'question:reorder:success', 'question:reorder:error');

            return promise;
        };

        defaultImpl.listQuestionBanks = function(program, page, pageSize, isNativeAssessment) {
            var promise = this._ajax({
                url: this._buildPath('assessments', 'questionbanks'),
                type: 'GET',
                dataType: 'json',
                data: {
                    programs: $.makeArray(program),
                    // need to convert from page # to 1 based start index...
                    startIndex: page * pageSize + 1,
                    pageSize: pageSize,
                    nativeBanks: isNativeAssessment
                }
            });

            return promise.then(function(data) {
                // convert to a format the model expects.   Ideally, client and server
                // should agree, but server uses a format that is a bit more difficult
                // to deal with (specifically using start index vs. page number)
                data.total = data.totalQuestionBanks;
                data.page = page;

                delete data.totalQuestionBanks;
                delete data.startIndex;

                return data;
            });
        };

        /**
         * Default dialog impl.   WARNING:  This is not intended for production use.
         *
         * @param opts
         */
        defaultImpl.showDialog = function(opts) {
            return this._dialog(opts);
        };

        defaultImpl.showUnsavedEditDialog = function() {
            var opts, resolver, defer;

            defer = $.Deferred();
            resolver = function(code) {
                return function() {
                    if (defer.state() === 'pending') {
                        defer.resolve(code);
                    }
                };
            };

            opts = {
                id: 'assessment-builder.unsaved.title',
                dialogId: 'unsavedChangesModal',
                titleCode: 'assessment-builder.unsaved.title',
                bodyCode: 'assessment-builder.unsaved.body',
                title: i18n.local('assessment-builder.unsaved.title'),
                body: i18n.local('assessment-builder.unsaved.body'),
                isDismissible: false,
                closeClickHandler: resolver('close'),
                defaultClickHandler: resolver('save'),
                buttons: [
                    {
                        code: 'assessment-builder.unsaved.continue',
                        title: i18n.local('assessment-builder.unsaved.continue'),
                        isDefault: false,
                        clickHandler: resolver('continue')
                    }, {
                        code: 'assessment-builder.unsaved.save',
                        title: i18n.local('assessment-builder.unsaved.save'),
                        isDefault: true,
                        clickHandler: resolver('save')
                    }
                ]
            };

            this.showDialog(opts);

            return defer.promise();
        };

        defaultImpl.showAlert = function(type, message, el) {
            this._showAlert(type, message, el);
        };

        defaultImpl.successAnimation = function(successEl, defaultEl) {
            return this._successAnimation(successEl, defaultEl);
        };

        defaultImpl.finalAllChanges = function() {
            EventBus.trigger('assessment-builder:update-new-questionList', this);
        };

        defaultImpl.getRemovingQuestionsList = function() {
            EventBus.trigger('assessment-builder:get-removedQuestions-pos', this);
        };

        /**
         * Command is similar to a trigger.  The implementation is de-coupled from the calling service.  The difference
         * here is that there is only 1 listener, and that it can return a value.   In this case, the listener
         * must always return a promise.  If no command is found, then a rejected promise will be returned.
         *
         * http://addyosmani.com/resources/essentialjsdesignpatterns/book/#commandpatternjavascript or
         * http://lostechies.com/derickbailey/2011/11/18/
         * is-there-an-idiomatic-command-pattern-implementation-for-javascript/
         *
         * @param name the name of the command.
         * @param data the arguments to the command function
         * @returns {*} a promise.
         */
        defaultImpl.execute = function(name, data) {
            if (!_.isFunction(commands[name])) {
                return $.Deferred().reject('Implementation not found');
            }

            return commands[name](data);
        };

        /**
         * Register a command listener.
         *
         * @param name
         * @param impl
         * @param context
         */
        defaultImpl.registerCommand = function(name, impl, context) {
            if (context) {
                commands[name] = _.bind(impl, context);
            } else {
                commands[name] = impl;
            }
        };

        /**
         * Schedule a scroll event.  If multiple scroll requests are made within one functions context,
         * the last request is the only request that is honored.  If null, the scroll request is cancelled.
         *
         * @param el the element to scroll to.
         */
        defaultImpl.scheduleScrollTo = function(el) {
            if (el && el instanceof $) {
                EventBus.trigger('assessment-builder:schedule-scroll-to', el);

            } else if (el && el.$el) {
                EventBus.trigger('assessment-builder:schedule-scroll-to', el.$el);
            }
        };

        // public...
        /**
         * Service locator function.  Note that it's not a good idea to cache the results of this method
         * for the long term (ie. making it a private module level var).  Doing so may lead to unexpected
         * behavior.
         *
         * @returns {*}
         */
        service = function() {
            if (customImpl) {
                return customImpl;
            }

            return defaultImpl;
        };

        /**
         * Get the default implementation.
         *
         * @returns {{}}
         */
        service.getDefaultImplementation = function() {
            return defaultImpl;
        };

        /**
         * Set the default implementation.  IMPORTANT:  the new impl should follow the same interface
         * as the default.  No way to really enforce that with JS, so just be careful!
         *
         * @param customImpl
         */
        service.setImplementation = function(impl) {
            customImpl = impl;
        };

        return service;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.AccordionView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.AssessmentBuilder.Views.XmlQuestionView',
        'UXF.Common.CollectionView',
        'UXF.Common.QuickLinksView',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Constants',
        'UXF.AssessmentBuilder.Services.Builder'
    ],
    initFunc: function($, Backbone, _, debug, XmlQuestionView, CollectionView, QuickLinksView,
                EventBus, Constants, builderService) {
        'use strict';

        var View,
            accordionTemplate,
            CONSTANT = new Constants();

        accordionTemplate = [
            '<div class="uxf-add-items-from-bank"></div>',
            '<div class="expanderList">',
                '<div class="questionUndoContainer">',
                    '<div class="undo-message">',
                        '<span><%__ "assessment-builder.question.undo-desc" %></span>',
                        '<span class="uxf-question-controls"></span>',
                    '</div>',
                '</div>',
                '<div class="expanderRow">',
                    '<div class="expanderController" href="javascript://">',
                        '<div class="questionIndex">',
                            '<span><%- position %>' +
                            '</span>',
                        '</div>',
                    '</div>',
                    '<div class="expanderDetails">',
                        '<div class="detailsInner">',
                            '<div class="title"><%- displayTitle %></div>',
                            '<div class="uxf-question-quicklinks"></div>',
                            '<div class="uxf-toggle-show-question-quicklink"></div>',
                        '</div>',
                    '</div>',
                    '<div class="uxf-question-preview"></div>',
                '</div>',
            '</div>'
        ].join('');

        View = CollectionView.extend({
            className: 'uxf-question-container',
            options: {
                template: accordionTemplate,
                collectionName: 'responses',
                containerSelector: 'responseList',
                expanded: false,
                showFeedback: false,
                assessmentId: null,
                restPath: null,
                includeSkills: true,
                questionTitleMax: 160
            },
            classes: {
                responses: 'uxf-response-list'
            },
            selectors: {
                title: '.title',
                controllerA11y: '.expanderController .uxf-a11yOffScreen',
                expanderRow: '.expanderRow',
                showQuestion: '.uxf-show-question-quicklinks',
                questionPreview: '.uxf-question-preview',
                addItemFromBankLink: function() {
                    return this.$el.find('.uxf-add-items-from-bank');
                },
                toggleShowQuestion: '.uxf-toggle-show-question-quicklink',
                questionUnDoControls: '.uxf-question-controls'
            },
            localize: {
                showQuestion: 'assessment-builder.question.accordion.showQuestion',
                hideQuestion: 'assessment-builder.question.accordion.hideQuestion'
            },
            events: {
                'click .expanderRow .expanderDetails': '_accordionClicked',
                'click .questionUndoContainer .uxf-question-controls': '_undoRemoveQuestion'
            },
            initialize: function() {
                EventBus.on('assessment-builder:accordion:closeIfNotThis', this._onCloseOtherAccordionEvent, this);
                this._questionView = this._getAccordionContentClass();
                this._questionsCount = this.options.questionsCount;
                this._isExpanded = false;
                EventBus.on('assessment-builder:question-count-changed', this._updateQuestionsCount, this);
                this.model.on('change', this._modelChange, this);
                this._displayTitle = this._getDisplayTitle();
                this.firstRender = true;

                this._toggleShowQuestionLink = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.accordion.showQuestion',
                        className: 'icon-th-list',
                        event: 'toggle-show-question'
                    }]
                });

                this._quicklinksQuestionsUndo = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.undo-remove-skill',
                        className: 'icon-undo',
                        event: 'undo'
                    }]
                });

                this.listen(this._quicklinksQuestionsUndo, 'undo', this._undoRemoveQuestion, this);
                this.listen(this._toggleShowQuestionLink, 'toggle-show-question',
                    this._toggleShowQuestion, this);
            },

            _createView: function(model) {
                return CollectionView.prototype._createView.apply(this, [model, {
                }]);
            },

            _getAccordionContentClass: function() {
                var questionType = this.model.get('questionType');
                switch (questionType) {
                    case CONSTANT.QUESTION_TYPE.MULTIPLE_CHOICE:
                        //TO BE IMPLEMENTED return QuestionView; //From QuestionProxy
                    break;
                    case CONSTANT.QUESTION_TYPE.GRIDDED_RESPONSE:
                        //TO BE IMPLEMENTED return QuestionView;
                    break;
                    case CONSTANT.QUESTION_TYPE.MATHXL:
                    case CONSTANT.QUESTION_TYPE.XML:
                        return XmlQuestionView;
                    default:
                        debug.error('Unknown question type ' + questionType);
                        throw new Error('Unknown question type ' + questionType);
                }
            },

            _getDisplayTitle: function() {
                var title = this.model.get('title') || '';
                title = _.unescape(title);
                if (title.length > this.options.questionTitleMax) {
                    title = title.substring(0, this.options.questionTitleMax - 3) + '...';
                }
                return title;
            },

            setIsExpanded: function(isExpanded) {
                this._isExpanded = isExpanded;
            },

            isExpanded: function() {
                return this._isExpanded;
            },

            //For QuestionProxyView, NOOP
            getEditMode: function() {
                return false;
            },
            //For QuestionProxyView, NOOP
            leaveEditMode: function() {},

            _updateQuestionsCount: function(eventData) {
                this._questionsCount = eventData.questionsSize;
            },

            _waitToOpenAccordion: function() {
                this._counter = 0;
                EventBus.on('assessment-builder:accordion:accordionClosed', this._countCloseAccordionEvent, this);
            },

            _countCloseAccordionEvent: function() { //make sure all accordion is closed before open
                this._counter += 1;
                if (this._counter === this._questionsCount) {
                    EventBus.off('assessment-builder:accordion:accordionClosed', this._countCloseAccordionEvent, this);
                    this.openAccordion();
                }
            },

            _toggleShowQuestionText: function() {
                var showQuestionText = this.locate('toggleShowQuestion').find('a:first span');

                if (this.isExpanded()) {
                    showQuestionText.text(this.localize.hideQuestion());
                } else {
                    showQuestionText.text(this.localize.showQuestion());
                }
            },

            _accordionClicked: function(event) {
                var $this = $(event.currentTarget);
                if ($this.find('a').is('.disabled, :disabled')) {
                    event.stopPropagation();
                } else if (!this.isExpanded()) {
                    this._waitToOpenAccordion();
                    this.closeOtherAccordion();
                } else {
                    this.closeAccordion();
                }
            },

            _toggleShowQuestion: function(el, event) {
                if (event) {
                    event.stopPropagation();
                }
                this._accordionClicked(event);
            },

            openAccordion: function() {
                var row = this.locate('expanderRow');

                row.addClass('expanded').removeClass('rowClickable');
                this.setIsExpanded(true);
                this._toggleShowQuestionText();
                this._renderAccordionContent();
            },

            _renderAccordionContent: function() {
                this._AccordionContentView = this._questionView.newInstance(this, {
                    model: this.model,
                    sequence: this.options.sequence,
                    previewSession: this.options.previewSession
                });
                this._AccordionContentView.setElement(this.locate('questionPreview'));
                this._AccordionContentView.render();
            },

            _destroyAccordionContent: function() {
                if (this._AccordionContentView) {
                    this._AccordionContentView.destroy();
                }
            },

            closeAccordion: function() {
                var row = this.locate('expanderRow');

                this.setIsExpanded(false);
                row.removeClass('expanded').addClass('rowClickable');
                this._destroyAccordionContent();
                this._toggleShowQuestionText();
            },

            closeOtherAccordion: function() {
                EventBus.trigger('assessment-builder:accordion:closeIfNotThis', this);
            },

            _onCloseOtherAccordionEvent: function(ref) {
                if (this !== ref) { //Close siblings but not self
                    if (this.isExpanded()) {
                        this.closeAccordion();
                    }
                }
                EventBus.trigger('assessment-builder:accordion:accordionClosed');
            },

            _renderTemplate: function(template, model, classes) {

                CollectionView.prototype._renderTemplate.call(this, template, model, classes, {
                    includeSkills: this.options.includeSkills,
                    displayTitle: this._displayTitle,
                    position: this.model.newPosition || this.model.get('position')
                });

                if (this.model.newPosition >= 0) {
                    this.$el.find('.questionUndoContainer').hide();
                    this._toggleShowQuestionLink.setElement(this.locate('toggleShowQuestion'));
                    this._toggleShowQuestionLink.render();
                } else {
                    this.$el.find('.expanderRow').hide();
                    this.$el.find('.questionUndoContainer').show();
                    this._quicklinksQuestionsUndo.setElement(this.locate('questionUnDoControls'));
                    this._quicklinksQuestionsUndo.render();
                }

                this.options.postRenderViewType();
            },

            _modelChange: function() {
                var skipOpenFirstAccordion = true;
                this.render(skipOpenFirstAccordion);
            },

            removeQuestion: function() {
                this.$el.find('.expanderRow').hide();
                this.$el.find('.questionUndoContainer').show();
                this._quicklinksQuestionsUndo.setElement(this.locate('questionUnDoControls'));
                this._quicklinksQuestionsUndo.render();
            },

            _undoRemoveQuestion: function() {
                this.trigger('undo-success');
                this.$el.find('.questionUndoContainer').hide();
                this.$el.find('.expanderRow').show();
            },

            render: function(skipOpenFirstAccordion) {

                CollectionView.prototype.render.call(this);
                this.setElement(this.el);

                this._toggleShowQuestionText();

                if (this.model.newPosition >= 0) {

                    var self = this, skipScrollToQuestion = true;

                    if (this.model.get('position') === 1 && !skipOpenFirstAccordion &&  this.firstRender) {

                        _.defer(function() {
                            if (!self.isExpanded()) {
                                self.openAccordion();
                            }
                        });
                        this.firstRender = false;

                    } else {

                        _.defer(function() {
                            if (self.isExpanded() && self.$el.find('.uxf-question-preview-container').length < 1) {
                                self.closeOtherAccordion();
                                self.openAccordion();
                            }
                        });
                    }
                }

                return this;
            },

            onDestroy: function() {
                this.model.off('change', this._modelChange, this);
                EventBus.off('assessment-builder:accordion:closeIfNotThis', this._onCloseAllAccordionEvent, this);
                EventBus.off('assessment-builder:question-count-changed', this._updateQuestionsCount, this);
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.AssessmentBuilderView',
    initArgs: [
        'angular',
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'window',
        'UXF.Common.AbstractView',
        'UXF.Common.ButtonView',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Models.AssessmentModel',
        'UXF.AssessmentBuilder.Models.QuestionBanksModel',
        'UXF.AssessmentBuilder.Views.AssessmentSummaryView',
        'UXF.AssessmentBuilder.Views.CreateAssessmentView',
        'UXF.AssessmentBuilder.Views.ReorderCollectionView',
        'UXF.AssessmentBuilder.Views.EditAssessmentView',
        'UXF.AssessmentBuilder.Views.QuestionBanksView',
        'UXF.AssessmentBuilder.Views.ReorderView',
        'UXF.AssessmentBuilder.DialogUtil',
        'UXF.AssessmentBuilder.Config',
        'UXF.Assessment.Services.AudioPlayerService',
        'UXF.AssessmentBuilder.Services.Builder'
    ],
    initFunc: function(angular, $, Backbone, _, debug, window, AbstractView, ButtonView, EventBus,
        Templates, AssessmentModel, QuestionBanksModel, AssessmentSummaryView, CreateAssessmentView,
        ReorderCollectionView, EditAssessmentView, QuestionBanksView, ReorderView, DialogUtil,
        config, AudioPlayerService, builderService) {
        'use strict';

        var View;

        View = AbstractView.extend({
            options: {
                assessmentSummaryOptions: {},
                questionCollectionOptions: {},
                reorderCollectionOptions: {},
                includeSkills: true,
                includeExtendedHeader: true,
                ckeditorSkin: undefined,
                fixedHeaderHeight: 0,
                isReadOnly: false,
                defaultMode: 'edit',
                questionBanksPerPage: 10,
                program: 'Realize Sample Program',
                defaultThumbnailURL: null,
                allowTitleUpdate: true
            },
            templates: {
                normal: Templates['assessment-builder-view']
            },
            events: {},

            localize: {
                done: 'assessment-builder.done'
            },
            selectors: {
                header: '.uxf-assessment-builder-header',
                title: '.uxf-assessment-title-print',
                body: '.uxf-body',
                footer: '.uxf-assessment-builder-footer',
                audio: '.uxf-assessment-builder-audio'
            },
            modes: {
                create: '_createNewAssessmentView',
                questionBanks: '_createQuestionBanksView',
                edit: '_createEditView',
                reorder: '_createReorderView'
            },
            initialize: function() {
                var self = this,
                    isNativeAssessment,
                    qbPromise, viewPromise;

                builderService().registerCommand('commitChanges', this._commitChanges, this);

                if (!this.model) {
                    throw 'AssessmentBuilderView must be initialized with a model';
                }

                if (this.options.includeQuestionBankSupport) {
                    isNativeAssessment = this.model.get('nativeAssessment');

                    this.questionBanksModel = QuestionBanksModel.newInstance();
                    this.questionBanksModel.set({
                        programs: this.options.program,
                        pageSize: this.options.questionBanksPerPage
                    });
                    qbPromise = builderService().listQuestionBanks(
                        this.options.program, 0, this.options.questionBanksPerPage, isNativeAssessment
                    );
                    qbPromise.then(function(data) {
                        // this should enable the build from bank button if
                        // question banks are available
                        self.questionBanksModel.set(data);
                    });

                    this.questionBanksModel.on('change:total', this._onQuestionBanksCountChanged, this);
                    this._onQuestionBanksCountChanged(this.questionBanksModel, this.questionBanksModel.get('total'));
                }

                this._currentMode = this.options.defaultMode;
                viewPromise = self[self.modes[this.options.defaultMode]].apply(self);
                viewPromise.then(function(view) {
                    self._currentView = view;
                    self._renderContent();
                    self._updateModeClass();
                });

                EventBus.on('assessment-builder:ckeditor:alert', this._onCkEditorAlert, this);
                EventBus.on('assessment-builder:schedule-scroll-to', this._scheduleScrollToEvent, this);
            },

            getCurrentView: function() {
                return this._currentView;
            },

            getCurrentMode: function() {
                return this._currentMode;
            },

            _updateModeClass: function() {
                var modeClassArray = _.map(this.modes, function(viewName, modeName) {
                    return 'uxf-mode-' + modeName;
                });

                this._currentView.$el.removeClass(modeClassArray.join(' '));
                this._currentView.$el.addClass('uxf-mode-' + this._currentMode);
            },

            setMode: function(mode) {
                var self = this,
                    promise;

                if (!mode || mode === this._currentMode) {
                    return;
                }

                if (!this.modes[mode] || !_.isFunction(this[this.modes[mode]])) {
                    throw new Error('Unrecognized mode: ' + mode);
                }

                // commit all outstanding changes.  If it works, go ahead and switch modes...
                this.commit().then(function() {
                    self._currentMode = mode;

                    // if building a new _currentView, kill the old one...
                    if (self._currentView) {
                        self._currentView.$el.empty();
                        self._currentView.destroy();
                    }

                    promise = self[self.modes[mode]].apply(self);
                    promise.then(function(view) {
                        self._currentView = view;
                        self._renderContent();
                        self._updateModeClass();
                    });
                }, function() {
                    // notify the world of the unchanged status...
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'navigation',
                        data: self._currentMode
                    });
                });
            },

            commit: function(from) {
                if (!this._currentView || !_.isFunction(this._currentView.commit)) {
                    return $.Deferred().resolve();
                }

                return this._currentView.commit(from);
            },

            render: function() {
                this.$el.empty();
                this.$el.html(this.templates.normal({
                    isReadOnly: this.options.isReadOnly
                }));

                this._renderContent();

                // init the service
                AudioPlayerService.init({
                    flowplayerRoot: config('flowplayerRoot'),
                    contextPath: config('contextPath'),
                    jQuerySelector: this.locate('audio')
                });

                // create the audio player (a jquery widget will be created in the dom)
                AudioPlayerService.createAudioPlayer();
                debug.log('audio player created in assessment builder');

                return this;
            },

            onDestroy: function() {
                EventBus.off('assessment-builder:ckeditor:alert', this._onCkEditorAlert, this);
                EventBus.off('assessment-builder:schedule-scroll-to', this._scheduleScrollToEvent, this);

                AudioPlayerService.stop();

                if (this._currentView) {
                    this._currentView.destroy();
                }

                if (this.questionBanksModel) {
                    this.questionBanksModel.off('change:total', this._onQuestionBanksCountChanged, this);
                }

                EventBus.destroyNamespace('assessment-builder');
            },

            _renderContent: function() {
                var body = this.locate('body');

                if (!this._isRendered() || !this._currentView) {
                    return;
                }

                body.empty();
                this.locate('body').append(this._currentView.render().$el);
                angular.element(window.document).scrollTop(0);
                // notify new view of the # of available question banks...
                if (this.questionBanksModel) {
                    this._onQuestionBanksCountChanged(this.questionBanksModel, this.questionBanksModel.get('total'));
                }
            },

            _isRendered: function() {
                return this.locate('body').length > 0;
            },

            _createNewAssessmentView: function() {
                var defer = $.Deferred();

                defer.resolve(CreateAssessmentView.newInstance(this, {
                    model: this.model,
                    createMode: true,
                    includeExtendedHeader: this.options.includeExtendedHeader
                }));

                return defer.promise();
            },

            _createQuestionBanksView: function() {
                var promise,
                    isNativeAssessment = this.model.get('nativeAssessment'),

                    self = this;

                promise = builderService().listQuestionBanks(
                    this.options.program, 0, this.options.questionBanksPerPage, isNativeAssessment);
                return promise.then(function(data) {
                    var defer = $.Deferred();

                    self.questionBanksModel.set(data);
                    defer.resolve(QuestionBanksView.newInstance(this, {
                        model: self.questionBanksModel,
                        assessmentModel: self.model,
                        questionBanksPerPage: self.options.questionBanksPerPage,
                        program: self.options.program,
                        defaultThumbnailURL: self.options.defaultThumbnailURL
                    }));

                    return defer.promise();
                });
            },

            _createEditView: function() {
                var defer = $.Deferred();

                defer.resolve(EditAssessmentView.newInstance(this, {
                    model: this.model,
                    useDropdownForAddQuestion: this.options.useDropdownForAddQuestion,
                    includeSkills: this.options.includeSkills,
                    includeExtendedHeader: this.options.includeExtendedHeader,
                    ckeditorSkin: this.options.ckeditorSkin,
                    allowTitleUpdate: this.options.allowTitleUpdate,
                    currentMode: this.getCurrentMode()
                }));

                return defer.promise();
            },

            _createReorderView: function() {
                var defer = $.Deferred();

                defer.resolve(new ReorderView.newInstance(this, {
                    model: this.model,
                    includeExtendedHeader: this.options.includeExtendedHeader
                }));

                return defer.promise();
            },

            _commitChanges: function(from) {
                return this.commit(from);
            },

            _onQuestionBanksCountChanged: function(model, count) {
                // notify anyone who might care whether we should enable question bank support or not.
                EventBus.trigger('assessment-builder:question-banks-enabled', count > 0);
            },

            _onCkEditorAlert: function(txt) {
                var type = txt === 'assessment-builder.image.upload.success.message' ? 'SUCCESS' : 'ERROR';
                builderService().showAlert(type, this.i18n(txt), $('.ckeditor-validation'));
                $('.ckeditor-validation').show();
            },

            // HACK!  Provide a separate function that backbone can bind to so
            // that we can still spyOn _scheduleScrollTo and have the spy called
            // instead of the real method.
            _scheduleScrollToEvent: function(container) {
                debug.log('schedule-scroll-to: ', container);
                this._scheduleScrollTo(container);
            },

            /**
             * Schedule a scroll-to action.  The action will occur after the current JS
             * function context completes.  If more than a single scroll-to event is
             * scheduled for a single function context, only the last one will actually
             * run.  Scrolling can be disabled by triggering the event with a null or
             * undefined container.  To be safe, async operations can (and should) null out the
             * scroll to operation and then initiate a new one in the async handler callback.
             *
             * @param container The container to scroll to.
             * @private
             */
            _scheduleScrollTo: function(container) {
                var self = this;
                window.clearTimeout(this._scrollToTimer);
                this._scrollToTimer = window.setTimeout(function() {
                    if (container && container.length && container.offset()) {
                        $('html, body').animate({
                            scrollTop: container.offset().top - self.options.fixedHeaderHeight - 60
                        }, 500);
                    }
                }, 0);
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.AssessmentSummaryView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.AbstractView',
        'UXF.Common.ButtonView',
        'UXF.Common.ButtonGroupView',
        'UXF.Common.QuickLinksView',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Models.AssessmentModel',
        'UXF.AssessmentBuilder.Services.Builder',
        'UXF.AssessmentBuilder.Constants'
    ],
    initFunc: function($, Backbone, _, debug, AbstractView, ButtonView, ButtonGroupView, QuickLinksView,
                EventBus, Templates, AssessmentModel, builderService, Constants) {
        'use strict';

        var View, _initState, CONSTANT = new Constants();

        View = AbstractView.extend({
            options: {
                editMode: false,
                allowTitleUpdate: true
            },
            templates: {
                edit: Templates['assessment-summary-view.edit'],
                view: Templates['assessment-summary-view.view']
            },
            events: {
                'keyup :text, textarea': '_restrictLength',
                'click .uxf-summary-type input[type=radio]': '_typeButtonClicked',
                'click .uxf-summary-mastery input[type=radio]': '_masteryButtonClicked',
                'blur #uxf-assessment-title': '_titleChanged',
                'blur #uxf-assessment-description': '_descriptionChanged'
            },
            // TODO: to be consistent with model, title and description selector keys should be changed
            // to assetTitle and assetDescription

            selectors: {
                body: function() { return this.locate(this.options.editMode ? 'editMode' : 'viewMode'); },
                editMode: '.uxf-summary-edit-mode',
                viewMode: '.uxf-summary-view-mode',
                title: '#uxf-assessment-title',
                description: '#uxf-assessment-description',
                mastery: '#uxf-assessment-mastery',
                type: '#uxf-assessment-type',
                quicklinks: '.uxf-assessment-summary-quicklinks',
                saveLink: '.uxf-summary-save',
                editLink: function() { return this._viewModeQuickLinksView.$('.icon-pencil').parent(); },
                fieldErrors: '.uxf-field-validation-error',
                // jquery selector for element that will be used by the host app to set custom validation error messages
                errorMsgElSelector: 'div.uxf-summary ' +
                    'div.uxf-notification.uxf-notification-error.uxf-notification-message',
                masteryYesButton: '#uxf-mastery-yes',
                masteryNoButton: '#uxf-mastery-no',
                typeTestButton: '#uxf-type-test',
                typePracticeButton: '#uxf-type-practice',
                typePrepButton: '#uxf-type-prep',
                masteryNotification: '.uxf-summary-mastery .uxf-field-validation-error',
                typeNotification: '.uxf-summary-type .uxf-field-validation-error'
            },
            localize: {
                save: 'assessment-builder.header.save',
                next: 'assessment-builder.header.next',
                cancel: 'assessment-builder.header.cancel',
                testInstructions: 'assessment-builder.summary.test-instructions',
                practiceInstructions: 'assessment-builder.summary.practice-instructions',
                prepInstructions: 'assessment-builder.summary.prep-instructions',
                homeworkInstructions: 'assessment-builder.summary.homework-instructions',
                masteryYes: 'assessment-builder.summary.mastery.yes',
                masteryNo: 'assessment-builder.summary.mastery.no',
                numTriesTest: 'assessment-builder.summary.type.test',
                numTriesPractice: 'assessment-builder.summary.type.practice',
                numTriesPrep: 'assessment-builder.summary.type.prep',
                numTriesHomework: 'assessment-builder.summary.type.homework'
            },

            initialize: function() {
                var quickLinks = [];
                if (!this.model) {
                    throw 'AssessmentSummaryView must be initialized with a model';
                }

                this._viewModeQuickLinksView = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.header.edit',
                        className: 'icon-pencil',
                        event: 'header-edit-clicked'
                    }]
                });

                quickLinks.push({
                    label: 'assessment-builder.header.cancel',
                    className: 'icon-ban-circle',
                    event: 'cancel-header'
                });
                quickLinks.push({
                    label: 'assessment-builder.header.save',
                    className: 'icon-ok',
                    event: 'save-header'
                });

                this._saveAndCancelLinkHeader = QuickLinksView.newInstance(this, {
                    links: quickLinks
                });

                this._saveButton = ButtonView.newInstance(this, {
                    label: this.model.isNew() ? this.localize.next() : this.localize.save(),
                    classes: 'uxf-summary-save'
                });
                this._cancelButton = ButtonView.newInstance(this, {
                    label: this.localize.cancel(),
                    classes: 'uxf-summary-cancel uxf-secondary'
                });

                this._buttonGroup = ButtonGroupView.newInstance(this, {
                    buttons: [
                        this._cancelButton,
                        this._saveButton
                    ]
                });

                // flag set by the parent view to control if edit is allowed in this view.
                // ex2: do not allow edit if a question is being edited
                this._allowEdit = true;

                this.listen(this._viewModeQuickLinksView, 'header-edit-clicked', this._editHeader, this);
                this.listen(this._saveAndCancelLinkHeader, 'save-header', this._saveHeader, this);
                this.listen(this._saveAndCancelLinkHeader, 'cancel-header', this._cancelEditHeader, this);
                this.listen(this.model, 'change:mastery', this._masteryUpdated, this);
                this.listen(this.model, 'change:type', this._typeUpdated, this);

                _initState = _.clone(this.model.attributes);
                this.options.allowTestTypeUpdate = this.options.createMode || this.model.get('nativeAssessment');
            },

            commit: function(from) {
                var self = this,
                    unsavedEditPromise;

                if (!this.options.editMode || this === from) {
                    // no outstanding changes, just continue...
                    return $.Deferred().resolve();
                }

                unsavedEditPromise = builderService().showUnsavedEditDialog();
                // IMPORTANT:  must return result of then so that chaining works correctly.
                return unsavedEditPromise.then(function(choice) {
                    if (choice === 'save') {
                        return self._saveHeader().then(function() {
                            builderService().scheduleScrollTo(from);
                            return $.Deferred().resolve(); //Continue with user action
                        });

                    } else if (choice === 'continue') {
                        // save header, and allow next edit...
                        self._cancelEditHeader();
                        builderService().scheduleScrollTo(from);
                        return $.Deferred().resolve();

                    } else {
                        // stay where we are, don't allow op that requested commit to continue...
                        builderService().scheduleScrollTo(self);
                        return $.Deferred().reject();
                    }
                });
            },

            render: function() {
                var templateToRender, quickLinksToRender, ql;

                if (this.options.editMode) {
                    templateToRender = this.templates.edit;
                    quickLinksToRender = this._saveAndCancelLinkHeader;
                } else {
                    templateToRender = this.templates.view;
                    if (this.options.allowTitleUpdate) {
                        quickLinksToRender = this._viewModeQuickLinksView;
                    }
                }

                this.$el.empty();
                this.$el.html(templateToRender(_.extend(
                    this.model.toJSON(),
                    {
                        includeExtendedHeader: this.options.includeExtendedHeader,
                        allowTestTypeUpdate: this.options.allowTestTypeUpdate
                    }
                )));

                if (quickLinksToRender) {
                    quickLinksToRender.setElement(this.locate('quicklinks'));
                    quickLinksToRender.render();
                }

                this._masteryUpdated();
                if (!this.options.editMode || this.options.allowTestTypeUpdate) {
                    this._typeUpdated();
                }
                if (this._saveButton.isEnabled()) {
                    this._enableSaveButton();
                } else {
                    this._disableSaveButton();
                }

                this.trigger('render');

                return this;
            },

            _restrictLength: function(e) {
                var currentTarget = $(e.currentTarget),
                    currentVal = currentTarget.val(),
                    count = currentVal.length,
                    limit = currentTarget.attr('maxlength'),
                    remaining = limit - count;

                if (remaining <= 0) {
                    remaining = 0;
                    currentTarget.val(currentVal.substr(0, limit));
                }
            },

            /**
             * Set view to edit mode.  Note: use with care.  It does not do dirty checking.
             * @param mode
             */
            setEditMode: function(mode) {
                if (mode !== this.options.editMode) {
                    this.options.editMode = mode;
                    this.model.flush().store();
                    this.render();
                }
            },

            _validateFields: function() {
                var valid = true,
                    title = this.locate('title'),
                    description = this.locate('description');

                // reset icons on each attempt...
                this.locate('fieldErrors').css('visibility', 'hidden');

                if (title.val().trim().length <= 0) {
                    valid = false;
                    title.next('.uxf-field-validation-error').css('visibility', 'visible');
                }
                if (description.val().trim().length <= 0) {
                    valid = false;
                    description.next('.uxf-field-validation-error').css('visibility', 'visible');
                }

                if (!_.isBoolean(this.model.get('mastery'))) {
                    valid = false;
                    this.locate('masteryNotification').css('visibility', 'visible');
                }

                if (!this.model.get('type')) {
                    valid = false;
                    this.locate('typeNotification').css('visibility', 'visible');
                }

                return valid;
            },

            _restoreInitState: function() {
                this.model.set({
                    assetTitle: _initState.assetTitle,
                    assetDescription: _initState.assetDescription,
                    type: _initState.type,
                    mastery: _initState.mastery
                });
            },

            _editHeader: function() {
                var self = this, promise;

                promise = builderService().execute('commitChanges', this);
                promise.then(function() {
                    if (!self._isNewAssessment()) {
                        EventBus.trigger('assessment-builder:question:enterEdit', self.$el);
                        EventBus.trigger('assessment-builder:header:enterEdit', self.$el);
                    }
                    self.setEditMode(true);
                });
            },

            _cancelEditHeader: function(e) {
                if (this._isNewAssessment()) {
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'assessment-builder:create:cancelled'
                    });
                } else {
                    this._restoreInitState();
                    this.setEditMode(false);
                    EventBus.trigger('assessment-builder:question:leaveEdit', this.$el);
                    EventBus.trigger('assessment-builder:header:leaveEdit', this.$el);
                    this.trigger('edit-cancelled');
                }
            },

            _saveHeader: function() {
                var titleEl = this.locate('title'),
                    descrEl = this.locate('description'),
                    promise,
                    savedSelf,
                    self = this;

                this.model.set({
                    assetTitle: titleEl.val(),
                    assetDescription: descrEl.val()
                });

                if (this._validateFields()) {
                    self.locate('errorMsgElSelector').html('');
                    if (this._isNewAssessment()) {
                        promise = builderService().createAssessment(this.model.exportJSON());
                        return promise.then(function(assess) {
                            self.model.set(assess);
                            self.setEditMode(false);
                            EventBus.trigger('assessment-builder:publish-event', {event: 'navigation', data: 'edit'});
                        });
                    } else {
                        savedSelf = builderService().saveSelf(self);
                        promise = builderService().saveSummary(this.model.get('id'), this.model.exportJSON());
                        return promise.then(function(assess) {
                            var tmp = _.extend({}, assess);

                            // should I go ahead and rebuild the question models too?
                            delete tmp.questions;
                            self = builderService().restoreSelf();
                            self.model.set(tmp);
                            _initState = _.clone(self.model.attributes);
                            self.setEditMode(false);
                            EventBus.trigger('assessment-builder:question:leaveEdit', this.$el);
                            EventBus.trigger('assessment-builder:header:leaveEdit', this.$el);
                            self.trigger('save-success');
                        });
                    }
                } else {
                    builderService().showAlert('ERROR',
                            self.i18n('assessment-builder.summary.validation-error'),
                            self.locate('errorMsgElSelector'));
                    builderService().scheduleScrollTo(this);
                    return $.Deferred().reject();
                }
            },

            /**
             * Sets the flag that controls allowing edit. Set by the parent view
             */
            setAllowEdit: function(allowEdit) {
                this._allowEdit = allowEdit;
            },
            /**
              * This function determines if any edit request will be allowed
              */
            _getAllowEdit: function() {
                return this._allowEdit;
            },

            /**
              * Function to be used by widget to inquire of the state of editing.
              */
            isEditInProcess: function() {
                return (false === this._getAllowEdit());
            },

            _isNewAssessment: function() {
                return !this.model.get('id');
            },

            _masteryUpdated: function() {
                var mastery = this.model.get('mastery');

                this.locate('masteryYesButton').removeAttr('checked');
                this.locate('masteryNoButton').removeAttr('checked');

                if (mastery === true) {
                    this.locate('masteryYesButton').attr('checked', 'checked');
                    this.locate('mastery').text(this.localize.masteryYes());
                } else if (mastery === false) {
                    this.locate('masteryNoButton').attr('checked', 'checked');
                    this.locate('mastery').text(this.localize.masteryNo());
                }
            },

            _typeUpdated: function() {
                var type = this.model.get('type'),
                    typeEl = this.locate('type');

                this.locate('typeTestButton').removeAttr('checked');
                this.locate('typePracticeButton').removeAttr('checked');
                this.locate('typePrepButton').removeAttr('checked');
                EventBus.trigger('assessment-builder:header:enterEdit', this.$el);

                switch (type) {
                    case CONSTANT.ASSESSMENT_TYPE.TEST:
                        this.locate('typeTestButton').attr('checked', 'checked');
                        typeEl.text(this.localize.numTriesTest());
                    break;

                    case CONSTANT.ASSESSMENT_TYPE.PRACTICE:
                        this.locate('typePracticeButton').attr('checked', 'checked');
                        typeEl.text(this.localize.numTriesPractice());
                    break;

                    case CONSTANT.ASSESSMENT_TYPE.PREP:
                        this.locate('typePrepButton').attr('checked', 'checked');
                        typeEl.text(this.localize.numTriesPrep());
                    break;

                    case CONSTANT.ASSESSMENT_TYPE.HOMEWORK:
                        typeEl.text(this.localize.numTriesHomework());
                    break;
                }
            },

            _masteryButtonClicked: function(evt) {
                var target, val;

                evt.stopPropagation();

                target = evt.currentTarget;
                val = $(target).attr('value');
                this.model.set('mastery', val === 'true');
            },

            _typeButtonClicked: function(evt) {
                var target, val, promise, self = this;

                evt.stopPropagation();

                target = evt.currentTarget;
                val = $(target).attr('value');

                if ((val === 'PRACTICE' || val === 'PREP' || val === 'TEST') && this.model.containsFeedback()) {
                    promise = this._showFeedbackDialog();
                    promise.then(function() {
                        self.model.set('type', val);
                    }, function() {
                        // reset the radio button to the model value...
                        self._typeUpdated();
                    });

                } else {
                    this.model.set('type', val);
                }
            },

            _titleChanged: function() {
                var val = this.locate('title').val();
                this.model.set('assetTitle', val);
            },

            _descriptionChanged: function() {
                var val = this.locate('description').val();
                this.model.set('assetDescription', val);
            },

            _disableSaveButton: function() {
                // can't use this._saveButton.enable() because the
                // single view is rendered twice and that update will
                // only update one of the buttons.
                this._saveButton.setEnabled(false);
                this.$('.uxf-summary-save').addClass('uxf-disabled');
            },

            _enableSaveButton: function() {
                this._saveButton.setEnabled(true);
                this.$('.uxf-summary-save').removeClass('uxf-disabled');
            },

            _showFeedbackDialog: function() {
                var defer, opts, resolve, reject;

                defer = $.Deferred();

                resolve = function() {
                    defer.resolve();
                };

                reject = function() {
                    defer.reject();
                };

                opts = {
                    id: 'assessment-builder.summary.feedback',
                    titleCode: 'assessment-builder.summary.feedback.title',
                    bodyCode: 'assessment-builder.summary.feedback.body',
                    title: this.i18n('assessment-builder.summary.feedback.title'),
                    body: this.i18n('assessment-builder.summary.feedback.body'),
                    isDismissible: false,
                    closeClickHandler: reject,
                    defaultClickHandler: resolve,
                    buttons: [
                        {
                            code: 'assessment-builder.summary.feedback.cancel',
                            title: this.i18n('assessment-builder.summary.feedback.cancel'),
                            isDefault: false,
                            clickHandler: reject
                        }, {
                            code: 'assessment-builder.summary.feedback.ok',
                            title: this.i18n('assessment-builder.summary.feedback.ok'),
                            isDefault: true,
                            clickHandler: resolve
                        }
                    ]
                };

                builderService().showDialog(opts);

                return defer.promise();
            },

            onDestroy: function() {
                this._saveButton.destroy();
                this._saveButton = null;
                this._cancelButton.destroy();
                this._cancelButton = null;
                this._buttonGroup.destroy();
                this._buttonGroup = null;
                this._viewModeQuickLinksView.destroy();
                this._viewModeQuickLinksView = null;
                this._saveAndCancelLinkHeader.destroy();
                this._saveAndCancelLinkHeader = null;

                this.unlisten(this.model, 'change:mastery', this._masteryUpdated, this);
                this.unlisten(this.model, 'change:type', this._typeUpdated, this);
                this.unlisten(this.model, 'change', this._enableSaveButton, this);

                // TODO: Would this get in the way of AbstractView cleanup?
                this.model = null;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.CreateAssessmentView',
    initArgs: [
        'jQuery',
        '_',
        'UXF.Common.AbstractView',
        'debug',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Views.AssessmentSummaryView'
    ],
    initFunc: function($, _, AbstractView, debug, Templates, SummaryView) {
        'use strict';

        var View;

        View = AbstractView.extend({
            templates: {
                body: Templates['assessment-builder-layout']
            },
            selectors: {
                header: '.uxf-assessment-builder-header'
            },

            initialize: function() {
                if (!this.model) {
                    throw new Error('CreateAssessmentView must be initialized with an Assessment model');
                }

                this._summaryView = SummaryView.newInstance(this, _.extend({}, this.options, {
                    el: undefined
                }));
                this._summaryView.setEditMode(true);
            },

            commit: function(from) {
                return this._summaryView.commit(from);
            },

            render: function() {
                this.$el.append(this.templates.body);
                this.locate('header').append(this._summaryView.render().$el);

                return this;
            },

            onDestroy: function() {
                this._summaryView.destroy();
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.DialogUtil',
    initArgs: [
        'jQuery',
        '_',
        'debug',
        'UXF.Common.i18n'
    ],
    initFunc: function($, _, debug, i18n) {
        'use strict';

        var util = {
            createSimpleDialog: function(params) {
                var dialogObj = {},
                    buttonObj;
                dialogObj.id = params.id;
                dialogObj.titleCode = params.titleCode;
                dialogObj.bodyCode = params.bodyCode; // doubles as unique id for this dialog
                dialogObj.title = i18n.local(params.titleCode);
                dialogObj.body = i18n.local(params.bodyCode);
                dialogObj.isDismissible = params.isDismissible === true ? true : false;
                // using unique id (i.e. i18n Description Code).
                // if it was permanently dismissed, the host app should call defaultClickHandler
                // if not, the host app will display the dialog
                // NOTE: The host app should only save the dialog as dismissed if the default is selected.

                // handler to be called if the close ('x') button is clicked
                dialogObj.closeClickHandler = params.closeClickHandler;
                dialogObj.defaultClickHandler = params.defaultClickHandler;

                if (params.buttons && params.buttons.length) {
                    dialogObj.buttons = [];
                    _.each(params.buttons, function(button, idx) {
                        buttonObj = {};
                        buttonObj.code = button.code;
                        buttonObj.title = i18n.local(button.code);
                        buttonObj.isDefault = button.isDefault;
                        buttonObj.clickHandler = button.clickHandler; // handler to be called if this button is clicked

                        dialogObj.buttons[idx] = buttonObj;
                    });
                }
                return dialogObj;
            }
        };

        return util;
    }
});
;/*global UXF,document */

UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.DropdownView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'UXF.Common.AbstractView',
        'UXF.Common.Classes',
        'UXF.Common.BrowserUtils'
    ],
    initFunc: function($, Backbone, _, AbstractView, Classes, browserUtils) {
        'use strict';

        var View, singleLinkTemplate, dropdownTemplate;

        dropdownTemplate = [
          '<div class="<%= classes.dropdownLinks %>">',
          '<ul class="uxf-quick-link-dropdown">',
            '<% for (var i=0; i<links.length; i++) { %>',
            '<% if (links[i].sub) { %>',
            '<li class="dropdown">',
              '<a href="javascript://" class="uxf-dropdownmenu dropdown-toggle" role="button" data-toggle="dropdown">',
                '<i class="<%= links[i].className %>"/>',
                '<span><%__ links[i].label %></span>',
                '<i class="icon-caret-down"></i>',
              '</a>',
              '<ul class="dropdown-menu" role="menu" aria-labelledby="uxfDropdown">',
                '<% for (var j=0; j<links[i].sub.length; j++) { %>',
                '<li>',
                  '<a href="javascript://" class="uxf-dropdownlink"' +
                    ' data-event-id="<%= links[i].sub[j].event %>" tabindex="-1">',
                    '<i class="<%= links[i].sub[j].className %>"/>',
                    '<span><%__ links[i].sub[j].label %></span>',
                  '</a>',
                '</li>',
                '<% } %>', //end foreach links[i].sub
              '</ul>',
            '</li>',
            '<% } else { %>', //end if links[i].sub
            '<li>',
              '<a href="javascript://" href="javascript://" class="uxf-dropdownlink" ' +
              'data-event-id="<%= links[i].event %>">',
                '<i class="<%= links[i].className %>"/>',
                '<span><%__ links[i].label %></span>',
              '</a>',
            '</li>',
            '<% } %>', //end else !links[i].sub
            '<% } %>', //end foreach links
            '<div style="clear:both;"></div>',
          '</ul>',
          '</div>'
        ].join('');

        singleLinkTemplate = [
          '<div class="<%= classes.dropdownLinks %>">',
            '<% for (var i=0; i<links.length; i++) { %>',
            '<a href="javascript://" class="uxf-dropdownlink" data-event-id="<%= links[i].event %>">',
              '<i class="<%= links[i].className %>"/>',
              '<span><%__ links[i].label %></span>',
            '</a>',
            '<% } %>', //end foreach links
          '</div>'
        ].join('');

        View = AbstractView.extend({
        options: {
            links: [],
            alt: false,
            topDrdopdown: false,
            dropdownMode: false // no dropdown by default
        },
        events: {
            'keydown .uxf-dropdownmenu': '_handleMenuButtonKeyDown',
            'keydown .dropdown-menu': '_handleMenuKeyDown',
            'click .uxf-dropdownmenu': '_handleMenuClick',
            'click .uxf-dropdownlink': '_handleLinkClick'
        },
        classes: Classes.quickLinks,
        selectors: {
            addQuestionLink: '.uxf-questions-quicklinks',
            dropdownLink: '.uxf-questions-quicklinks',
            dropdownAddQuestionLink: '.uxf-dropdown-addquestions-quicklinks',
            menus: '.uxf-dropdownmenu',
            links: '.uxf-dropdownlink',
            dropdownLinks: 'dropdownLinks',
            icon: 'i'
        },
        templates: { //other, non-default templates
            nonDropdown: singleLinkTemplate,
            dropdown: dropdownTemplate
        },

        initialize: function() {
            var view = this;
            this.usesBootstrap = $.isFunction($.fn.dropdown);
            if (!this.options.links && this.options.links.length === 0) {
                throw 'No links provided';
            }
            if (!!this.options.topDropdown && !this.usesBootstrap) {
                $(document)
                    .on('click.dropdown.data-api', function(e) {
                        var $active = false;
                        if (!!e.currentTarget && !!e.currentTarget.activeElement &&
                                !!view.selectors && !!view.selectors.links) {
                            $active = $(e.currentTarget.activeElement);
                            if (!$active.hasClass('dropdown-toggle') && !$active.parents(view.selectors.links).length) {
                                view._clearMenus(e);
                            }
                        }
                    });
            }
        },

        /**
         * Get the dropdown mode.
         * @return {Boolean}
         */
        isDropdownMode: function() {
            return this.options.dropdownMode;
        },

        render: function() {

            this.$el.empty();

            if (this.isDropdownMode()) {
                this.$el.html(this.templates.dropdown({
                    links: this.options.links,
                    alt: this.options.alt
                }));
            } else {
                this.$el.html(this.templates.nonDropdown({
                    links: this.options.links,
                    alt: this.options.alt
                }));
            }

            return this;
        },

        _clearMenus: function(event) {
            var view = this,
                e = $.Event('hide.bs.dropdown');
            if (this.usesBootstrap) {
                return;
            }

            $('.dropdown-backdrop').remove();
            $('[data-toggle=dropdown]').parent('.open').each(function(ev) {
                var $this = $(this);
                $this.trigger(e);
                if (e.isDefaultPrevented()) {
                    return;
                }
                $this.removeClass('open').trigger('hidden.bs.dropdown');
                $this.find(view.selectors.links + '[tabindex=0]').attr('tabindex', '-1');
            });
        },

        _handleMenuButtonKeyDown: function(event) {
            var $this = $(event.currentTarget),
                $parent = $this.parent(),
                isActive = $parent.hasClass('open'),
                $items = false,
                index = 0;

            if (this.usesBootstrap) {
                return false;
            }

            if ($this.is('.disabled, :disabled')) {
                return;
            }

            if ((!isActive && (event.keyCode === 40 || event.keyCode === 32)) ||
                    (isActive && (event.keyCode === 27 || event.keyCode === 38))) {
                event.preventDefault();
                event.stopPropagation();

                if (event.which === 27) {
                    $parent.find('[data-toggle=dropdown]').focus();
                }
                $this.click();
            } else if (event.keyCode === 13) {
                event.preventDefault();
                event.stopPropagation();
            }

            $items = $('[role=menu] li:not(.divider):visible a', $parent);
            if (!$items.length) {
                return;
            }

            $items.eq(index).focus();
        },

        _handleMenuKeyDown: function(event) {
            var $this = $(event.currentTarget),
                $parent = $this.parent(),
                isActive = $parent.hasClass('open'),
                $items = false,
                index = 0;

            if (!/(38|40|27|13)/.test(event.keyCode)) {
                return false;
            }

            if (isActive && event.keyCode === 27) {
                event.preventDefault();
                event.stopPropagation();
                $parent.find('[data-toggle=dropdown]').focus();
                $parent.find('[data-toggle=dropdown]').click();
            }

            $items = $('[role=menu] li:not(.divider):visible a', $parent);

            index = $items.index($items.filter(':focus'));
            if (event.keyCode === 38 && index > 0) {
                index--;
            } // up
            if (event.keyCode === 40 && index < $items.length - 1) {
                index++;
            } // down
            if (index === -1) {
                index = 0;
            }

            $items.eq(index).focus();
        },

        _handleMenuClick: function(event) {
            var $this = $(event.currentTarget),
                $parent = $this.parent(),
                isActive = $parent.hasClass('open'),
                e = $.Event('show.bs.dropdown');

            if (this.usesBootstrap) {
                return;
            }
            if ($this.is('.disabled, :disabled')) {
                return;
            }

            this._clearMenus(event);

            if (!isActive) {
                if ((typeof document.hasOwnProperty === 'function') &&
                        !!document.documentElement.hasOwnProperty('ontouchstart')) {
                    // if mobile we we use a backdrop because click events don't delegate
                    $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', this._clearMenus(event));
                }

                $parent.trigger(e);
                if (e.isDefaultPrevented()) {
                    return;
                }

                $parent
                    .toggleClass('open')
                    .trigger('shown.bs.dropdown');
                $parent.find(this.selectors.links).attr('tabindex', '0');
            }

            $this.focus();
        },

        _handleLinkClick: function(event) {
            // Commenting out this event propagation so that Print menu goes away when user clicks a link.
            //    event.stopPropagation();
            //    event.preventDefault();

            var eventId = $(event.currentTarget).data('eventId'),
                $element = null;

            this.trigger(eventId, event.currentTarget);
            this._clearMenus();
            // Start IE8 hack.....
            // Removing the event propagation above isn't enough for IE8.
            // This IE8 hack is to remove the Print menu dropdown when the user clicks on a link in the builder.
            if (browserUtils.getBrowserType() === 'Explorer' && browserUtils.getVersion() === 8) {
                // This code only executed for IE8....
                $element = $('a#print-menu.dropdown-toggle');
                if ($element && (event.currentTarget !== $element) && $element.parent().hasClass('open')) {
                    $element.parent().removeClass('open');
                }
            }
            // ... End IE8 hack.
        },

        onDestroy: function() {
            // nothing here
        }

    });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.EditAssessmentView',
    initArgs: [
        'jQuery',
        '_',
        'UXF.Common.AbstractView',
        'debug',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Models.AssessmentModel',
        'UXF.AssessmentBuilder.Views.AssessmentSummaryView',
        'UXF.AssessmentBuilder.Views.QuestionCollectionView',
        'UXF.AssessmentBuilder.Views.InstructionBarView',
        'UXF.AssessmentBuilder.Constants'
    ],
    initFunc: function($, _, AbstractView, debug, EventBus, Templates, AssessmentModel,
            SummaryView, QuestionCollectionView, InstructionBarView, Constants) {
        'use strict';

        var View, CONSTANT = new Constants();

        View = AbstractView.extend({
            options: {
                allowTitleUpdate: true
            },
            selectors: {
                header: '.uxf-assessment-builder-header',
                instruction: '.uxf-assessment-builder-instruction',
                instructionNoText: '.uxf-assessment-builder-instruction-no-text',
                body: '.uxf-assessment-builder-content'
            },
            templates: {
                layout: Templates['assessment-builder-layout']
            },

            initialize: function() {
                this._questionsView = QuestionCollectionView.newInstance(this, {
                    model: this.model,
                    assessmentId: this.model.get('id'),
                    useDropdownForAddQuestion: this.options.useDropdownForAddQuestion,
                    includeSkills: this.options.includeSkills,
                    includeExtendedHeader: this.options.includeExtendedHeader,
                    ckeditorSkin: this.options.ckeditorSkin
                });
                this._summaryView = SummaryView.newInstance(this, {
                    model: this.model,
                    includeExtendedHeader: this.options.includeExtendedHeader,
                    allowTitleUpdate: this.options.allowTitleUpdate
                });
                this._instructionBarView = InstructionBarView.newInstance(this, {
                    model: this.model,
                    currentMode: this.options.currentMode,
                    showText: true
                });
                this._instructionBarViewBottom = InstructionBarView.newInstance(this, {
                    model: this.model,
                    currentMode: this.options.currentMode,
                    showText: false
                });
            },

            commit: function(from) {
                var commits = [];

                commits.push(this._summaryView.commit(from));
                commits.push(this._questionsView.commit(from));

                return $.when.apply($, commits);
            },

            render: function() {
                this.$el.empty();
                this.$el.html(this.templates.layout());

                this._summaryView.setElement(this.locate('header'));
                this._questionsView.setElement(this.locate('body'));

                this._summaryView.render();
                this._questionsView.render();

                this._instructionBarView.setElement(this.locate('instruction'));
                this._instructionBarView.render();
                this._instructionBarViewBottom.setElement(this.locate('instructionNoText'));
                this._instructionBarViewBottom.render();

                return this;
            },

            onDestroy: function() {
                this._instructionBarView.destroy();
                this._instructionBarViewBottom.destroy();
                this._summaryView.destroy();
                this._questionsView.destroy();
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;/*global UXF, $ */

UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.GriddedResponseEditLayoutView',
    initArgs: [
        'Backbone',
        '_',
        'debug',
        'UXF.Common.CollectionView',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Views.ResponseProxyView',
        'UXF.AssessmentBuilder.Views.GriddedResponseView',
        'UXF.AssessmentBuilder.Models.ResponseModel'
    ],
    initFunc: function(Backbone, _, debug, CollectionView, EventBus, ResponseProxyView,
            GriddedResponseView, ResponseModel) {
        'use strict';

        var View,
            layoutTemplate,
            editTemplate;

        layoutTemplate = [
            '<form>',
                '<fieldset><legend class="uxf-a11yOffScreen">' +
                    '<%__ "assessment-builder.gridded-response.selections.legend" %></legend>',
                    '<label for="selectColumn"><b><%__ "assessment-builder.gridded-response.columns" %></b></label>',

                    '<div class="uxf-field-wrapper">',
                        '<select id="selectColumn" class="uxf-box-select">',
                            '<% for (var i = 1; i <= 9; i++) { %>',
                                '<option value = "<%= i %>" <% if (boxesValue === i) { %>selected<% } %>><%= i %>' +
                                    '</option>',
                            '<% }; %>',
                        '</select>',
                    '</div>',
                    '<label for="decimal"><b><%__ "assessment-builder.gridded-response.decimal" %></b></label>',
                    '<div class="uxf-field-wrapper">',
                        '<select id="decimal" class="uxf-delim-select">',
                            '<% for (var i = 0; i < delimOptions.length; i++) { %>',
                                '<option value = "<%= delimOptions[i].value %>" ' +
                                    '<% if (delimValue === delimOptions[i].value) { %>selected<% } %>>' +
                                        '<%__ delimOptions[i].label %></option>',
                            '<% }; %>',
                        '</select>',
                    '</div>',
                    '<label class="uxf-a11yOffScreen" for="placementOrder"><b>' +
                        '<%__ "assessment-builder.gridded-response.decimal.placementorder" %></b></label>',
                    '<div class="uxf-field-wrapper">',
                        '<select class="uxf-delimpos-select"  id="placementOrder" ' +
                            '<% if (!isFixedDelim) { %>disabled<% } %>>',
                            '<% for (var i = 0; i < delimPosOptions.length; i++) { %>',
                                '<option value = "<%= i %>" <% if (delimPosValue === i) { %>selected<% } %>>' +
                                    '<%= delimPosOptions[i] %></option>',
                            '<% }; %>',
                        '</select>',
                    '</div>',
                    '<label for="plusminus"><b><%__ "assessment-builder.gridded-response.plusminus" %></b></label>',
                    '<div class="uxf-field-wrapper">',
                    '<select id="plusminus" class ="uxf-plusminus-select">',
                        '<option value = "false" <% if (!plusMinusValue) { %>selected<% } %>>none</option>',
                        '<option value = "true" <% if (plusMinusValue) { %>selected<% } %>>+/-</option>',
                    '</select>',
                    '</div>',
                '</fieldset>',
            '</form>'
        ].join('');

        editTemplate = [
            '<div class="uxf-add-question-dropdown"></div>',
            '<div class="uxf-question-container-box">',

                '<div class="uxf-left-panel">',
                    '<div class="uxf-question-number uxf-edit-question-number">',
                        '<%- position %>',
                    '</div>',
                '</div>',

                '<div class="uxf-right-panel uxf-gridded-response">',
                    '<div class="uxf-question-header uxf-question-edit-mode uxf-edit-question-header">',

                        '<div class="uxf-question-column uxf-question-body uxf-question-body-edit-mode">',
                            '<span class="uxf-question-edit-label">' +
                                '<%__ "assessment-builder.question.question" %>',
                            '</span>',
                            '<span class="uxf-field-validation-error"></span>',
                            '<div class="uxf-field-wrapper">',
                                '<div class="uxf-editor-preview question" tabindex="0">',
                                    '<%= text %>',
                                '</div>',
                            '</div>',
                            '<div class="uxf-clear"></div>',
                        '</div>',
                        '<div class="uxf-controlbar uxf-edit-controlbar"></div>',
                        '<div class="uxf-clear"></div>',
                     '</div>',
                    //Host app will populate this element with validation error messages
                    '<div class="uxf-notification-wrapper uxf-edit-notification-wrapper">',
                        '<div class="uxf-notification uxf-notification-error uxf-notification-message ' +
                            'uxf-question-notification uxf-edit-question-alert"></div>',
                    '</div>',

                    '<div class="uxf-answers uxf-right-gr-edit">',
                        '<div class="uxf-response-answer-label">',
                            '<%__ "assessment-builder.response.answer" %>',
                        '</div>',
                        '<div aria-hidden="true" role="presentation" class="uxf-griddedresponse-instructions">' +
                            '<%__ "gridded-response.instructions" %>',
                        '</div>',
                        '<div class="uxf-response-list uxf-response-list-edit-mode uxf-gr-edit-grid"></div>',
                        '<div class="uxf-answers-controls"></div>',
                        '<div class="uxf-grid-form">', layoutTemplate, '</div>',
                    '</div>',
                    '<div class="uxf-clear"></div>',

                    '<% if (includeSkills) { %>',
                        '<div class="uxf-skill-container"></div>',
                    '<% } %>',
                '</div>',
            '</div>'
        ].join('');

        // this view it of type CollectionView so that calling render on this view will also render the
        //right hand side grid (i.e. the child view)
        View = CollectionView.extend({
            //tagName: 'div',
            className: 'uxf-question-container',
            responseModel: null,

            options: {
                collectionName: 'responses',
                containerSelector: 'responseList',
                viewClass: ResponseProxyView,
                viewName: 'ResponseProxyView',
                template: editTemplate,
                delimChar: '.',
                delimPadChar: '#',
                delimOptions: [
                    { value: 'none', label: 'assessment-builder.gridded-response.decimal.none' },
                    { value: 'floating', label: 'assessment-builder.gridded-response.decimal.floating' },
                    { value: 'fixed', label: 'assessment-builder.gridded-response.decimal.fixed' }
                ],
                includeSkills: true
            },
            templates: {
                edit: editTemplate
            },

            classes: {
                responses: 'uxf-response-list'
            },
            events: {
                'change .uxf-box-select': '_boxesChanged',
                'change .uxf-delim-select': '_delimChanged',
                'change .uxf-delimpos-select': '_delimPosChanged',
                'change .uxf-plusminus-select': '_plusMinusChanged'
            },

            selectors: {
                skillList: '.uxf-skill-container',
                responseList: '.uxf-response-list',
                boxesSelect:'.uxf-box-select',
                delimSelect:'.uxf-delim-select',
                delimPosSelect:'.uxf-delimpos-select',
                plusMinusSelect:'.uxf-plusminus-select'
            },

            initialize: function() {
                this.responseModel = this.model.get('responses').models[0];
            },

            _boxesChanged: function(e) {
                // save the question text
                this.options.destroyEditor(false);
                var fieldVal = parseInt($(e.currentTarget).val(), 10),
                    modelUpdates = {
                        boxes: fieldVal,
                        correctVal: ''
                    };

                if (this._isFixedDelim()) {
                    modelUpdates.delimPosition = 0;
                }

                this.responseModel.set(modelUpdates);
                this._updateLayoutForBoxChange();
            },

            _delimChanged: function(e) {
                // save the question text
                this.options.destroyEditor(false);
                var fieldVal = $(e.currentTarget).val(),
                    delim,
                    delimPos;

                if (fieldVal === 'none') {
                    delim = '';
                    delimPos = 0;
                } else if (fieldVal === 'floating') {
                    delim = '.';
                    delimPos = -1;
                } else if (fieldVal === 'fixed') {
                    delim = '.';
                    delimPos = 0;
                }

                this.responseModel.set({
                    delim: delim,
                    delimPosition: delimPos,
                    correctVal: ''
                });

                this._updateLayoutForDecimalType();
            },

            _delimPosChanged: function(e) {
                // save the question text
                this.options.destroyEditor(false);
                var fieldVal = parseInt($(e.currentTarget).val(), 10);

                this.responseModel.set({
                    delimPosition: fieldVal,
                    correctVal: ''
                });
            },

            _plusMinusChanged: function(e) {
                // save the question text
                this.options.destroyEditor(false);
                var fieldVal = ($(e.currentTarget).val() === 'true');

                this.responseModel.set({
                    plusMinus: fieldVal,
                    correctVal: ''
                });
            },

            _isFixedDelim: function() {
                return (this._getDelimType() === 'fixed');
            },

            _getDelimType: function() {
                return (!this.responseModel.get('delim') ? 'none' :
                            (this.responseModel.get('delimPosition') === -1 ? 'floating' : 'fixed')
                       );
            },

            cancelEdit: function() {
                var cancelEdit = true;
                this.options.destroyEditor(cancelEdit);
                // https://github.com/derickbailey/backbone.memento
                // rollback to the first store point
                this.responseModel.restart();
            },

            closeAllEditors: function() {
                var cancelEdit = false;
                this.options.destroyEditor(cancelEdit);
            },

            _getChildView: function() {
                var childView;

                // there will be only one view in _viewMap
                _.each(this._viewMap, function(view) {
                    childView = view;
                });

                return childView;
            },

            /**
             * @return true if valid, false otherwise
             */
            validateFields: function() {
                // first do the standard question model validation (i.e., blank question) - if
                // there's an error, triggerValidation() triggers the necessary model events and
                // returns false
                if (!this.model.triggerValidation()) {
                    return false;
                }
                return true;
            },

            enterEditMode: function() {
                EventBus.trigger('assessment-builder:question:enterEdit', this.$el);
                $('.uxf-assessment-builder-header, .uxf-add-question-dropdown, .uxf-view-mode').addClass('disabled');
                // https://github.com/derickbailey/backbone.memento
                // take a snap shot of the current state of model object that can be restored when 'cancel' is called
                this.responseModel.flush().store();
            },

            leaveEditMode: function() {
                EventBus.trigger('assessment-builder:question:leaveEdit', this.$el);
            },

            /**
             * Set edit mode for this view.  Will fire 'enterEditMode' and 'leaveEditMode'
             * events so that other views can update themselves correctly.
             *
             * @param mode boolean value - true == editMode, false == viewMode
             */
            setEditMode: function(mode) {
                this.options.editMode = mode;
                _.each(this._viewMap, function(view) {
                    if (view && view.setEditMode) {
                        view.setEditMode(mode, {
                            silent: true
                        });
                    }
                });
                this.render();
            },

            getEditMode: function() {
                return this.options.editMode;
            },

            _createView: function(model) {
                return CollectionView.prototype._createView.apply(this, [model, {
                    griddedResponseViewClass: GriddedResponseView,
                    getGriddedResponseViewOptions: _.bind(this._getGriddedResponseViewOptions, this)
                }]);
            },

            _getGriddedResponseViewOptions: function(model) {
                return {
                    model: model,
                    editMode: true
                };
            },
            /**
             * Pick the appropriate template (default or edit) based on the edit mode.
             *
             * @param template default template function
             * @param model the model
             * @param classes the list of classes
             * @protected
             */
            _renderTemplate: function(template, model, classes) {
                // data needed by the template
                var renderData = {
                    boxesValue: this.responseModel.get('boxes'),
                    delimValue: this._getDelimType(),
                    isFixedDelim: this._isFixedDelim(),
                    delimOptions: this.options.delimOptions,
                    delimPosValue: this.responseModel.get('delimPosition'),
                    delimPosOptions: this._getDelimPosOption(),
                    plusMinusValue: this.responseModel.get('plusMinus'),
                    includeSkills: this.options.includeSkills,
                    position: this.model.newPosition || this.model.get('position')
                };

                this.$el.removeClass('uxf-view-mode').addClass('uxf-edit-mode');
                CollectionView.prototype._renderTemplate.call(this, template, model, renderData);
                this.options.postRenderViewType();
            },

            render: function() {
                CollectionView.prototype.render.call(this);
                this.setElement(this.el);
                return this;
            },

            _updateLayoutForDecimalType: function() {
                var delimPosSelect;
                delimPosSelect = this.locate('delimPosSelect');
                if (this._isFixedDelim()) {
                    delimPosSelect.removeAttr('disabled');
                } else {
                    delimPosSelect.attr('disabled', 'disabled');
                }
                // select the first option by default
                delimPosSelect.find('option:nth-child(1)').attr('selected', true);
            },

            _updateLayoutForBoxChange: function() {
                var delimPosSelect, delimPosOptions;

                delimPosOptions = this._getDelimPosOption();
                delimPosSelect = this.locate('delimPosSelect');
                // remove all the options in the select box
                delimPosSelect.find('option').remove();
                _.each(delimPosOptions, function(value, indx) {
                    delimPosSelect.append($('<option/>', {
                        value: indx,
                        text: value
                    }));
                });
                // select the first option by default
                delimPosSelect.find('option:nth-child(1)').attr('selected', true);
            },

            _getDelimPosOption: function() {
               var boxes = this.responseModel.get('boxes'),
               delimPosOptions = [], i = 0;

               // create delimPosOptions as an array like ['###.', '##.#', #.##'] (for boxes = 3)
               for (i = 0; i < boxes; i++) {
                   delimPosOptions.push(this.options.delimChar.pad(this.options.delimPadChar, boxes - i, i));
               }
               return delimPosOptions;
           },

            onDestroy: function() {
                // TODO: Does this get in the way of other cleanup code?
                this.responseModel = null;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.GriddedResponseView',
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.Common.AbstractView', 'debug'],
    initFunc: function($, Backbone, _, AbstractView, debug) {
        'use strict';

        var View,
            template =
                '<div class="uxf-answer">' +
                    '<span class="uxf-field-validation-error"></span>' +
                    '<div class="uxf-response-content"></div>' +
                '</div>';

        View = AbstractView.extend({
            tagName: 'div',
            className: 'uxf-response',

            templates: {
                view: template
            },

            options: {
                editMode: false
            },

            events: {
            },

            selectors: {
                responseContainer:'.uxf-response-content',
                answerError: '.uxf-answer .uxf-field-validation-error'
            },
            _regex: {
                plusMinusAndOrDecimalOnly : /(^[+\-]?\s*\.*$)|(\.\d*\.)/
            },
            initialize: function() {
                if (!this.model) {
                    throw 'ResponseView must be initialized with a model';
                }

                this.listen(this.model, 'change', this._modelChanged, this);
                this.listen(this.model, 'validation', this._showValidation, this);
            },

            _showValidation: function(e) {
                if (this.options.editMode && e) {
                    this.locate('answerError').css('visibility', (e.isGridValid ? 'hidden' : 'visible'));
                }
            },

            render: function() {
                var gridConfig = _.extend({}, this.model.toJSON(), {rawValue: this.model.get('correctVal'),
                                immutable: !this.options.editMode});

                this.$el.empty();
                this.$el.html(this.templates.view());

                this.locate('responseContainer').griddedResponse(gridConfig);

                if (this.options.editMode) {
                    // register a callback with the response model to be invoked
                    // when the validate on the response model is called
                    // the callback function will in turn invoke the validate
                    // on the gridded response widget available to this view
                    this.model.setViewValidator(this, this.validateCorrectValue);
                }

                return this;
            },

            _destroyWidget: function() {
                var widget = this.locate('responseContainer');

                if (widget) {
                    widget.remove();
                }
            },

            _modelChanged: function() {
                this._destroyWidget();

                this.render();
            },

            onDestroy: function() {
                this._destroyWidget();
            },

            // return error message or '' based on gridded response widget validation
            validateCorrectValue: function() {
                var msg = '',
                    widget = this.locate('responseContainer'),
                    correctVal;

                try {
                    // getValue() throws exception for the likes of mismatched text and bubble values
                    correctVal = widget.griddedResponse('getValue');

                    if (correctVal.trim() === '') {
                        return 'assessment-builder.validation.question.griddedresponse.correct-answer.missing';
                    }

                    if (this._regex.plusMinusAndOrDecimalOnly.test(correctVal.trim())) {

                        // case when
                        // 1. Decimal type "fixed" and no bubble is selected and no text is entered
                        // 2. Decimal type "floating" and select a bubble for "decimal point" and enter text as "."
                        // 3. Only plus/minus is selected
                        // 4. Decimal type "floating" and more than one decimal column is selected
                        // 5. Value with plus/minus and decimal point(s)

                        return 'assessment-builder.validation.question.griddedresponse.correct-answer.missing';
                    }

                    this.model.set('correctVal', correctVal);
                    // validate() returns '' or an error message for the likes of missing columns
                    //
                    // note: don't use cached widget because it may have been changed by the
                    // call to correctVal
                    msg = this.locate('responseContainer').griddedResponse('validate');
                } catch (error) {
                    msg = error;
                }
                switch (msg) {
                    // TODO - the grid widget should not return an error key that has 'player' in it
                    case 'assessment-player.question.griddedresponse.missing':
                        msg = 'assessment-builder.validation.question.griddedresponse.correct-answer.missing';
                    break;
                    case 'assessment-player.question.griddedresponse.mismatch':
                        msg = 'assessment-builder.validation.question.griddedresponse.mismatch';
                    break;
                    case 'assessment-player.question.griddedresponse.missingcolumn':
                        msg = 'assessment-builder.validation.question.griddedresponse.missingcolumn';
                    break;
                }
                return msg;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});

;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.InstructionBarView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.AssessmentBuilder.Templates',
        'UXF.Common.AbstractView',
        'UXF.Common.EventBus'
    ],
    initFunc: function($, Backbone, _, debug, Templates, AbstractView, EventBus) {
        'use strict';

        var View,
            requestExitBuilder = function(view) {
                EventBus.trigger('assessment-builder:publish-event', {
                    event: 'assessment-builder:exit',
                    data: view
                });
            };

        View = AbstractView.extend({
            templates: {
                body: Templates['instruction-bar-view']
            },
            selectors: {
                instruction: '.uxf-instruction-text',
                cancelButton: '.uxf-instruction-cancel-button',
                doneButton: '.uxf-instruction-done-button'
            },
            localize: {
                edit: 'assessment-builder.instruction-bar.text.edit',
                reorder: 'assessment-builder.instruction-bar.text.reorder'
            },
            events: {
                'click .uxf-instruction-cancel-button': '_cancelButtonClicked',
                'click .uxf-instruction-done-button': '_doneButtonClicked'
            },
            initialize: function() {
                if (!this.model) {
                    throw 'InstructionBarView must be initialized with a model';
                }
                EventBus.on('assessment-builder:question:enterEdit', this._enterEdit, this);
                EventBus.on('assessment-builder:question:leaveEdit', this._leaveEdit, this);
            },
            render: function() {
                this.$el.empty();
                this.$el.html(this.templates.body());

                if (this.options.showText) {
                    var instructionEl = this.locate('instruction');

                    if (this.options.currentMode === 'edit') {
                        instructionEl.text(this.localize.edit());
                    } else if (this.options.currentMode === 'reorder') {
                        instructionEl.text(this.localize.reorder());
                    }
                }

                if (this.options.currentMode === 'reorder') {
                    this.locate('cancelButton').hide();
                }

                return this;
            },

            _cancelButtonClicked: function() {
                requestExitBuilder('cancel');
            },

            _doneButtonClicked: function() {
                if (this.options.currentMode === 'reorder') {
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'navigation',
                        data: 'edit'
                    });
                } else {
                    requestExitBuilder(this);
                }
            },

            _enterEdit: function() {
                this.locate('doneButton').prop('disabled', true);
            },

            _leaveEdit: function() {
                this.locate('doneButton').prop('disabled', false);
            },

            onDestroy: function() {
                this.$el.empty();
                EventBus.off('assessment-builder:question:enterEdit', this._enterEdit, this);
                EventBus.off('assessment-builder:question:leaveEdit', this._leaveEdit, this);
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.InstructionView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.AbstractView'
    ],
    initFunc: function($, Backbone, _, debug, AbstractView) {
        'use strict';

        var View;

        View = AbstractView.extend({
            templates: {
                body: '<%__ "assessment-builder.accordion.instruction" %>'
            },
            selectors: {
                instruction: '.uxf-accordionInstruction'
            },
            initialize: function() {
                if (!this.model) {
                    this.model = {};
                }
            },
            render: function() {
                this.$el.empty();
                this.$el.html(this.templates.body());

                return this;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.PrintView',
    dependencies: ['$.fn.griddedResponse'],
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.Common.AbstractView'],
    initFunc: function($, Backbone, _, AbstractView) {
        'use strict';

        var View, template;

        template = [
            '<div class="uxf-assessment-title-print"><%= assetTitle %></div>',
            '<div class="uxf-assessment-builder-content">',
                '<div class="uxf-question-list">',
                    '<% _.each(questions.toJSON(), function(question) { %>',
                        '<div class="uxf-question-container">',
                            '<div class="uxf-question-container-box">',
                                '<div class="uxf-question-header">',
                                    '<div class="uxf-question-number">',
                                        '<%- question.position %>',
                                    '</div>',
                                '</div>',
                                '<div class="uxf-question-body">',
                                    '<%= question.text %>',
                                '</div>',
                                '<div class="uxf-response-list">',
                                    '<% if (question.questionType === "gridded-response") { %>',
                                        '<div class="uxf-print-gr" data-question-id="<%= question.id %>" ' +
                                            'data-response-id="<%= question.responses.at(0).id %>"></div>',
                                    '<% } else { %>',
                                        '<% _.each(question.responses.toJSON(), function(response) { %>',
                                            '<div class="uxf-response">',
                                                '<% if (answerKey && response.score > 0) { %>',
                                                    '<img class="uxf-response-score uxf-response-correct" ' +
                                                        'src="<%= correctResponseImgUrl %>">',
                                                '<% } %>',
                                                '<div class="uxf-response-content">',
                                                    '<div class="uxf-answer">',
                                                        '<span class="uxf-response-label">',
                                                            '<%__ "assessment-builder.response.label-format", ' +
                                                                '[ response.label ] %>',
                                                        '</span>',
                                                        '<div class="uxf-response-text"><%= response.text %></div>',
                                                    '</div>',
                                                '</div>',
                                            '</div>',
                                        '<% }); %>',
                                    '<% } %>',
                                '</div>',
                                '<div style="clear:both;"></div>',
                            '</div>',
                        '</div>',
                    '<% }); %>',
                '</div>',
            '</div>'
        ].join('');

        View = AbstractView.extend({
            options: {
                answerKey: false,
                correctResponseImgUrl: 'correct.jpg'
            },
            templates: {
                body: template
            },
            selectors: {
                questions: '.uxf-question-body',
                responses: '.uxf-response',
                correctResponses: '.uxf-response-score',
                griddedResponseContainers: '.uxf-print-gr',
                grTextInputs: '.uxf-print-gr input[type = "text"]'
            },

            render: function() {
                var self = this;

                this.$el.html(this.templates.body(_.extend(this.model.toJSON(), {
                    answerKey: this.options.answerKey,
                    correctResponseImgUrl: this.options.correctResponseImgUrl
                })));

                $.each(this.locate('griddedResponseContainers'), function(idx, el) {
                    var qid = $(el).data('questionId'),
                        rid = $(el).data('responseId'),
                        model = self.model.get('questions').get(qid),
                        respModel = model.get('responses').get(rid),
                        opts = {
                            immutable: true,
                            boxes: respModel.get('boxes'),
                            delim: respModel.get('delim'),
                            delimPosition: respModel.get('delimPosition'),
                            currencySymbol: respModel.get('currencySymbol'),
                            plusMinus: respModel.get('plusMinus')
                        };

                    if (self.options.answerKey) {
                        opts.rawValue = respModel.get('correctVal');
                    }

                    $(el).griddedResponse(opts);
                    if (self.options.answerKey) {
                        $(el).addClass('uxf-gr-answer-key');
                    }
                });

                return this;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.QuestionBankItemView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.AbstractView',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Services.Builder'
    ],
    initFunc: function($, Backbone, _, debug, AbstractView, Templates, builderService) {
        'use strict';

        var View;

        View = AbstractView.extend({
            options: {
                defaultThumbnailURL: null
            },
            templates: {
                body: Templates['question-bank-item-view']
            },
            selectors:{
                checkbox: 'input[type="checkbox"]',
                grCount: '.uxf-qbank-count-gr',
                mcCount: '.uxf-qbank-count-mc',
                title: '.uxf-qbank-details .uxf-qbank-title',
                description: '.uxf-qbank-details .uxf-qbank-description',
                row: '.uxf-item-row',
                success: '.uxf-qbank-success',
                details: '.uxf-qbank-details'
            },
            events: {
                'click': '_updateSelection',
                'click input[type="checkbox"]': '_checkboxClicked'
            },

            initialize: function() {
                if (!this.model) {
                    throw new Error('QuestionBankItemView must be initialized with a model');
                }

                this.listen(this.model, 'change:isChecked', this._updateChecked, this);
            },

            showSuccessIndicator: function() {
                var promise, self = this;

                this.locate('row').addClass('uxf-success uxf-qbank-imported');
                this.locate('checkbox').attr('disabled', 'disabled');

                this.locate('success').show();
                this.locate('details').hide();

                /*
                promise = builderService().successAnimation(this.locate('success'), this.locate('details'));
                promise.then(function() {
                    self.locate('row').removeClass('uxf-success');
                });
                */
            },

            render: function() {
                var renderOpts = this.model.toJSON();

                if (!renderOpts.thumbnailUrl) {
                    renderOpts.thumbnailUrl = this.options.defaultThumbnailURL;
                }

                this.$el.empty();
                this.$el.html(this.templates.body(renderOpts));

                this.locate('success').hide();

                return this;
            },

            onDestroy: function() {
                this.unlisten(this.model, 'change:isChecked', this._updateChecked, this);
            },

            _checkboxClicked: function(e) {
                var checked = this.model.get('isChecked');

                if (e) {
                    e.stopPropagation();
                }

                if (this.model.get('isImported')) {
                    return false;
                }

                this.model.set('isChecked', !checked);
                return true;
            },

            _updateSelection: function(e) {
                if (this._checkboxClicked(e)) {
                    // if clicking on a line instead of a checkbox, post a message to save immediately...
                    this.trigger('save-question-banks');
                }
            },

            _updateChecked: function(model, val) {
                this.locate('checkbox').removeAttr('checked');
                this.locate('checkbox').prop('checked', false);
                this.locate('row').removeClass('uxf-selected');
                if (val) {
                    this.locate('checkbox').attr('checked', 'checked');
                    this.locate('checkbox').prop('checked', true);
                    this.locate('row').addClass('uxf-selected');
                }
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.QuestionBanksView',
    initArgs: [
        'jQuery',
        '_',
        'debug',
        'UXF.Common.CollectionView',
        'UXF.Common.AbstractView',
        'UXF.Common.EventBus',
        'UXF.Common.ButtonView',
        'UXF.Common.PagerView',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Services.Builder',
        'UXF.AssessmentBuilder.Views.QuestionBankItemView'
    ],
    initFunc: function($, _, debug, CollectionView, AbstractView, EventBus, ButtonView, PagerView,
                Templates, builderService,
        QuestionBankItemView) {
        'use strict';

        var View;

        View = CollectionView.extend({
            options: {
                template: Templates['question-banks'],
                containerSelector: 'list',
                collectionName: 'questionBanks',
                viewClass: QuestionBankItemView,
                viewName: 'QuestionBankItemView',
                questionBanksPerPage: 10,
                program: null,
                defaultThumbnailURL: null
            },
            selectors: {
                list: '.uxf-question-banks',
                pager: '.uxf-question-banks-pager',
                buttons: '.uxf-question-bank-buttons'
            },
            localize: {
                save: 'assessment-builder.question-banks.save'
            },

            initialize: function() {
                if (!this.model) {
                    throw new Error('QuestionBanksView must be initialized with a QuestionBanksModel');
                }

                if (!this.options.assessmentModel) {
                    throw new Error('QuestionBanksView must be initialize with an AssessmentModel');
                }

                this._setupPager();
                this._setupButtons();

                this._selectImported();
            },

            postRenderChildren: function() {
                var pagerEl, buttonsEl;

                pagerEl = this.locate('pager');
                this._pagerView.setElement(pagerEl);
                this._pagerView.render();

                buttonsEl = this.locate('buttons');
                buttonsEl.empty()
                    .append(this._saveButton.render().$el);
            },

            onChildViewCreated: function(view, options) {
                this.listen(view, 'save-question-banks', this._bankRowSelected, this);
            },

            onChildViewDestroyed: function(view) {
                this.unlisten(view, 'save-question-banks', this._bankRowSelected, this);
            },

            onDestroy: function() {
                this._destroyPager();
                this._destroyButtons();
                this.model = null;
            },

            _createView: function(model) {
                // call the super class method.
                return CollectionView.prototype._createView.apply(this, [model, {
                    defaultThumbnailURL: this.options.defaultThumbnailURL
                }]);
            },

            _setupPager: function() {
                var pages = PagerView.calculatePages(this.model.get('total'), this.options.questionBanksPerPage);

                this._pagerView = PagerView.newInstance(this, {});
                this._pagerView.setPageCount(pages);

                this.listen(this._pagerView, 'pager:change-page', this._pageChange, this);
            },

            _setupButtons: function() {
                this._saveButton = ButtonView.newInstance(this, {
                    label: this.localize.save(),
                    classes: 'uxf-qbanks-save'
                });

                this.listen(this._saveButton, 'click', this._saveClicked, this);
            },

            _destroyPager: function() {
                this.unlisten(this._pagerView, 'pager:change-page', this._pageChange, this);
                this._pagerView.destroy();
            },

            _destroyButtons: function() {
                this.unlisten(this._saveButton, 'click', this._saveClicked, this);
                this._saveButton.destroy();
            },

            _bankRowSelected: function() {
                var promise,
                    self = this,
                    checked = this._getNewIds();

                promise = this._saveQuestionBanks();
                promise.then(function() {
                    _.each(self._viewMap, function(view) {
                        var id = view.model.get('assessmentId');
                        if (_.contains(checked, id)) {
                            view.showSuccessIndicator();
                        }
                    });
                });
            },

            _pageChange: function(page) {
                var self = this,
                    isNativeAssessment = this.model.get('nativeAssessment'),
                    promise;

                promise = this._saveQuestionBanks();
                promise.then(function() {
                    var fetchPagePromise = builderService().listQuestionBanks(
                        self.options.program, page, self.options.questionBanksPerPage, isNativeAssessment);
                    fetchPagePromise.then(function(data) {
                        self.model.set(data);
                        self._selectImported();
                    });
                });
            },

            _saveClicked: function() {
                var self = this,
                    promise = this._saveQuestionBanks();
                promise.then(function() {
                    self.options.assessmentModel.setInsertPosition(null);
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'navigation',
                        data: 'edit'
                    });
                });
            },

            _selectImported: function() {
                var ids = this.options.assessmentModel.get('sourceQuestionBankIds');
                this.model.selectImported(ids);
            },

            _getUpdatedIds: function() {
                var current = this.options.assessmentModel.get('sourceQuestionBankIds'),
                    ids = this.model.getCheckedIds();

                current = current || [];
                ids = ids || [];

                return _.union(current, ids);
            },

            _getNewIds: function() {
                var current, checked;

                current = this.options.assessmentModel.get('sourceQuestionBankIds');
                checked = this.model.getCheckedIds();

                current = current || [];
                checked = checked || [];

                // figure out which items are checked, but not part of current question bank set.
                return _.difference(checked, current);
            },

            _saveQuestionBanks: function() {
                var questionBankIds, assessmentId, position, promise, self = this;

                // no changes, just return a resolved promise...
                if (this._getNewIds().length === 0) {
                    return $.Deferred().resolve();
                }

                position = this.options.assessmentModel.getInsertPosition();
                if (!_.isNumber(position)) {
                    position = this.options.assessmentModel.get('questions').size() + 1;
                }

                questionBankIds = this._getUpdatedIds();
                assessmentId = this.options.assessmentModel.get('id');

                promise = builderService().updateQuestionBanks(assessmentId, questionBankIds, position);
                return promise.then(function(assess) {
                    self.options.assessmentModel.set(assess);
                    self.model.selectImported(assess.sourceQuestionBankIds);

                    return assess;
                });
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.QuestionCollectionView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.CollectionView',
        'UXF.Common.QuickLinksView',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Views.QuestionProxyView',
        'UXF.AssessmentBuilder.Views.DropdownView',
        'UXF.AssessmentBuilder.Services.Builder',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Constants'
    ],
    initFunc: function($, Backbone, _, debug, CollectionView, QuickLinksView, EventBus, QuestionProxyView, DropdownView,
        builderService, Templates, Constants) {
        'use strict';

        var View, CONSTANT = new Constants();

        View = CollectionView.extend({
            _newQuestionPosition: 0, // 1-based position of new question being added
            options: {
                template: Templates['question-collection-view'],
                collectionName: 'questions',
                viewClass: QuestionProxyView,
                viewName: 'QuestionView',
                containerSelector: 'questions',
                assessmentId: null,
                restPath: null,
                useDropdownForAddQuestion: false,
                includeSkills: true,
                ckeditorSkin: undefined
            },
            selectors: {
                dropdown: '.uxf-add-question-dropdown',
                questions: '.uxf-question-list',
                viewMode: 'viewMode',
                zeroStateContainer: '.uxf-questions-zeroState',
                zeroStateContainerSel: '.uxf-questions-zeroState a',
                dropdownMenu: '.uxf-quick-link-dropdown .dropdown .uxf-dropdownmenu',
                expanderDetailContainer: '.expanderDetails',
                accordionContainer: '.uxf-toggle-show-question-quicklink a',
                questionQuicklinks: '.uxf-question-quicklinks a',
                zeroStateMessageAddAllQuestionTypes: function() {
                    var selector = [this.selectors.zeroStateContainer, '.uxf-add-question.all-types'].join(' ');
                    return this.$el.find(selector);
                },
                zeroStateMessageAddRegularQuestions: function() {
                    var selector = [this.selectors.zeroStateContainer, '.uxf-add-question.no-qb'].join(' ');
                    return this.$el.find(selector);
                },
                zeroStateMessageAddQuestionBankOnly: function() {
                    var selector = [this.selectors.zeroStateContainer, '.uxf-add-question.qb-only'].join(' ');
                    return this.$el.find(selector);
                },
                addItemFromBankLink: function() {
                    return this.$el.find('.uxf-add-items-from-bank');
                },
                addItemFromBankLinkSel: function() {
                    return this.$el.find('.uxf-add-items-from-bank a');
                },
                addFromBankMenuItem: function() {
                    return this.$el.find('.uxf-add-question-dropdown [data-event-id="add-question-bank"]').parent();
                },
                // testing only selectors
                // TODO: determine whether we want just a comment, and naming convention,
                //    a separate testSelectors, or other method for solving this.
                firstAddMCQuestionLink: function() {
                    return this.$el.find('.uxf-quick-link-dropdown [data-event-id=add-question-mc]').first();
                },
                lastAddQuestionLink: function() {
                    return this.$el.find('.icon-plus').last().parent();
                },
                lastAddMCQuestionLink: function() {
                    return this.$el.find('.uxf-quick-link-dropdown [data-event-id=add-question-mc]').last();
                }
            },
            events: {
                'click .uxf-questions-zeroState [data-add-question-type="mc"]': '_addQuestionMC',
                'click .uxf-questions-zeroState [data-add-question-type="gr"]': '_addQuestionGR',
                'click .uxf-questions-zeroState [data-add-question-type="bank"]': '_putNewQuestionsListToDB',
                'click .uxf-questions-zeroState [data-add-question-type="bank-nonNative"]':
                    '_putNewQuestionsListToDB'
            },

            initialize: function() {
                if (!this.model) {
                    throw 'QuestionCollection is required';
                }

                if (!_.isUndefined(this.model.get('questions'))) {
                    var questions = this.model.get('questions');
                    questions.models = _.filter(questions.models, function(model) {
                        return model.newPosition >= 0;
                    });
                    _.each(questions.models, function(model) {
                        model.set('position', model.newPosition);
                    });

                    this.model.set('questions', questions);
                }

                this._addQuestionView = DropdownView.newInstance(this, {
                    topDropdown: true,
                    dropdownMode: this.options.useDropdownForAddQuestion,
                    links: [{
                        label: 'assessment-builder.question.add',
                        className: 'icon-plus',
                        event: 'add-question',
                        sub: [{
                            label: 'assessment-builder.question.addMC',
                            className: '',
                            event: 'add-question-mc'
                        }, {
                            label: 'assessment-builder.question.addGR',
                            className: '',
                            event: 'add-question-gr'
                        }, {
                            label: 'assessment-builder.question.addQB',
                            className: '',
                            event: 'add-question-bank'
                        }]
                    }]
                });

                this._addQuestionFromBankLink = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.addQB',
                        className: 'icon-plus',
                        event: 'add-question-bank-nonNative'
                    }]
                });

                this._editingView = null;
                this.listen(this._addQuestionView, 'add-question', this._addQuestionMC, this);
                this.listen(this._addQuestionView, 'add-question-mc', this._addQuestionMC, this);
                this.listen(this._addQuestionView, 'add-question-gr', this._addQuestionGR, this);
                this.listen(this._addQuestionView, 'add-question-bank', this._putNewQuestionsListToDB, this);
                this.listen(this._addQuestionFromBankLink, 'add-question-bank-nonNative',
                    this._putNewQuestionsListToDB, this);

                // flag set by the parent view to control if Edit, Add and Remove operations are allowed in this view.
                // ex1: do not allow add/edit/remove question if Title/Description is being edited
                // ex2: do not allow add/edit/remove if another question is being edited
                this._allowEdit = true;

                // initial value based on test type...
                this._setFeedbackSupported(!this._isTestType());

                // don't support question banks till I hear otherwise...
                this._enableQuestionBanks(false);

                if (!this.model.get('nativeAssessment')) {
                    this._sequence = this.model.get('sequence');
                    this._previewSession = this.model.get('previewSession');
                    this._questionsCount = this.getChildCollection().length;
                }

                EventBus.on('assessment-builder:question:save-success', this._questionSaved, this);
                EventBus.on('assessment-builder:feedback-supported', this._feedbackSupported, this);
                EventBus.on('assessment-builder:question-banks-enabled', this._enableQuestionBanks, this);
                EventBus.on('assessment-builder:header:enterEdit', this._enterEdit, this);
                EventBus.on('assessment-builder:header:leaveEdit', this._leaveEdit, this);
                EventBus.on('assessment-builder:update-new-questionList', this._putNewQuestionsListToDB, this);
                EventBus.on('assessment-builder:get-removedQuestions-pos', this._getRemovedQuestionPosition, this);
            },
            _enterEdit: function() {
                this.locate('questions').removeClass('enabled');
                this.locate('questionQuicklinks').removeClass('enabled');
                this.locate('questions').addClass('disabled');
                this.locate('questionQuicklinks').addClass('disabled');
                if (this.model.get('nativeAssessment') === true) {
                    this.locate('dropdownMenu').removeClass('enabled');
                    this.locate('dropdownMenu').addClass('disabled');
                } else {
                    this.locate('addItemFromBankLink').removeClass('enabled');
                    this.locate('addItemFromBankLink').addClass('disabled');
                    this.locate('addItemFromBankLinkSel').removeClass('enabled');
                    this.locate('addItemFromBankLinkSel').addClass('disabled');
                    this.locate('expanderDetailContainer').removeClass('enabled');
                    this.locate('expanderDetailContainer').addClass('disabled');
                    this.locate('accordionContainer').removeClass('enabled');
                    this.locate('accordionContainer').addClass('disabled');
                }
                if (this.model.get('questions').length === 0) {
                    this.locate('zeroStateContainer').removeClass('enabled');
                    this.locate('zeroStateContainerSel').removeClass('enabled');
                    this.locate('zeroStateContainer').addClass('disabled');
                    this.locate('zeroStateContainerSel').addClass('disabled');
                }
            },

            _leaveEdit: function() {
                this.locate('questions').removeClass('disabled');
                this.locate('questions').addClass('enabled');
                this.locate('questionQuicklinks').removeClass('disabled');
                this.locate('questionQuicklinks').addClass('enabled');
                if (this.model.get('nativeAssessment') === true) {
                    this.locate('dropdownMenu').removeClass('disabled');
                    this.locate('dropdownMenu').addClass('enabled');
                } else {
                    this.locate('addItemFromBankLink').removeClass('disabled');
                    this.locate('addItemFromBankLink').addClass('enabled');
                    this.locate('addItemFromBankLinkSel').removeClass('disabled');
                    this.locate('addItemFromBankLinkSel').addClass('enabled');
                    this.locate('expanderDetailContainer').removeClass('disabled');
                    this.locate('expanderDetailContainer').addClass('enabled');
                    this.locate('accordionContainer').removeClass('disabled');
                    this.locate('accordionContainer').addClass('enabled');
                }
                if (this.model.get('questions').length === 0) {
                    this.locate('zeroStateContainer').removeClass('disabled');
                    this.locate('zeroStateContainerSel').removeClass('disabled');
                }
            },

            _createView: function(model) {
                // call the super class method.
                return CollectionView.prototype._createView.apply(this, [model, {
                    showFeedback: this._showFeedback,
                    assessmentId: this.options.assessmentId,
                    restPath: this.options.restPath,
                    useDropdownForAddQuestion: this.options.useDropdownForAddQuestion,
                    includeSkills: this.options.includeSkills,
                    ckeditorSkin: this.options.ckeditorSkin,
                    sequence: this._sequence, //Pass it down the pipe
                    previewSession: this._previewSession,
                    isPaf: this._isPaf,
                    questionsCount: this._questionsCount
                }]);
            },

            onChildViewCreated: function(view, options) {
                this.listen(view, 'edit-mode-requested', this._editQuestion, this);
                this.listen(view, 'put-new-question', this._putNewQuestionsListToDB, this);
                this.listen(view, 'remove-success', this._removeQuestion, this);
                this.listen(view, 'undo-success', this._undoRemoveQuestion, this);
                this.listen(view, 'cancel-edit', this._cancelQuestionEdit, this);
                this.listen(view, 'add-question', this._addQuestionMC, this);
                this.listen(view, 'add-question-mc', this._addQuestionMC, this);
                this.listen(view, 'add-question-gr', this._addQuestionGR, this);

                // if adding a question - we go directly into edit mode
                if (options && options.autoEdit) {
                    this._editQuestion(view);
                }

                view.enableQuestionBanks(this._questionBanksEnabled);
            },

            onChildViewDestroyed: function(view) {
                // collection view will clean up after itself if this is not done since
                // listen was used, but no sense wasting memory.
                this.unlisten(view, 'edit-mode-requested', this._editQuestion, this);
                this.unlisten(view, 'put-new-question', this._putNewQuestionsListToDB, this);
                this.unlisten(view, 'remove-success', this._removeQuestion, this);
                this.unlisten(view, 'undo-success', this._undoRemoveQuestion, this);
                this.unlisten(view, 'cancel-edit', this._cancelQuestionEdit, this);
                this.unlisten(view, 'add-question', this._addQuestionMC, this);
                this.unlisten(view, 'add-question-mc', this._addQuestionMC, this);
                this.unlisten(view, 'add-question-gr', this._addQuestionGR, this);
            },

            commit: function(from) {
                var promises = [],
                    self = this;

                _.each(this._viewMap, function(view) {
                    promises.push(view.commit(from));
                });

                if (promises.length === 0) {
                    return $.Deferred().resolve();
                } else {
                    return $.when.apply($, promises);
                }
            },

            _renderTemplate: function(template, model, classes) {
                CollectionView.prototype._renderTemplate.call(this, template, model, {});

                if (this.model.get('nativeAssessment') === true) {
                    this.locate('addItemFromBankLink').hide();
                    this.locate('dropdown').empty();
                    this._addQuestionView.setElement(this.locate('dropdown'));
                    this._addQuestionView.render();
                } else {
                    this._addQuestionFromBankLink.setElement(this.locate('addItemFromBankLink'));
                    this._addQuestionFromBankLink.render();
                }

                this._enableQuestionBanks(this._questionBanksEnabled);
                this._adjustZeroState();
            },

            render: function() {
                CollectionView.prototype.render.call(this);
                this.setElement(this.el);
                return this;
            },

            postRenderChildren: function(collection) {
                this._adjustRemoveLinks();
            },

            _getNonNewChildren: function() {
                return _.filter(this.model.get('questions').models, function(question) {
                    return !question.isNew();
                });
            },

            _adjustRemoveLinks: function() {
                var showRemove = (this._getNonNewChildren().length >= 1);

                _.each(this._viewMap, function(view) {
                    view.showRemoveLink(showRemove);
                });
            },

            _adjustZeroState: function() {
                var show = this.model.get('questions').models.length > 0;

                if (show) {
                    this.locate('zeroStateContainer').hide();
                } else {
                    this.locate('zeroStateContainer').show();
                }
            },

            _questionSaved: function(question, event) {
                this._adjustRemoveLinks();

                this._adjustZeroState();

                if (this._editingView !== null && event) {
                    this._scrollToContainer(this._editingView.$el);
                }
            },

            _getListQuestionNewPosition: function() {
                var questionsList = this.model.get('questions').models;

                questionsList = _.filter(questionsList, function(model) {
                    return model.newPosition >= 0;
                });

                return questionsList;
            },

            _removeQuestion: function(question, updatedQuestionBankIds, view) {
                var questionsList;
                this.model.get('questions')._renumberQuestions();

                questionsList = this._getListQuestionNewPosition();

                if (questionsList.length <= 1) {
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'builder-question:hideReorder:success',
                        data: 'success'
                    });
                }

                if (questionsList.length < 1) {
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'builder-question:hidePrintButton:success',
                        data: 'success'
                    });

                }
                this.render();
            },

            _undoRemoveQuestion: function() {
                var questionsList;
                this.model.get('questions')._renumberQuestions();

                questionsList = this._getListQuestionNewPosition();

                if (questionsList.length > 1) {
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'builder-question:unhideReorder:success',
                        data: 'success'
                    });
                }

                if (questionsList.length > 0) {
                    EventBus.trigger('assessment-builder:publish-event', {
                        event: 'builder-question:showPrintButton:success',
                        data: 'success'
                    });
                }

                this.render();
            },

            _cancelQuestionEdit: function(data, event) {
                var scrollToAddQuestion;

                this.trigger('edit-cancelled');

                // when canceling edit for a new question, we want to remove the new question
                // and scroll to the "add question" link that had been clicked to add it
                if (data.isNew()) {
                    // first get the "add question" link first - if the position of the new question = 1,
                    // we'll scroll to the "add question" link above the question list
                    if (data.get('position') === this.model.get('questions').size()) {
                        scrollToAddQuestion = this.locate('lastAddQuestionLink');
                        // otherwise we'll scroll to the "add question" link for the previous question
                    } else {
                        scrollToAddQuestion = this.locate('dropdown').eq(data.get('position'));
                    }

                    // adjust the _newQuestionPosition if we're removing a question that comes before it
                    if (this._newQuestionPosition > data.get('position')) {
                        this._newQuestionPosition = this._newQuestionPosition - 1;
                    }

                    // now remove the new question
                    this.model.get('questions').remove(data);
                }

                this._adjustRemoveLinks();
                this._adjustZeroState();

                /*
                 * DE19251 - canceling a question edit should scroll the window to the beginning of the question
                 * Note: only scrolls if event is defined -- ie. if the cancel button was clicked.
                 */
                if (this._editingView !== null && event) {
                    if (scrollToAddQuestion) {
                        this._scrollToContainer(scrollToAddQuestion);
                    } else {
                        this._scrollToContainer(this._editingView.$el);
                    }
                }

                this.render();
            },

            /**
             * Sets the flag that controls allowing add/edit/remove of a question. Set by the parent view
             */
            setAllowEdit: function(allowEdit) {
                this._allowEdit = allowEdit;
            },

            /**
             * This function determines if any new add/edit/remove request will be allowed
             */
            _getAllowEdit: function() {
                return this._allowEdit;
            },

            /**
             * Function to be used by widget to inquire of the state of editing.
             */
            isEditInProcess: function() {
                return (false === this._getAllowEdit());
            },

            _editQuestion: function(view) {
                var self = this,
                    promise;

                promise = builderService().execute('commitChanges', view);
                promise.then(function(scrollTo) {
                    self._editingView = view;
                    self._editingView.setEditMode(true);
                    builderService().scheduleScrollTo(view);
                });
            },

            _addQuestion: function(event, view, type) {
                var self, promise;

                // Each question view has an "add question" link - clicking these links passes
                // the corresponding question view and the new question should be placed in that question's
                // position (i.e., pushing the existing question down one position). There is also an extra
                // "floating" "add question" link below all questions - clicking this link does not pass
                // a question view  and the new question should be appended in last position.
                this._newQuestionPosition = (view && view.model ? view.model.get('position') :
                    this.model.get('questions').size() + 1);

                self = this;
                // pass null as view since we don't want to exclude current view from dirty checking and
                // we don't need to scroll there (handled below)
                promise = builderService().execute('commitChanges', null);
                promise.then(function() {
                    var opts = {
                        position: self._newQuestionPosition - 1,
                        autoEdit: true,
                        questionType: type
                    };

                    self.model.get('questions').addNewQuestion(opts);
                    self._scrollToEditModeQuestion();

                    self._adjustZeroState();
                });

                this.render();
                $('.uxf-add-question-dropdown').addClass('disabled');
                return promise;

            },

            _addQuestionMC: function(e, view) {
                var $this = $(e.currentTarget);
                if ($this.is('.disabled, :disabled')) {
                    e.stopPropagation();
                } else {
                    this._addQuestion(e, view, 'multiple-choice');
                }
            },

            _addQuestionGR: function(e, view) {
                var $this = $(e.currentTarget);
                if ($this.is('.disabled, :disabled')) {
                    e.stopPropagation();
                } else {
                    this._addQuestion(e, view, 'gridded-response');
                }
            },

            _addQuestionFromBank: function(e, position, view) {
                var promise, self = this, $this = $(e.currentTarget);

                if (_.isUndefined(position)) {
                    //NaN if user click on zero state/last link
                    position = this._getNewPosition(this.model.get('questions')._lastQuestionCount) + 1;
                } else if (_.isNumber(position)) {
                    position = this._getNewPosition(position - 1) + 1;

                }

                if ($this.is('.disabled, :disabled')) {
                    e.stopPropagation();
                } else {
                    promise = builderService().execute('commitChanges', null);
                    promise.then(function() {
                        self.model.setInsertPosition(position || null);
                        EventBus.trigger('assessment-builder:publish-event', {
                            event: 'navigation',
                            data: 'questionBanks'
                        });
                    });
                }
            },

            _addQuestionFromBankNonNative: function(e, position, view) {
                var promise,
                    self = this,
                    questionInsertPosition,
                    $this = $(e.currentTarget);

                if (!_.isNumber(position)) {
                    //NaN if user click on zero state/last link
                    position = this._getNewPosition(this._questionsCount) + 1;
                } else {
                    position = this._getNewPosition(position - 1) + 1;

                }
                questionInsertPosition = position;

                if ($this.is('.disabled, :disabled')) {
                    e.stopPropagation();
                } else {
                    promise = builderService().execute('commitChanges', null);
                    promise.then(function() {
                        EventBus.trigger('assessment-builder:publish-event', {
                            event: 'assessment-builder.navigate.addQuestionFromBank',
                            data: questionInsertPosition
                        });
                    });
                }

            },

            _getNewPosition: function(position) {
                var questionsList = this.model.get('questions').models,
                    i = 0,
                    oldPosition = position;

                for (i; i < questionsList.length; i++) {
                    if (questionsList[i].newPosition < 0 && i < oldPosition) {
                        position --;
                    }
                }

                return position;
            },

            _getRemovedQuestionPosition: function() {
                var questionsList = this.model.get('questions').models,
                    i = questionsList.length - 1  ,
                    stringList = '';

                for (i; i >= 0; i--) {
                    if (questionsList[i].newPosition < 0) {
                        stringList = i + ',' + stringList;
                    }
                }

                EventBus.trigger('assessment-builder:publish-event', {
                    event: 'builder-question:get:printList',
                    data: stringList
                });

            },

            _putNewQuestionsListToDB: function(e, position, view) {
                var questionsList = this._getListQuestionNewPosition(),
                    self = this,
                    $this = $(e.currentTarget),
                    isQuestionListChanged = false,
                    questionListLength = this.model.get('questions').length;

                if ($this.is('.disabled, :disabled')) {
                    e.stopPropagation();
                } else {
                    questionsList = builderService().getQuestionIdList(questionsList);

                    isQuestionListChanged = questionsList.length !== questionListLength;
                    return builderService()
                    .execute('commitChanges', this)
                    .then(function() {
                        builderService()
                        .putQuestionsInAssessment(self.options.assessmentId, questionsList, isQuestionListChanged)
                        .then(function(data) {

                            switch ((!_.isUndefined(e.attributes) &&
                                e.attributes.getNamedItem('data-event-id').textContent) ||
                                $this.attr('data-add-question-type')) {

                                case 'add-question-bank-nonNative':
                                    self._addQuestionFromBankNonNative(e, position, view);
                                break;
                                case 'bank-nonNative':
                                    self._addQuestionFromBankNonNative(e, position, view);
                                break;
                                case 'add-question-bank':
                                    self._addQuestionFromBank(e, position, view);
                                break;
                                case 'bank':
                                    self._addQuestionFromBank(e, position, view);
                                break;
                                default:
                                    debug.log('only doing the put assessment');
                            }

                            EventBus.trigger('assessment-builder:publish-event', {
                                event: 'builder-question:put:success',
                                data: 'success'
                            });
                        }, function(response) {
                            EventBus.trigger('assessment-builder:publish-event', {
                                event: 'builder-question:put:success',
                                data: 'fail'
                            });
                        });
                    });
                }

            },

            _scrollToEditModeQuestion: function() {
                this._scrollToContainer($('.uxf-question-container.uxf-edit-mode'));
            },

            _scrollToContainer: function(container) {
                EventBus.trigger('assessment-builder:schedule-scroll-to', container);
            },

            _isTestType: function() {
                var type = this.model.get('type');
                return (/test/i).test(type);
            },

            _setFeedbackSupported: function(supported) {
                this._showFeedback = supported;
            },

            _feedbackSupported: function(supported) {
                if (supported !== this._showFeedback) {
                    this._setFeedbackSupported(supported);
                    this.render();
                }
            },

            _showZeroStateAddQuestionsMessage: function() {
                var isNativeAssessment = this.model.get('nativeAssessment');

                if (!isNativeAssessment) {
                    this.locate('zeroStateMessageAddRegularQuestions').hide();
                    this.locate('zeroStateMessageAddAllQuestionTypes').hide();
                    this.locate('zeroStateMessageAddQuestionBankOnly').show();
                } else {
                    this.locate('zeroStateMessageAddQuestionBankOnly').hide();
                    if (this._questionBanksEnabled) {
                        this.locate('zeroStateMessageAddAllQuestionTypes').show();
                        this.locate('zeroStateMessageAddRegularQuestions').hide();
                    } else {
                        this.locate('zeroStateMessageAddAllQuestionTypes').hide();
                        this.locate('zeroStateMessageAddRegularQuestions').show();
                    }
                }
            },

            _enableQuestionBanks: function(enabled) {
                this._questionBanksEnabled = enabled;
                if (enabled && this.locate('addFromBankMenuItem')) {
                    this.locate('addFromBankMenuItem').show();
                } else {
                    this.locate('addFromBankMenuItem').hide();
                }

                if (enabled && this.locate('addItemFromBankLink')) {
                    this.locate('addItemFromBankLink').show();
                } else {
                    this.locate('addItemFromBankLink').hide();
                }

                // show the correct zero state message
                this._showZeroStateAddQuestionsMessage();

                _.each(this._viewMap, function(view) {
                    view.enableQuestionBanks(enabled);
                    view.enableAddQuestionFromBankLink(enabled);
                });
            },

            onDestroy: function() {
                EventBus.off('assessment-builder:question:save-success', this._questionSaved, this);
                EventBus.off('assessment-builder:feedback-supported', this._feedbackSupported, this);
                EventBus.off('assessment-builder:question-banks-enabled', this._enableQuestionBanks, this);
                EventBus.off('assessment-builder:header:enterEdit', this._enterEdit, this);
                EventBus.off('assessment-builder:header:leaveEdit', this._leaveEdit, this);
                EventBus.off('assessment-builder:update-new-questionList', this._putNewQuestionsListToDB, this);
                EventBus.off('assessment-builder:get-removedQuestions-pos', this._getRemovedQuestionPosition, this);

                if (this._addQuestionView) {
                    this._addQuestionView.destroy();
                    this._addQuestionView = null;
                }

                if (this._editingView) {
                    this._editingView.destroy();
                    this._editingView = null;
                }
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.QuestionProxyView',
    initArgs: [
        'jQuery',
        '_',
        'Backbone',
        'debug',
        'UXF.Common.i18n',
        'UXF.Common.AbstractView',
        'UXF.Common.QuickLinksView',
        'UXF.Common.ButtonView',
        'UXF.Common.ButtonGroupView',
        'UXF.AssessmentBuilder.Views.SkillCollectionView',
        'UXF.Common.BrowserUtils',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Views.QuestionView',
        'UXF.AssessmentBuilder.Views.GriddedResponseEditLayoutView',
        'UXF.AssessmentBuilder.Views.AccordionView',
        'UXF.AssessmentBuilder.Views.DropdownView',
        'UXF.AssessmentBuilder.DialogUtil',
        'UXF.AssessmentBuilder.Config',
        'UXF.Assessment.Services.AudioPlayerService',
        'UXF.AssessmentBuilder.Services.Builder',
        'UXF.AssessmentBuilder.Constants'
    ],
    initFunc: function($, _, Backbone, debug, i18n, AbstractView, QuickLinksView, ButtonView, ButtonGroupView,
        SkillCollectionView, browserUtils, EventBus, QuestionView, GriddedResponseEditLayoutView,
        AccordionView, DropdownView, DialogUtil, config, AudioPlayerService, builderService, Constants) {
        'use strict';

        var View, CONSTANT = new Constants();

        View = AbstractView.extend({
            options: {
                multichoiceViewClass: QuestionView,
                griddedResponseEditViewClass: GriddedResponseEditLayoutView,
                accordionViewClass: AccordionView,

                // the list of methods that need to be proxied
                multichoiceMethods: [],
                griddedResponseMethods: [],

                editMode: false,
                questionTextMax: 600,
                showFeedback: true,
                assessmentId: null,
                editorUpload: true,
                useDropdownForAddQuestion: false,
                includeSkills: true,
                ckeditorSkin: undefined
            },
            _currentView: undefined,
            _proxiedMethods: undefined,

            events: {
                'focus .uxf-question-body .uxf-editor-preview': '_editorPreviewFocused',
                'click .uxf-question-audio-player a:first': '_playAudio'
            },
            localize: {
                i18nCharacterMax: 'assessment-builder.question.characterMax',
                save: 'assessment-builder.question.save',
                cancel: 'assessment-builder.question.cancel'
            },
            classes: {
                editMode: 'uxf-question-edit-mode',
                viewMode: 'uxf-question-view-mode',
                questionHeader: 'uxf-question-header',
                questionNumber: 'uxf-question-number',
                questionQuickLinks: 'uxf-questions-quicklinks',
                dropdownAddQuestionLinks: 'uxf-add-question-dropdown',
                printQuestionNumber: 'uxf-print-question-number',
                questionNotification: 'uxf-question-notification',
                questionBody: 'uxf-question-body',
                questionContainer: 'uxf-question-container',
                quickLinks: 'uxf-question-quicklinks',
                characterCounter: 'uxf-character-counter',
                editorPreview: 'uxf-editor-preview'
            },
            selectors: {
                characterCounter: '.uxf-question-body .uxf-character-counter',
                questionQuickLinks: '.uxf-questions-quicklinks',
                quickLinks: '.uxf-question-quicklinks',
                questionAudioPlayer: '.uxf-question-audio-player',
                dropdown: '.uxf-add-question-dropdown',
                editButtons: '.uxf-controlbar',
                questionError: '.uxf-question-body-edit-mode .uxf-field-validation-error',
                errorMsgElSelector: 'div.uxf-question-notification',
                questionNumber: '.uxf-question-number',
                question: '.uxf-question-body',
                questionText: '.question',
                printQuestionNumber: '.uxf-question-body .uxf-print-question-number',
                questionNotification: '.uxf-question-notification',
                addFromBankMenuItem: function() {
                    return this.$el.find('.uxf-add-question-dropdown [data-event-id="add-question-bank"]').parent();
                },
                addItemFromBankLink: function() {
                    return this.$el.find('.uxf-add-items-from-bank');
                },
                editLink: function() {
                    return this._quickLinksView.$('i.icon-pencil').parent();
                },
                saveLink: '.uxf-question-save:eq(0)',
                cancelLink: '.uxf-question-cancel:eq(0)',
                removeLink: function() {
                    return this._quickLinksView.$('i.icon-remove-sign').parent();
                },
                trashLink: function() {
                    return this._quickLinksView.$('i.icon-trash').parent();
                }
            },

            setEditMode: function(isEditMode) {
                var nextViewMeta;
                this.options.editMode = isEditMode;

                nextViewMeta = this._getNextViewClassMeta(isEditMode);
                if (!this._isNextViewAlreadyRendered(nextViewMeta.classId)) {
                    this._renderViewType(nextViewMeta);
                } else if (this._currentView.getEditMode() !== isEditMode) {
                    // toggle the edit mode of the current view
                    this._currentView.setEditMode(isEditMode);
                }
                if (isEditMode) {
                    // reset
                    this._notificationCode = null;
                    if (!this._currentView.model.id) {
                        this._currentView.$el.addClass('uxf-new-question');
                    }
                } else {
                    this._currentView.$el.removeClass('uxf-new-question');
                }
                this.trigger(isEditMode ? 'enterEditMode' : 'leaveEditMode', this);
            },

            initialize: function() {
                var questionType = this.model.get('questionType'),
                    quickLinks = [],
                    quickLinksForEditQuestions = [];

                if (!this.options.multichoiceViewClass || !this.options.griddedResponseEditViewClass) {
                    debug.error(
                        'Both a multichoiceViewClass and a griddedResponseEditViewClass must be provided'
                    );
                    throw new Error(
                        'Both a multichoiceViewClass and a griddedResponseEditViewClass must be provided'
                    );
                }

                if (!this.model) {
                    debug.error('QuestionViewProxy must be configured with a valid model');
                    throw new Error('QuestionViewProxy must be configured with a valid model');
                }

                // define a view structure based on question type and mode
                this._viewClassMeta = {
                    multichoiceview: {
                        className: this.options.multichoiceViewClass,
                        classId: 'multi-choice',
                        proxiedMethods: this.options.multichoiceMethods
                    },
                    multichoiceedit: {
                        className: this.options.multichoiceViewClass,
                        classId: 'multi-choice',
                        proxiedMethods: this.options.multichoiceMethods
                    },
                    grideedresponseview: {
                        className: this.options.multichoiceViewClass,
                        classId: 'multi-choice',
                        proxiedMethods: this.options.multichoiceMethods
                    },
                    griddedresponseedit: {
                        className: this.options.griddedResponseEditViewClass,
                        classId: 'gridded-response-edit',
                        proxiedMethods: this.options.griddedResponseMethods
                    },
                    accordionView: {
                        className: this.options.accordionViewClass,
                        classId: 'accordion', //xml
                        proxiedMethods: this.options.accordionMethods
                    }
                };

                // state variable to store the last validation error code
                this._notificationCode = null;

                // for "view mode"

                if (questionType !== CONSTANT.QUESTION_TYPE.XML && questionType !== CONSTANT.QUESTION_TYPE.MATHXL) {
                    //No edit for xml questions
                    quickLinks.push({
                        label: 'assessment-builder.question.edit',
                        className: 'icon-pencil',
                        event: 'edit'
                    });

                    quickLinks.push({
                        label: 'assessment-builder.question.remove',
                        className: 'icon-trash',
                        event: 'remove'
                    });
                } else {
                    quickLinks.push({
                        label: 'assessment-builder.question.remove',
                        className: 'icon-trash',
                        event: 'remove'
                    });
                }
                this._quickLinksView = QuickLinksView.newInstance(this, {
                    links: quickLinks
                });

                // for displaying the skills
                if (this.options.includeSkills) {
                    this._skillCollectionView = SkillCollectionView.newInstance(this, _.extend({}, {
                        model: this.model
                    }));
                }

                // for add questions - dropdown
                // todo: make this a separate view so that we can eliminate duplicate code
                this._addQuestionView = DropdownView.newInstance(this, {
                    dropdownMode: this.options.useDropdownForAddQuestion,
                    links: [{
                        label: 'assessment-builder.question.add',
                        className: 'icon-plus',
                        event: 'add-question-view',
                        sub: [{
                            label: 'assessment-builder.question.addMC',
                            className: '',
                            event: 'add-question-mc'
                        }, {
                            label: 'assessment-builder.question.addGR',
                            className: '',
                            event: 'add-question-gr'
                        }, {
                            label: 'assessment-builder.question.addQB',
                            className: '',
                            event: 'add-question-bank'
                        }]
                    }]
                });

                this._addQuestionFromBankLink = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.addQB',
                        className: 'icon-plus',
                        event: 'add-question-bank-nonNative'
                    }]
                });

                this.listen(this._quickLinksView, 'edit', this._editLinkClicked, this);
                this.listen(this._quickLinksView, 'remove', this.removeQuestion, this);
                this.listen(this._addQuestionView, 'add-question-view', this._addQuestionMC, this);
                this.listen(this._addQuestionView, 'add-question-mc', this._addQuestionMC, this);
                this.listen(this._addQuestionView, 'add-question-gr', this._addQuestionGR, this);
                this.listen(this._addQuestionView, 'add-question-bank', this._addQuestionFromBank, this);
                this.listen(this._addQuestionFromBankLink, 'add-question-bank-nonNative',
                    this._addQuestionFromBankNonNative, this);

                quickLinksForEditQuestions.push({
                    label: this.localize.cancel(),
                    className: 'icon-ban-circle',
                    event: 'cancel-header'
                });
                quickLinksForEditQuestions.push({
                    label: this.localize.save(),
                    className: 'icon-ok',
                    event: 'save-header'
                });

                this._saveAndCancelLinkHeader = QuickLinksView.newInstance(this, {
                    links: quickLinksForEditQuestions
                });

                this.listen(this._saveAndCancelLinkHeader, 'save-header', this._saveButtonPressed, this);
                this.listen(this._saveAndCancelLinkHeader, 'cancel-header', this._cancelButtonPressed, this);

                this.listen(this.model, 'validation', this._showValidation, this);
                this.listen(this.model, 'notification', this._showNotification, this);

                this.bind('enterEditMode', function() {
                    this.model.flush().store();
                    // inform proxied view of edit mode to do question type specifc logic
                    this._currentView.enterEditMode();
                });

                this.bind('leaveEditMode', function() {
                    this._currentView.leaveEditMode();
                });

                this.listen(this.model, 'change:position', this._onQuestionPositionChange, this);
                // initialize to the correct view type based on the question type and 'view' layout
                this._renderViewType(this._getNextViewClassMeta(this.options.editMode));

                this.enableQuestionBanks(false);
                this._currentView.on('undo-success', this.undoRemoveQuestion, this);
            },

            commit: function(from) {
                var self = this,
                    unsavedEditPromise;

                if (from === this || this.options.editMode === false) {
                    return $.Deferred().resolve();
                }

                unsavedEditPromise = builderService().showUnsavedEditDialog();
                return unsavedEditPromise.then(function(choice) {
                    if (choice === 'save') {
                        return self._validateAndSaveEdit().then(function() {
                            builderService().scheduleScrollTo(from);
                            return $.Deferred().resolve(); //Continue with user action
                        });

                    } else if (choice === 'continue') {
                        // cancel edit, scroll to new location and start new edit.
                        self.cancel();
                        builderService().scheduleScrollTo(from);
                        return $.Deferred().resolve();

                    } else {
                        builderService().scheduleScrollTo(self);
                        return $.Deferred().reject();
                    }
                });
            },

            /**
             * Cancel editing mode.  Allows parent view to force a cancel when another
             * view wants edit mode.  Can veto the change by returning false.
             */
            cancel: function(e) {
                if (this.options.includeSkills) {
                    this._skillCollectionView.clearSkillsFlaggedForRemoval();
                }
                this._currentView.cancelEdit();
                this.model.restart();
                this._currentView.getChildCollection().restart();
                this.setEditMode(false);
                this.trigger('cancel-edit', this.model, e);
                return true;
            },

            /*
             * Receive permission from parent view to proceed with the remove operation
             */
            removeQuestion: function(target, event) {
                this.model.setRemoveFlag(true);
                this.trigger('remove-success', this.model);
                this._currentView.removeQuestion();
            },

            undoRemoveQuestion: function() {
                this.model.setRemoveFlag(false);
                this.trigger('undo-success', this.model);
            },

            enableQuestionBanks: function(enabled) {
                this._questionBanksEnabled = enabled;
                if (enabled) {
                    this.locate('addFromBankMenuItem').show();
                } else {
                    this.locate('addFromBankMenuItem').hide();
                }
            },

            enableAddQuestionFromBankLink: function(enabled) {
                this._questionBanksEnabled = enabled;
                if (enabled) {
                    this.locate('addItemFromBankLink').show();
                } else {
                    this.locate('addItemFromBankLink').hide();
                }
            },

            _addQuestionMC: function(e) {
                this.trigger('add-question-mc', e, this);
            },

            _addQuestionGR: function(e) {
                this.trigger('add-question-gr', e, this);
            },

            _addQuestionFromBank: function(e) {
                var position = this.model.get('position');
                this.trigger('put-new-question', e, position, this);
            },

            _addQuestionFromBankNonNative: function(e) {
                var position = this.model.get('position');
                this.trigger('put-new-question', e, position, this);
            },

            _onQuestionPositionChange: function() {
                var position = this.model.get('position'),
                    el = this.locate('questionNumber');
                el.text(position);
            },

            _cancelButtonPressed: function(e) {
                EventBus.trigger('assessment-builder:schedule-scroll-to', this.$el);
                this.cancel(e);
            },

            _saveButtonPressed: function(e) {
                var self = this,
                    promise = this._validateAndSaveEdit(e);

                promise.then(function() {
                    EventBus.trigger('assessment-builder:schedule-scroll-to', self.$el);
                });
            },

            /** Final actions of this view to save:
             * 1. First removes empty responses
             * 2. Gets out of edit mode
             * 3. Ultimately triggers save-question event so the widget can perform the save
             */
            _saveEdit: function(event) {
                var self = this,
                    promise, deferred;

                this.model.removeEmptyResponses();
                this.model.removeAudio();

                this.trigger('save-question', this.model, event, function() {
                    self.setEditMode(false);
                });

                this.model.savePending();

                deferred = $.Deferred();

                promise = builderService().saveQuestion(this.options.assessmentId, this.model.exportJSON());
                promise.then(function(question) {
                    self.model.set(question);

                    self.setEditMode(false);
                    EventBus.trigger('assessment-builder:question:save-success', question, event);

                    deferred.resolve();
                }, function() {
                    deferred.reject();
                });

                return deferred.promise();
            },

            /** Validation and other preparation for a save
             * 1. close open editors
             * 2. validates fields
             * 3. checks for audio
             * 4. if all is well - calls _saveEdit
             */
            _validateAndSaveEdit: function(event) {
                var promise,
                    self = this;

                // close editors in preparation for save
                this._currentView.closeAllEditors();

                if (!this._validateFields()) {
                    builderService().showAlert('ERROR', this.i18n(this._notificationCode),
                        this.locate('errorMsgElSelector'));
                    builderService().scheduleScrollTo(this);
                    return $.Deferred().reject();
                }
                this.locate('errorMsgElSelector').html(' ');

                // if the question and/or response has audio, let the user know that the audio
                // will be deleted if they save their edit
                // false --> check both question and response for audio
                if (this.model.hasAudio(false)) {
                    // show the audio warning.  If resolved (ok pressed) then go ahead
                    // and saved.
                    promise = this._sendAudioWarning(event);
                    return promise.then(function() {
                        return self._saveEdit(event);
                    });

                } else {
                    // save valid fields
                    return this._saveEdit(event);
                }
            },

            /**
             * If the question has audio, we warn the user that it will be deleted if
             * they continue with saving the edits.
             *
             * Returns a promise.  If user clicks ok will resolve the promise.  If use clicks cancel, will
             * reject the promise.
             */
            _sendAudioWarning: function(event) {
                var audioWarningDialog, okClickHandler, cancelClickHandler, button,
                    self = this,
                    dialogParams = {},
                    defer;

                defer = $.Deferred();

                okClickHandler = function() {
                    defer.resolve();
                };

                cancelClickHandler = function() {
                    defer.reject();
                };

                // kill off any scroll requests.
                EventBus.trigger('assessment-builder:schedule-scroll-to', null);

                dialogParams.id = 'assessment-builder.question.audio-warning'; //unique dialog id
                dialogParams.titleCode = 'assessment-builder.question.audio-warning.title';
                dialogParams.bodyCode = 'assessment-builder.question.audio-warning.desc';
                dialogParams.isDismissible = true;
                dialogParams.closeClickHandler = cancelClickHandler;
                // convenience reference to the default button's click handler
                dialogParams.defaultClickHandler = okClickHandler;

                dialogParams.buttons = [];

                button = {};
                button.code = 'assessment-builder.question.audio-warning.cancel';
                button.isDefault = false;
                button.clickHandler = cancelClickHandler;
                dialogParams.buttons.push(button);

                button = {};
                button.code = 'assessment-builder.question.audio-warning.ok';
                button.isDefault = true;
                button.clickHandler = okClickHandler;
                dialogParams.buttons.push(button);

                audioWarningDialog = DialogUtil.createSimpleDialog(dialogParams);

                builderService().showDialog(audioWarningDialog);

                return defer.promise();
            },

            /**
             * Event handler for "remove" quick link
             */
            _removeQuestionRequested: function(e) {
                // let parent view know that a remove request has been made.
                // Parent view can disallow this request if another question view is being edited
                this.trigger('remove-requested', this);
            },

            /**
             * Event handler for "play question link" quick link
             */
            _playAudio: function(evt) {
                var audioType = this.model.get('audioType'),
                    audioId = this.model.get('audioId'),
                    audioAssessmentId = this.model.get('audioAssessmentId');
                AudioPlayerService.play(audioType, audioId, audioAssessmentId);
                this._wasAudioTrigerred = true;
            },

            /**
             * Switch to edit mode when the edit button is clicked.
             */
            _editLinkClicked: function() {
                this.trigger('edit-mode-requested', this);
            },

            showRemoveLink: function(enabled) {
                // do nothing if destroyed
                if (this._isDestroyed) {
                    return;
                }

                if (enabled === true) {
                    //this.locate("removeLink").show();
                    /* Doesn't work for IE when the value should be 'inline-block'. */
                    this.locate('trashLink').css('display', 'inline-block');
                } else {
                    this.locate('trashLink').hide();
                }
            },

            /**
             * Function called after MC or GR view has been rendered
             */
            _postRenderViewType: function() {
                // hmm. this shouldn't be necessary.  TODO: figure out why it is.
                if (this._isDestroyed) {
                    return;
                }

                if (!this.options.editMode) {
                    this._quickLinksView.setElement(this.locate('quickLinks'));
                    this._quickLinksView.render();

                    // true -->  check only the question for audio but do not also check the response
                    if (this.model.hasAudio(true)) {
                        this.locate('questionAudioPlayer').show();
                    }

                    // Hide the remove link immediately on rendering - it will be shown as needed by the parent view.
                    // This prevents the link from being shown (and clickable) while the parent view is processing.
                    this.showRemoveLink(false);
                } else {
                    if (this.model === null) {
                        debug.error('error');
                    }
                    this._updateCharacterCount(this.model.get('text'));

                    this._saveAndCancelLinkHeader.setElement(this.locate('editButtons'));
                    this._saveAndCancelLinkHeader.render();

                    if (this.options.includeSkills) {
                        this._skillCollectionView.setElement(this.locate('skillList'));
                        this._skillCollectionView.render();
                    }
                }
                this._addQuestionView.setElement(this.locate('dropdown'));
                this._addQuestionView.render();
                this.enableQuestionBanks(this._questionBanksEnabled);

                if (this.model.get('isPaf')) {
                    this._addQuestionFromBankLink.setElement(this.locate('addItemFromBankLink'));
                    this._addQuestionFromBankLink.render();
                    this.enableAddQuestionFromBankLink(this._questionBanksEnabled);
                }
            },

            render: function() {
                if (!this._currentView) {
                    debug.error('Current view has not been correctly configured in QuestionViewProxy');
                    throw new Error('Current view has not been correctly configured in QuestionViewProxy');
                }

                this._currentView.render();
                return this;
            },

            /**
             * Render the passed in view template
             * @param viewClassMeta - a structure containing  class name and id of the view to be rendered
             */
            _renderViewType: function(viewClassMeta) {
                var opts, view, proxyMethods, response;

                opts = _.extend({}, {
                    model: this.model
                });
                opts = _.extend(opts, this.options);
                opts.postRenderViewType = _.bind(this._postRenderViewType, this);
                opts.destroyEditor = _.bind(this._destroyEditor, this);
                opts.viewClassId = viewClassMeta.classId;
                opts.ckeditorSkin = this.options.ckeditorSkin;

                this._currentView = viewClassMeta.className.newInstance(this, opts);
                proxyMethods = viewClassMeta.proxiedMethods;

                if (this._currentView.className) {
                    this.$el.addClass(this._currentView.className);
                }

                this.selectors = _.extend(this.selectors, this._currentView.selectors);
                this._setupProxyMethods(proxyMethods);
                this.listen(this._currentView, 'all', this._replayEvents, this);
                this._currentView.setElement(this.$el);

                this.render();
            },

            _replayEvents: function(eventName, event, param) {
                this.trigger(eventName, event, param);
            },

            /**
             * Handle the focus event and replace the target with a rich text editor
             */
            _editorPreviewFocused: function(e) {
                this._createRichTextEditor(e.currentTarget);
            },

            /**
             * Create a rich text editor instance
             * @param targetEl - any block-level element to be replaced with an editor
             */
            _createRichTextEditor: function(targetEl) {
                var self = this,
                    assessmentId = this.options.assessmentId,
                    toolbarList,
                    editorParams,
                    customAlert;

                if (_.isFunction(this._currentView._createRichTextEditor)) {
                    this._currentView._createRichTextEditor(targetEl);
                }

                customAlert = function(txt) {
                    EventBus.trigger('assessment-builder:ckeditor:alert', txt);
                };

                toolbarList = (this.options.editorUpload === true && browserUtils.getHostOS() !== 'iPad') ? [
                    ['Bold', 'Italic', 'Underline', '-', 'Image']
                ] : [
                    ['Bold', 'Italic', 'Underline']
                ];

                editorParams = {
                    alert: customAlert,
                    toolbarCanCollapse: false,
                    toolbarStartupExpanded: true, // default
                    toolbar: 'TestBuilder',
                    toolbar_TestBuilder: toolbarList,
                    filebrowserImageBrowseUrl: null,
                    filebrowserImageUploadUrl: config('contextPath') + '/assessment/' + assessmentId +
                        '/imageSource/question/',
                    removePlugins: 'elementspath,resize',
                    forcePasteAsPlainText: true,
                    removeDialogTabs: 'image:Link',
                    resize_enabled: false,
                    resize_dir: 'vertical',
                    autoGrow_onStartup: true,
                    extraPlugins: 'autogrow',
                    autoGrow_minHeight: 75,
                    autoGrow_maxHeight: 800,
                    startupFocus: true,
                    language: i18n.getLang(),
                    enterMode: 2 // this prevents the content from being wrapped in <p>...</p>
                };

                if (this.options.ckeditorSkin) {
                    editorParams.skin = this.options.ckeditorSkin;
                }

                this._editorInstance = $(targetEl).ckeditor(editorParams).ckeditorGet();

                // update character count immediately
                this._onEditorChange();

                // quick and dirty way for now - refactor out duplicate editor code later.
                this._editorInstance.on('instanceReady', function(evt) {
                    this.document.on('keyup', function() {
                        self._onEditorChange($(self._editorInstance.element.$));
                    });
                });
            },

            /**
             * Set skip save to true if you want to close without saving to the model.
             * We do this during render to avoid ckeditor errors.
             */
            _destroyEditor: function(cancelEdit) {
                var txt, isEmpty = false;
                debug.log('destroyEditor', this._editorInstance);

                // make sure cancelEdit is defined
                cancelEdit = (cancelEdit ? true : false);

                // first if exists, remove, it will update the DOM on the way out...
                if (this._editorInstance) {
                    // cancelEdit is to avoid errors in certain instances
                    if (!cancelEdit) {
                        isEmpty = browserUtils.isCkEditorFieldEmpty(this.$el);
                        txt = isEmpty ? '' : $.trim(this._editorInstance.getData());
                        this.model.set('text', txt);
                    }

                    this._editorInstance.destroy(cancelEdit);
                    this._editorInstance = null;
                }

                this._editorInstance = null;
            },

            _onEditorChange: function(e) {
                var source = this._editorInstance.getData();
                this._updateCharacterCount(source);
            },

            _updateCharacterCount: function(source) {
                var count = $.trim($('<div>' + source + '</div>').text()).length,
                    maxMsg = this.localize.i18nCharacterMax([count, this.options.questionTextMax]);
                this.locate('characterCounter').html(maxMsg);
            },

            _destroyCurrent: function() {
                // drop all existing proxied methods...
                this._dropProxyMethods();

                if (this._currentView) {
                    if (this._currentView.className) {
                        this.$el.removeClass(this._currentView.className);
                    }
                    this.unlisten(this._currentView, 'all', this._replayEvents, this);
                    this._currentView.destroy();
                    this._currentView = null;
                }
            },

            _setupProxyMethods: function(methods) {
                // drop all existing proxied methods...
                this._dropProxyMethods();
                // proxy each method for the new view...  Basically just creates
                // a small wrapper function that calls the real method on the
                // proxied view with the correct context if the function actually
                // exists
                _.each(methods, function(val) {
                    this[val] = function() {
                        if (_.isFunction(this._currentView[val])) {
                            return this._currentView[val].apply(this._currentView, arguments);
                        }

                        throw new Error('invalid proxy method defined: ' + val);
                    };
                }, this);
                // keep track of which methods are proxied...
                this._proxiedMethods = methods;
            },

            _dropProxyMethods: function() {
                if (this._proxiedMethods) {
                    _.each(this._proxiedMethods, function(val) {
                        if (_.isFunction(this[val])) {
                            this[val] = undefined;
                        }
                    }, this);
                    this._proxiedMethods = null;
                }
            },

            /**
             * @return true if valid, false otherwise
             */
            _validateFields: function() {
                return this._currentView.validateFields();
            },

            _showNotification: function(e) {
                if (this.isEditMode) {
                    if (e && e.code) {
                        this._notificationCode = e.code;
                    }
                }
            },

            /**
             * Get the edit mode.
             * @return {Boolean}
             */
            isEditMode: function() {
                return this.options.editMode;
            },

            _showValidation: function(e) {
                if (this.isEditMode) {
                    if (e && e.isValid) {
                        this.locate('questionError').css('visibility', 'hidden');
                    } else {
                        this.locate('questionError').css('visibility', 'visible');
                    }
                }
            },

            /**
             * return true if the requested view is same as the current view
             */
            _isNextViewAlreadyRendered: function(nextViewClassId) {
                return this._currentView.options.viewClassId === nextViewClassId;
            },

            /**
             * Return  meta info for next view based on question type and  mode
             * @link https://hub.pearson.com/confluence/display/TK12/Assessment+Builder+-+Question+View+hierarchy
             *
             * @param isEditMode - if true the next view will be rendered in 'edit' mode else in 'view' mode
             */
            _getNextViewClassMeta: function(isEditMode) {
                var viewClassMeta, questionType;
                questionType = this.model.get('questionType');
                switch (questionType) {
                    case 'multiple-choice':
                        viewClassMeta = isEditMode ? this._viewClassMeta.multichoiceedit :
                            this._viewClassMeta.multichoiceview;
                    break;
                    case 'gridded-response':
                        viewClassMeta = isEditMode ? this._viewClassMeta.griddedresponseedit :
                            this._viewClassMeta.grideedresponseview;
                    break;
                    case CONSTANT.QUESTION_TYPE.MATHXL:
                    case CONSTANT.QUESTION_TYPE.XML:
                        viewClassMeta = this._viewClassMeta.accordionView;
                    break;
                    default:
                        debug.error('Unknown question type ' + questionType);
                        throw new Error('Unknown question type ' + questionType);
                }
                return viewClassMeta;
            },

            onDestroy: function() {
                this._destroyEditor(true);
                this._isDestroyed = true;
                this._quickLinksView.destroy();
                this._quickLinksView = null;
                this._addQuestionView.destroy();
                this._addQuestionView = null;
                this._saveAndCancelLinkHeader.destroy();
                this._saveAndCancelLinkHeader = null;

                if (this._skillCollectionView) {
                    this._skillCollectionView.destroy();
                    this._skillCollectionView = null;
                }

                this._destroyCurrent();
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.QuestionRowView',
    initArgs: ['jQuery', 'Backbone', '_', 'debug', 'UXF.Common.AbstractView', 'UXF.AssessmentBuilder.Constants'],
    initFunc: function($, Backbone, _, debug, AbstractView, Constants) {
        'use strict';

        var View, template, CONSTANT = new Constants();

        template = [
            '<div class="uxf-reorder-position"><%- position %></div>',
            '<div class="uxf-reorder-text"><%= text %></div>'
        ].join('');

        View = AbstractView.extend({
            tagName: 'li',
            className: 'uxf-reorder-question-row',
            options: {
                maxChars:  600,
                thumbnailMax: 40
            },
            templates: {
                body: template
            },
            events: {
            },
            selectors: {
                position: '.uxf-reorder-position',
                text: '.uxf-reorder-text'
            },

            initialize: function() {
                if (!this.model) {
                    throw 'QuestionModel is required';
                }

                this.listen(this.model, 'change:position', this._onQuestionPositionChange, this);
            },

            _onQuestionPositionChange: function() {
                var position = this.model.get('position'),
                    el = this.locate('position');
                el.text(position);
            },

            render: function() {
                var data = {
                    id: this.model.get('id'),
                    position: this.model.get('position'),
                    text: this._restrictQuestionText()
                };
                this.$el.html(this.templates.body(data));
                this.$el.attr('id', ['question', data.id].join('_'));

                return this;
            },

            /**
             * Get the text to display for the reorder view.
             *
             * @return {*}
             * @private
             */
            _restrictQuestionText: function() {
                var tmpElement = $('<div/>'),
                    questionType = this.model.get('questionType'),
                    //Use title for non-native, since native user-created test
                    //always have empty for title (V1 Customize)
                    isPaf = (questionType === CONSTANT.QUESTION_TYPE.XML ||
                            questionType === CONSTANT.QUESTION_TYPE.MATHXL),
                    textField = isPaf ? 'title' : 'text',
                    text = this.model.get(textField) || '&nbsp;',
                    bufferData = {
                        text: '',
                        length: 0
                    },
                    tagData;

                tmpElement.html($.trim(text));
                this._replaceTags(tmpElement.get()[0], bufferData);
                // could probably do this in _replaceTags, but doing it here avoids
                // some ugly edge cases.
                if (bufferData.truncated) {
                    bufferData.text = bufferData.text.substring(0, this.options.maxChars - 3) + '...';
                }

                return bufferData.text;
            },

            _replaceTags: function(domNode, buffer) {
                var self = this,
                    realTxt,
                    txt,
                    allowed = Math.max(0, this.options.maxChars - buffer.length);

                if (allowed === 0) {
                    // handle edge case where entire contents of a tag takes length
                    // to exactly 400, but there are more tags still...
                    buffer.truncated = true;
                    return;
                }

                // text nodes...
                if (domNode.nodeType === 3) {
                    realTxt = $(domNode).text();
                    txt = realTxt.substring(0, allowed);
                    buffer.truncated = allowed < realTxt.length;
                    buffer.text += txt;
                    buffer.length += txt.length;
                    return;
                }

                // images...
                if ((/^IMG$/i).test(domNode.nodeName)) {
                    buffer.text += this._replaceImage($(domNode), buffer);
                    return;
                }

                // all other tags...
                _.each($(domNode).contents(), function(child) {
                    self._replaceTags(child, buffer);
                });
            },

            /**
             * Replace an image tag with a new image tag.   Just copies src and alt
             * attributes.   Will always add the class 'uxf-reorder-image'.  If we
             * can guess that that image is greater than 40x40 and which is greater
             * (height or width), will add a uxf-scale-horizontal or uxf-scale-vertical
             * class as well that can be used to help with proportional scaling.
             *
             * @param el
             * @return {String}
             * @private
             */
            _replaceImage: function(el) {
                var src = el.attr('src'),
                    alt = el.attr('alt'),
                    classes = 'uxf-reorder-image',
                    width, height;

                // try and get the image width.  Not super reliable.  Doesn't seem
                // that there is any easy way to synchronously get the actual image
                // height/width...
                width = el.attr('width') || 0;
                height = el.attr('height') || 0;

                if (width > this.options.thumbnailMax || height > this.options.thumbnailMax) {
                    classes += width >= height ? ' uxf-scale-horizontal' : ' uxf-scale-vertical';
                }

                return '<img src="' + src + '" alt="' + alt + '" class="' + classes + '"></img>';
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});

;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.QuestionView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.CollectionView',
        'UXF.Common.QuickLinksView',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Views.ResponseProxyView',
        'UXF.AssessmentBuilder.Views.ResponseView',
        'UXF.AssessmentBuilder.Views.SkillView',
        'UXF.AssessmentBuilder.Views.GriddedResponseView',
        'UXF.AssessmentBuilder.Models.ResponseModel'
    ],
    initFunc: function($, Backbone, _, debug, CollectionView, QuickLinksView, EventBus, ResponseProxyView,
        ResponseView, SkillView, GriddedResponseView, ResponseModel) {
        'use strict';

        var View,
            questionTemplate,
            editQuestionTemplate;

        questionTemplate = [
            '<div class="uxf-add-question-dropdown"></div>',
            '<div class="uxf-question-container-box">',
                '<div class="questionUndoContainer">',
                    '<div class="undo-message">',
                        '<span><%__ "assessment-builder.question.undo-desc" %></span>',
                        '<span class="uxf-question-controls"></span>',
                    '</div>',
                '</div>',
                '<div class="uxf-left-panel">',
                    '<div class="uxf-question-number">',
                    '<%- position %>',
                    '</div>',
                '</div>',

                '<div class="uxf-right-panel">',
                    '<div class="uxf-question-header uxf-question-view-mode">',
                        '<div class="uxf-question-column">',
                            '<div class="uxf-question-audio-player uxf-audio-player" style="display: none;">',
                                '<a href="javascript://"><i class="uxf-icon-audio"></i>' +
                                '<%__ "assessment-builder.audio.listen" %></a>',
                            '</div>',
                            '<div class="uxf-question-body">',
                                '<%= text %>',
                            '</div>',
                        '</div>',
                        '<div class="uxf-question-quicklinks"></div>',
                    '</div>',

                    '<div class="uxf-response-list"></div>',
                '</div>',
                '<div style="clear:both;"></div>',
            '</div>'
        ].join('');

        editQuestionTemplate = [
            '<div class="uxf-add-question-dropdown"></div>',
            '<div class="uxf-question-container-box">',

                '<div class="uxf-left-panel">',
                    '<div class="uxf-question-number uxf-edit-question-number">',
                        '<%- position %>',
                    '</div>',
                '</div>',

                '<div class="uxf-right-panel">',
                    '<div class="uxf-question-header uxf-question-edit-mode uxf-edit-question-header">',

                        '<div class="uxf-question-column uxf-question-body uxf-question-body-edit-mode">',
                            '<span class="uxf-question-edit-label">' +
                                '<%__ "assessment-builder.question.question" %>',
                            '</span>',
                            '<span class="uxf-field-validation-error"></span>',
                            '<div class="uxf-field-wrapper">',
                                '<div class="uxf-editor-preview question" tabindex="0">',
                                    '<%= text %>',
                                '</div>',
                            '</div>',
                        '</div>',

                        '<div class="uxf-controlbar uxf-edit-controlbar"></div>',
                        '<div class="uxf-clear"></div>',
                    '</div>',
                    //Host app will populate this element with validation error messages
                    '<div class="uxf-notification-wrapper uxf-edit-notification-wrapper">' +
                        '<div class="uxf-notification uxf-notification-error uxf-notification-message' +
                            ' uxf-question-notification uxf-edit-question-alert">',
                        '</div>',
                    '</div>',
                    '<div class="uxf-answers">',
                        '<div class="uxf-response-answer-label">',
                            '<%__ "assessment-builder.response.answer" %>',
                        '</div>',
                        '<div class="uxf-question-instructions uxf-edit-question-instructions">' +
                            '<%__ "assessment-builder.question.mc.header.instructions" %></div>',
                        '<div class="uxf-response-list uxf-response-list-edit-mode"></div>',
                        '<div class="uxf-answers-controls"></div>',
                    '</div>',

                    '<% if (includeSkills) { %>',
                    '<div class="uxf-skill-container"></div>',
                    '<% } %>',
                '</div>',
            '</div>'
        ].join('');

        View = CollectionView.extend({
            className: 'uxf-question-container',
            options: {
                template: questionTemplate,
                collectionName: 'responses',
                containerSelector: 'responseList',
                viewClass: ResponseProxyView,
                viewName: 'ResponseProxyView',
                editMode: false,
                showFeedback: true,
                assessmentId: null,
                restPath: null,
                editorUpload: true,
                useDropdownForAddQuestion: false,
                includeSkills: true,
                ckeditorSkin: undefined
            },
            classes: {
                responses: 'uxf-response-list'
            },
            selectors: {
                skillList: '.uxf-skill-container',
                responseList: '.uxf-response-list',
                answerQuicklinks: '.uxf-answers-controls',
                addAnswerLink: function() {
                    return this._quickLinksAnswers.$('i.icon-plus').parent();
                },
                editInstructions: '.uxf-edit-question-instructions',
                questionUnDoControls: '.uxf-question-controls'
            },
            templates: {
                editQuestion: editQuestionTemplate
            },
            events: {
                'click .questionUndoContainer .uxf-question-controls': '_undoRemoveQuestion'
            },

            initialize: function() {
                this._quickLinksAnswers = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.addAnswer',
                        className: 'icon-plus',
                        event: 'add'
                    }]
                });

                this._showFeedback = this.options.showFeedback;

                this._quicklinksQuestionsUndo = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.undo-remove-skill',
                        className: 'icon-undo',
                        event: 'undo'
                    }]
                });

                this.listen(this._quicklinksQuestionsUndo, 'undo', this._undoRemoveQuestion, this);

                this.listen(this._quickLinksAnswers, 'add', this._addResponse, this);
                this.listen(this.getChildCollection(), 'add', this._limitAnswers, this);
                this.listen(this.getChildCollection(), 'remove', this._limitAnswers, this);
            },

            _limitAnswers: function() {

                var showAddAnswer = (this.getChildCollection().length < 8),
                    showRemoveAnswers = (this.getChildCollection().length > 2);

                // limit responses to 8
                if (showAddAnswer) {
                    this._quickLinksAnswers.locate('links').show();
                } else {
                    // also delete extras?
                    this._quickLinksAnswers.locate('links').hide();
                }

                _.each(this._viewMap, function(view) {
                    view.showRemoveLink(showRemoveAnswers);
                });
            },

            enterEditMode: function() {
                EventBus.trigger('assessment-builder:question:enterEdit', this.$el);
                $('.uxf-assessment-builder-header, .uxf-view-mode').addClass('disabled');
                $('.uxf-assessment-builder-content').find('.uxf-add-question-dropdown').addClass('disabled');
                this.getChildCollection().flush().store();
            },

            leaveEditMode: function() {
                EventBus.trigger('assessment-builder:question:leaveEdit', this.$el);
                $('.uxf-assessment-builder-header, .uxf-view-mode').removeClass('disabled');
                $('.uxf-assessment-builder-content').find('.uxf-add-question-dropdown').removeClass('disabled');
            },

            /**
             * Set edit mode for this view.  Will fire 'enterEditMode' and 'leaveEditMode'
             * events so that other views can update themselves correctly.
             *
             * @param mode boolean value - true == editMode, false == viewMode
             */
            setEditMode: function(mode) {
                this.options.editMode = mode;
                _.each(this._viewMap, function(view) {
                    if (view && view.setEditMode) {
                        view.setEditMode(mode, {
                            silent: true
                        });
                    }
                });
                this.render();
            },

            getEditMode: function() {
                return this.options.editMode;
            },

            _createView: function(model) {
                return CollectionView.prototype._createView.apply(this, [model, {
                    textOptionViewClass: ResponseView,
                    griddedResponseViewClass: GriddedResponseView,
                    getTextOptionViewOptions: _.bind(this._getTextOptionViewOptions, this),
                    getGriddedResponseViewOptions: _.bind(this._getGriddedResponseViewOptions, this),
                    ckeditorSkin: this.options.ckeditorSkin
                }]);
            },

            /**
             * Get the edit mode.
             * @return {Boolean}
             */
            isEditMode: function() {
                return this.options.editMode;
            },

            _getTextOptionViewOptions: function(model) {
                return {
                    model: model,
                    showFeedback: this._showFeedback,
                    editMode: this.isEditMode(),
                    assessmentId: this.options.assessmentId,
                    restPath: this.options.restPath,
                    ckeditorSkin: this.options.ckeditorSkin
                };
            },

            _getGriddedResponseViewOptions: function(model) {
                return {
                    model: model
                };
            },

            onChildViewCreated: function(view) {
                this.listen(view, 'editor-enabled', this._destroyAllEditors, this);
                this.listen(view, 'remove', this._removeResponse, this);
            },

            onChildViewDestroyed: function(view) {
                this.unlisten(view, 'editor-enabled', this._destroyAllEditors, this);
                this.unlisten(view, 'remove', this._removeResponse, this);
            },

            _addResponse: function() {
                this.getChildCollection().add(new ResponseModel());
            },

            _removeResponse: function(model) {
                this.$el.find(this.selectors.responseList).focus();
                this.getChildCollection().remove(model);
            },

            removeQuestion: function() {
                this.$el.find('.uxf-left-panel').hide();
                this.$el.find('.uxf-right-panel').hide();
                this.$el.find('.questionUndoContainer').show();
                this._quicklinksQuestionsUndo.setElement(this.locate('questionUnDoControls'));
                this._quicklinksQuestionsUndo.render();
            },

            _undoRemoveQuestion: function() {
                this.trigger('undo-success');
                this.$el.find('.questionUndoContainer').hide();
                this.$el.find('.uxf-left-panel').show();
                this.$el.find('.uxf-right-panel').show();
            },

            cancelEdit: function() {
                var cancelEdit = true;
                this._destroyAllEditors(cancelEdit);
            },

            closeAllEditors: function() {
                var cancelEdit = false;
                this._destroyAllEditors(cancelEdit);
            },

            /**
             * @return true if valid, false otherwise
             */
            validateFields: function() {
                return this.model.triggerValidation();
            },

            _createRichTextEditor: function(targetEl) {
                this._destroyAllEditors();
            },

            /**
             * Should destroy any open ckeditor if there is one, for the question or any of its
             * child (response) views.
             * @param cancelEdit pass cancelEdit along to the destroyEditor calls (false if not supplied)
             */
            _destroyAllEditors: function(cancelEdit) {
                // make sure cancelEdit is defined (false if not defined)
                // note: cancelEdit is actually a view in the case of a
                //    'editor-enabled' event, so check using strict equals
                cancelEdit = (cancelEdit === true ? true : false);

                // destroy editor on the question (method passed from questionproxy)
                this.options.destroyEditor(cancelEdit);

                // destroy editor for all child (response) views
                _.each(this._viewMap, function(v, k) {
                    v.destroyEditor(cancelEdit);
                });
            },

            /**
             * Pick the appropriate template (default or edit) based on the edit mode.
             *
             * @param template default template function
             * @param model the model
             * @param classes the list of classes
             * @protected
             */
            _renderTemplate: function(template, model, classes) {
                if (this.options.editMode) {
                    template = this.templates.editQuestion;
                    this.$el.removeClass('uxf-view-mode').addClass('uxf-edit-mode');
                } else {
                    this.$el.removeClass('uxf-edit-mode').addClass('uxf-view-mode');
                }

                CollectionView.prototype._renderTemplate.call(this, template, model, classes, {
                    showFeedback: this._showFeedback,
                    includeSkills: this.options.includeSkills,
                    position: this.model.newPosition || this.model.get('position')
                });

                if (this.model.newPosition >= 0) {
                    this.$el.find('.questionUndoContainer').hide();
                    if (this.options.editMode) {
                        this._quickLinksAnswers.setElement(this.locate('answerQuicklinks'));
                        this._quickLinksAnswers.render();
                    }
                } else {
                    this.$el.find('.uxf-left-panel').hide();
                    this.$el.find('.uxf-right-panel').hide();
                    this.$el.find('.questionUndoContainer').show();
                    this._quicklinksQuestionsUndo.setElement(this.locate('questionUnDoControls'));
                    this._quicklinksQuestionsUndo.render();

                }

                this.options.postRenderViewType();
            },

            render: function() {
                var cancelEdit = true;

                if (this.options.editMode) {
                    // destroy all editors
                    this._destroyAllEditors(cancelEdit);
                }

                CollectionView.prototype.render.call(this);

                if (this.options.editMode) {
                    this._limitAnswers();
                }

                // Backbone - establish new el as the el.
                this.setElement(this.el);

                return this;
            },

            onDestroy: function() {
                if (this._quickLinksAnswers) {
                    this._quickLinksAnswers.destroy();
                    this._quickLinksAnswers = null;
                }
            }

        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.ReorderView',
    initArgs: [
        'jQuery',
        '_',
        'UXF.Common.AbstractView',
        'debug',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Views.AssessmentSummaryView',
        'UXF.AssessmentBuilder.Views.ReorderCollectionView',
        'UXF.AssessmentBuilder.Views.InstructionBarView'
    ],
    initFunc: function($, _, AbstractView, debug, Templates, SummaryView, ReorderCollectionView, InstructionBarView) {
        'use strict';

        var View;

        View = AbstractView.extend({
            templates: {
                body: Templates['assessment-builder-layout']
            },
            selectors: {
                header: '.uxf-assessment-builder-header',
                instruction: '.uxf-assessment-builder-instruction',
                instructionNoText: '.uxf-assessment-builder-instruction-no-text',
                body: '.uxf-assessment-builder-content'
            },

            initialize: function() {
                if (!this.model) {
                    throw new Error('ReorderView must be initialized with an Assessment model');
                }

                this._instructionBarView = InstructionBarView.newInstance(this, {
                    model: this.model,
                    currentMode: 'reorder',
                    showText: true
                });
                this._instructionBarViewBottom = InstructionBarView.newInstance(this, {
                    model: this.model,
                    currentMode: 'reorder',
                    showText: false
                });

                this._reorderView = ReorderCollectionView.newInstance(this, _.extend({}, this.options, {
                    el: undefined
                }));
            },

            render: function() {
                this.$el.empty();
                this.$el.html(this.templates.body());

                this._instructionBarView.setElement(this.locate('instruction'));
                this._instructionBarView.render();
                this._instructionBarViewBottom.setElement(this.locate('instructionNoText'));
                this._instructionBarViewBottom.render();

                this._reorderView.setElement(this.locate('body'));
                this._reorderView.render();

                return this;
            },

            onDestroy: function() {
                this._instructionBarView.destroy();
                this._instructionBarViewBottom.destroy();
                this._reorderView.destroy();
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.ReorderCollectionView',
    dependencies: ['jQuery.fn.sortable'],
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'UXF.Common.CollectionView',
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Views.QuestionRowView',
        'UXF.AssessmentBuilder.Services.Builder',
        'UXF.Common.EventBus'
    ],
    initFunc: function($, Backbone, _, CollectionView, Templates, QuestionRowView, builderService, EventBus) {
        'use strict';

        var View;

        View = CollectionView.extend({
            options: {
                template: Templates['reorder-collection-view'],
                collectionName: 'questions',
                viewClass: QuestionRowView,
                viewName: 'QuestionReorderView',
                containerSelector: 'questions'
            },
            selectors: {
                questions: '.uxf-reorder-list'
            },

            initialize: function() {
                if (!this.model) {
                    throw 'Assessment model is required';
                }

                if (!_.isUndefined(this.model.get('questions'))) {
                    var questions = this.model.get('questions');
                    questions.models = _.filter(questions.models, function(model) {
                        return model.newPosition >= 0;
                    });
                    _.each(questions.models, function(model) {
                        model.set('position', model.newPosition);
                    });

                    this.model.set('questions', questions);
                }

                EventBus.on('assessment-builder:update-new-questionList', this._putNewQuestionsListToDB, this);
            },

            preRenderChildren: function(collection) {
                // remove any new but incomplete question
                collection.each(function(question) {
                    if (question.isNew()) {
                        this.model.get('questions').remove(question);
                    }
                }, this);
            },

            postRenderChildren: function(collection) {
                this._enableSorting();
            },

            _enableSorting: function() {
                var sortableElem = this.locate('questions');
                sortableElem.sortable({
                    placeholder: 'placeholder',
                    opacity: 0.6,
                    scroll: false,
                    containment: 'document'
                });

                // need to bind this after rendering, but only once
                if (!this.$el._boundToSortUpdateEvent) {
                    this.$el.bind('sortupdate', this, _.bind(this._updateModelAfterSort, this));
                    this.$el.bind('sortstart', this, _.bind(this._sortStart, this));
                    this.$el._boundToSortUpdateEvent = true;
                }
            },

            _getOrderedIds: function() {
                var sortableElem = this.locate('questions'),
                    orderedIds = sortableElem.sortable('toArray');
                return _.map(orderedIds, function(id) {
                    return id.split('_')[1];
                });
            },

            /**
             * Store the initial position of the Question being dragged.
             */
            _sortStart: function(e, ui) {
                var el = ui.item;
                e.data._startPosition = e.data.locate('questions').children().index(el);
            },

            _putNewQuestionsListToDB: function(s) {
                var promise,
                    questionsList = this.model.get('questions').models,
                    self = this,
                    isQuestionListChanged = false,
                    questionListLength = this.model.get('questions').length;

                questionsList = builderService().getQuestionIdList(questionsList);

                isQuestionListChanged = questionsList.length !== questionListLength;

                promise = builderService().execute('commitChanges', this);
                return promise.then(function() {
                    var savePromise;
                    savePromise = builderService().putQuestionsInAssessment(self.model.get('id'), questionsList,
                        isQuestionListChanged);
                    savePromise.then(function(data) {
                        EventBus.trigger('assessment-builder:publish-event', {
                            event: 'builder-question:put:success',
                            data: 'success'
                        });
                    });
                });
            },

            /**
             * After question is dragged, we mimic the change on the
             * screen in the Collection by removing the question and
             * adding it back in its new position
             */
            _updateModelAfterSort: function(e, ui) {
                var promise,
                    el = ui.item,
                    startPosition = e.data._startPosition,
                    newPosition = e.data.locate('questions').children().index(el),
                    questionCollection = e.data.model.get('questions'),
                    question = questionCollection.at(startPosition);

                // no update necessary if the position is not changing
                if (startPosition === newPosition) {
                    return;
                }

                // remove the question from the collection in its old position
                questionCollection.remove(question, {
                    silent: true
                });

                // add the question back into the collection in its new position
                question.set('position', newPosition + 1);
                questionCollection.add(question, {
                    at: newPosition,
                    silent: true
                });

                // renumber the questions
                questionCollection._renumberQuestions();

                // notify the client of the new order

                promise = builderService().reorder(this.model.get('id'), this._getOrderedIds());
                promise.then(function() {
                    // todo?
                });
            },

            onDestroy: function() {
                if (this.$el) {
                    this.$el.unbind();
                }
                EventBus.off('assessment-builder:update-new-questionList', this._putNewQuestionsListToDB, this);
            }

        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.ResponseProxyView',
    initArgs: ['jQuery', '_', 'debug', 'Backbone', 'UXF.Common.AbstractView'],
    initFunc: function($, _, debug, Backbone, AbstractView) {
        'use strict';

        var View;

        View = AbstractView.extend({
            options: {
                textOptionViewClass: undefined,
                griddedResponseViewClass: undefined,
                // default methods for fetching the options.  If you need to provide
                // custom options to the view, override these methods.  Feels ugly.
                // may want to redesign this a bit.
                getTextOptionViewOptions: function(model) { return {model: model}; },
                getGriddedResponseViewOptions: function(model) { return {model: model}; },

                // the list of methods that need to be proxied
                textOptionMethods: ['destroyEditor', 'setEditMode', 'showRemoveLink'],
                griddedResponseMethods: ['validateCorrectValue'],
                ckeditorSkin: undefined
            },
            _currentView: undefined,
            _proxiedMethods: undefined,

            initialize: function() {
                if (!this.options.textOptionViewClass && !this.options.griddedResponseViewClass) {
                    debug.error('One of textOptionViewClass or GriddedResponseViewClass must be provided');
                    throw new Error('One of textOptionViewClass or GriddedResponseViewClass must be provided');
                }

                if (!this.model) {
                    debug.error('View must be configured with a valid model');
                    throw new Error('View must be configured with a valid model');
                }

                this.listen(this.model, 'change:responseType', this._responseTypeChanged, this);
                this._responseTypeChanged();  // initialize to the correct view type based on the model...
            },

            render: function() {
                if (!this._currentView) {
                    debug.error('Current view has not been correctly configured');
                    throw new Error('Current view has not been correctly configured');
                }

                this._currentView.render();
                return this;
            },

            _responseTypeChanged: function() {
                var opts, view, proxyMethods;

                this._destroyCurrent();

                view = this.model.get('responseType');
                if (view === 'gridded-response') {
                    opts = this.options.getGriddedResponseViewOptions(this.model);
                    this._currentView = this.options.griddedResponseViewClass.newInstance(this, opts);
                    proxyMethods = this.options.griddedResponseMethods;
                } else {
                    opts = this.options.getTextOptionViewOptions(this.model);
                    this._currentView = this.options.textOptionViewClass.newInstance(this, opts);
                    proxyMethods = this.options.textOptionMethods;
                }

                if (this._currentView.className) {
                    this.$el.addClass(this._currentView.className);
                }
                this._setupProxyMethods(proxyMethods);
                this.listen(this._currentView, 'all', this._replayEvents, this);
                this._currentView.setElement(this.$el);

                this.render();
            },

            _replayEvents: function(eventName, event) {
                this.trigger(eventName, event);
            },

            _destroyCurrent: function() {
                if (this._currentView) {
                    if (this._currentView.className) {
                        this.$el.removeClass(this._currentView.className);
                    }
                    this.unlisten(this._currentView, 'all', this._replayEvents, this);
                    this._currentView.destroy();
                    this._currentView = null;
                }
            },

            _setupProxyMethods: function(methods) {
                // drop all existing proxied methods...
                this._dropProxyMethods();
                // proxy each method for the new view...  Basically just creates
                // a small wrapper function that calls the real method on the
                // proxied view with the correct context if the function actually
                // exists
                _.each(methods, function(val) {
                    this[val] = function() {
                        if (_.isFunction(this._currentView[val])) {
                            return this._currentView[val].apply(this._currentView, arguments);
                        }

                        throw new Error('invalid proxy method defined: ' + val);
                    };
                }, this);
                // keep track of which methods are proxied...
                this._proxiedMethods = methods;
            },

            _dropProxyMethods: function() {
                if (this._proxiedMethods) {
                    _.each(this._proxiedMethods, function(val) {
                        if (_.isFunction(this[val])) {
                            this[val] = undefined;
                        }
                    }, this);
                    this._proxiedMethods = null;
                }
            },

            onDestroy: function() {
                this._dropProxyMethods();
                this._destroyCurrent();
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.ResponseView',
    dependencies: ['jQuery.fn.ckeditor'],
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'UXF.Common.i18n',
        'UXF.Common.AbstractView',
        'UXF.Common.QuickLinksView',
        'UXF.Common.BrowserUtils',
        'UXF.Common.EventBus',
        'debug',
        'UXF.AssessmentBuilder.Config',
        'UXF.Assessment.Services.AudioPlayerService'
    ],
    initFunc: function($, Backbone, _, i18n, AbstractView, QuickLinksView, browserUtils,
                 EventBus, debug, config, AudioPlayerService) {
        'use strict';

        var View, viewTemplate, editTemplate;

        viewTemplate = [
            '<div class="uxf-response-audio-player uxf-audio-player" style="display: none;">',
                '<a href="javascript://"><i class="uxf-icon-audio"></i>',
                    '<%__ "assessment-builder.audio.listen" %>',
                '</a>',
            '</div>',
            // div for showing the green arrow next to the correct response.
            '<% if (score !== 0) { %>',
                '<div class="uxf-response-correct uxf-response-score">',
                    '<i class="icon-ok-sign"></i>',
                '</div>',
            '<% } else { %>',
                '<div class="uxf-response-incorrect uxf-response-score"></div>',
            '<% } %>',

            // all other response info...
            '<div class="uxf-response-content">',
                '<div class="uxf-answer">',
                    '<span class="uxf-response-label">',

                        '<%__ "assessment-builder.response.label-format", [ label ] %>',
                    '</span>',
                    '<div class="uxf-response-text"><%= text %></div>',
                '</div>',
                '<% if (showFeedback && feedback) { %>',
                    '<div class="uxf-feedback">',
                        '<span class="uxf-response-label">',
                            '<%__ "assessment-builder.response.feedback" %>',
                        '</span>',
                        '<span class="uxf-feedback-text"><%= feedback %></span>',
                    '</div>',
                '<% } %>',
            '</div>'
        ].join('');

        editTemplate = [
            '<div class="uxf-answer">',
                '<div class="uxf-radio-wrapper">',
                    '<input id="<%= labelId %>" type="radio" name="answerRadioGroup" role="group"/>',
                    '<label for="<%= labelId %>" class="uxf-response-answer-label">',
                    '</label>',
                '</div>',
                '<label for="<%= labelId %>" class="uxf-a11yOffScreen"></label>',
                '<div class="uxf-field-wrapper">',
                    '<div class="uxf-editor-preview" tabindex="0">',
                        '<%= text %>',
                    '</div>',
                '</div>',
                '<div class="uxf-answer-controls"></div>',
                '<span class="uxf-field-validation-error"></span>',
            '</div>',

            '<% if (showFeedback) { %>',
            '<div class="uxf-clear"></div>',
                '<div class="uxf-feedback">',
                    '<label class="uxf-question-label-feedback"><%__ "assessment-builder.response.feedback" %></label>',
                    '<span class="uxf-field-validation-error"></span>',
                    '<div class="uxf-field-wrapper">',
                        '<div class="uxf-editor-preview" tabindex="0">',
                            '<%= feedback %>',
                        '</div>',
                    '</div>',
                '</div>',
            '<% } %>',
            '<div class="uxf-clear"></div>'
        ].join('');

        View = AbstractView.extend({
            tagName: 'div',
            className: 'uxf-response',
            options: {
                editMode: false,
                answerCharacterMax: 130,
                feedbackCharacterMax: 40,
                showFeedback: true,
                assessmentId: null,
                editorUpload: true,
                ckeditorSkin: undefined
            },
            templates: {
                view: viewTemplate,
                edit: editTemplate
            },
            events: {
                'click .uxf-answer .uxf-radio-wrapper' : '_radioClicked',
                'focus .uxf-answer .uxf-editor-preview': '_answerPreviewFocused',
                'focus .uxf-feedback .uxf-editor-preview': '_feedbackPreviewFocused',
                'click .uxf-response-audio-player a:first': '_playAudio'
            },
            classes: {
                editMode: 'uxf-response-edit-mode',
                viewMode: 'uxf-response-view-mode'
            },
            // special locator mappings to allow for configurable class names.
            // use the locate() method instead of hitting these directly
            selectors: {
                score: '.uxf-response-score',
                response: '.uxf-response-text',
                correctResponse: '.uxf-response-correct',
                incorrectResponse: '.uxf-response-incorrect',
                feedback: '.uxf-feedback-text',
                feedbackPreview: '.uxf-feedback .uxf-editor-preview',
                label: '.uxf-answer .uxf-response-label',
                answerCharacterCounter: '.uxf-answer .uxf-character-counter',
                feedbackCharacterCounter: '.uxf-feedback .uxf-character-counter',
                editorPreview: '.uxf-editor-preview',
                answerError: '.uxf-answer .uxf-field-validation-error',
                feedbackError: '.uxf-feedback .uxf-field-validation-error',
                answerControls: '.uxf-answer-controls',
                removeLink: function() { return this._quickLinksAnswers.$('.icon-remove-sign').parent(); },
                responseAudioPlayer: '.uxf-response-audio-player'
            },
            localize: {
                characterMax: 'assessment-builder.question.characterMax',
                optional: 'assessment-builder.feedback.optional'
            },
            initialize: function() {
                if (!this.model) {
                    throw 'ResponseView must be initialized with a model';
                }

                this._quickLinksAnswers = QuickLinksView.newInstance(this, {
                    links: [
                        {
                            label: ' ',
                            className: 'icon-trash',
                            event: 'remove'
                        }
                    ]
                });

                // need to handle each field individually or it causes ckeditor badness.
                this.listen(this.model, 'change:text', this._setText, this);
                this.listen(this.model, 'change:feedback', this._setFeedback, this);
                this.listen(this.model, 'change:score', this._setCorrectResponse, this);
                this.listen(this.model, 'validation', this._showValidation, this);
                EventBus.on('assessment-builder:feedback-supported', this._feedbackSupported, this);

                this._showFeedback = this.options.showFeedback;

                this.listen(this._quickLinksAnswers, 'remove', this._removeAnswerClicked, this);
            },

            /**
             * Event handler for "play response link" quick link
             */
            _playAudio: function(evt) {
                var audioType = this.model.get('audioType'), audioId =  this.model.get('audioId'),
                             audioAssessmentId = this.model.get('audioAssessmentId');
                AudioPlayerService.play(audioType, audioId, audioAssessmentId);
            },

            _removeAnswerClicked: function(e) {
                // bubble up
                this.trigger('remove', this.model);
            },

            showRemoveLink: function(enabled) {
                if (enabled === true) {
                    //this.locate("removeLink").show();
                    /* Doesn't work for IE when the value should be 'inline-block'. */
                    this.locate('removeLink').css('display', 'inline-block');
                } else {
                    this.locate('removeLink').hide();
                }
            },

            setEditMode: function(val, opts) {
                this.options.editMode = val;

                if (!opts || !opts.silent) {
                    this.render();
                }
            },

            isEditMode: function() {
                return this.options.editMode;
            },

            /**
             * Create a rich text editor instance
             * @param targetEl - any block-level element to be replaced with an editor
             */
            enableEditor: function(targetEl, field) {
                var self = this,
                    assessmentId = this.options.assessmentId,
                    toolbarList,
                    editorParams,
                    customAlert;

                this.destroyEditor();

                // remove the 'optional' text before showing the editor...
                if (field === 'feedback' && !this.model.get('feedback')) {
                    $(targetEl).empty();
                }

                this.trigger('editor-enabled', this);

                customAlert = function(txt) {
                    EventBus.trigger('assessment-builder:ckeditor:alert', txt);
                };

                toolbarList = (this.options.editorUpload === true && field !== 'feedback' &&
                    browserUtils.getHostOS() !== 'iPad') ? [['Bold', 'Italic', 'Underline', '-' , 'Image']] :
                    [['Bold', 'Italic', 'Underline']];

                editorParams = {
                    alert: customAlert,
                    toolbarCanCollapse: false,
                    toolbarStartupExpanded: true, // default
                    toolbar: 'TestBuilder',
                    toolbar_TestBuilder: toolbarList,
                    filebrowserImageBrowseUrl: null,
                    filebrowserImageUploadUrl: config('contextPath') + '/assessment/' + assessmentId +
                                                '/imageSource/response/',
                    removePlugins: 'elementspath,resize',
                    forcePasteAsPlainText: true,
                    removeDialogTabs: 'image:Link',
                    resize_enabled: false,
                    resize_dir: 'vertical',
                    autoGrow_onStartup: true,
                    extraPlugins: 'autogrow',
                    autoGrow_minHeight: 75,
                    autoGrow_maxHeight: 300,
                    height: $(targetEl).height(),
                    startupFocus: true,
                    language: i18n.getLang(),
                    enterMode: 2   // this prevents the content from being wrapped in <p>...</p>
                };

                if (this.options.ckeditorSkin) {
                    editorParams.skin = this.options.ckeditorSkin;
                }

                this._editorInstance = $(targetEl).ckeditor(editorParams).ckeditorGet();
                this._editorInstance._response_field = field;

                // update character count immediately
                this._onEditorChange();

                this._editorInstance.on('instanceReady', function(evt) {
                    this.document.on('keyup', function() {
                        self._onEditorChange($(self._editorInstance.element.$));
                    });
                });

            },

            /**
             * Set skip save to true if you want to close without saving to the model.
             * We do this during render to avoid ckeditor errors.
             */
            destroyEditor: function(cancelEdit) {
                var txt, isEmpty = false, isEditingAnswer = this._isEditingAnswer();

                // make sure cancelEdit is defined
                cancelEdit = (cancelEdit ? true : false);

                if (this._editorInstance) {
                    // cancelEdit is to avoid errors in certain instances
                    if (cancelEdit) {
                        this._editorInstance.resetDirty();
                    } else {
                        isEmpty = browserUtils.isCkEditorFieldEmpty(this.$el);

                        txt = isEmpty ? '' : $.trim(this._editorInstance.getData());
                        if (isEditingAnswer) {
                            this.model.set('text', txt);
                        } else {
                            // need to force the change event to fire even if setting
                            // the feedback to the same value.
                            this.model.set('feedback', null, { unset: true, silent: true });
                            this.model.set('feedback', txt);
                        }
                    }
                    this._editorInstance.destroy();
                }

                this._editorInstance = null;
                // Next statement is to make sure the 'Optional' text gets put into the Feedback text box
                // should the user clear the feedback.
                if (isEditingAnswer !== undefined && isEditingAnswer !== null && !isEditingAnswer &&
                        this.model !== null && !this.model.get('feedback')) {
                    this._setFeedback();
                }
            },

            _isEditingAnswer: function() {
                return this._editorInstance && this._editorInstance._response_field === 'answer';
            },

            _radioClicked: function() {
                this.model.setAsCorrect();
            },

            /**
             * Handle the focus eventd and replace the target with a rich text editor
             */
            _answerPreviewFocused: function(e) {
                this.enableEditor(e.currentTarget, 'answer');
            },

            _feedbackPreviewFocused: function(e) {
                this.enableEditor(e.currentTarget, 'feedback');
            },

            _onEditorChange: function(e) {
                var source = this._editorInstance.getData(),
                    selector = this._isEditingAnswer() ? 'answer' : 'feedback';

                this._updateCharacterCount(source, selector);
            },

            _updateCharacterCount: function(source, type) {
                var text = $.trim($('<div>' + source + '</div>').text()),
                    count = text.length,
                    max = type === 'feedback' ? this.options.feedbackCharacterMax : this.options.answerCharacterMax,
                    maxMsg = this.localize.characterMax([count, max]),
                    selector = type === 'feedback' ? 'feedbackCharacterCounter' : 'answerCharacterCounter';

                this.locate(selector).html(maxMsg);
            },

            _showValidation: function(e) {
                if (this.isEditMode && e) {
                    this.locate('answerError').css('visibility', (e.isTextValid ? 'hidden' : 'visible'));
                    this.locate('feedbackError').css('visibility', (e.isFeedbackValid ? 'hidden' : 'visible'));
                }
            },

            _clearValidation: function() {
                this.locate('answerError').css('visibility', 'hidden');
                this.locate('feedbackError').css('visibility', 'hidden');
            },

            _setText: function() {
                this.locate('response').html(this.model.get('text'));
            },

            _setFeedback: function() {
                var el = this.options.editMode ? this.locate('feedbackPreview') : this.locate('feedback'),
                    txt = this.model.get('feedback');

                el.removeClass('uxf-watermark');
                if (!txt && this.options.editMode) {
                    el.addClass('uxf-watermark');
                }

                el.html(txt);
            },

            _setCorrectResponse: function() {
                if (this.model.isCorrect()) {
                    this.$el.find('.answerRadio').addClass('selected');
                    this.$el.find('input[type=radio]').attr('checked', true);
                } else {
                    this.$el.find('.answerRadio').removeClass('selected');
                    this.$el.find('input[type=radio]').attr('checked', false);
                }
            },

            render: function() {
                var template, model;

                template = this.templates.view;

                if (this.options.editMode) {
                    template = this.templates.edit;
                    this.$el.removeClass(this.classes.viewMode).addClass(this.classes.editMode);
                } else {
                    // make sure the editor is not around for view mode.
                    this.destroyEditor();
                    this.$el.removeClass(this.classes.editMode).addClass(this.classes.viewMode);
                }

                this.undelegateEvents();
                model = this.model.toJSON();
                if (model.id !== null) {
                    model.labelId = model.id;
                } else {
                    model.labelId = this.model.cid;
                }
                this.$el.html(template(_.extend({}, model, {
                    showFeedback: this._showFeedback
                })));
                this.delegateEvents();

                if (this.options.editMode) {
                    this._updateCharacterCount(this.model.get('text'), 'answer');
                    this._updateCharacterCount(this.model.get('feedback'), 'feedback');

                    this._quickLinksAnswers.setElement(this.locate('answerControls'));
                    this._quickLinksAnswers.render();

                    // Hide the remove link immediately on rendering - it will be shown as needed by the parent view.
                    // This prevents the link from being shown (and clickable) while the parent view is processing.
                    this.showRemoveLink(false);
                } else {
                    if (this.model.hasAudio()) {
                        this.locate('responseAudioPlayer').show();
                    }
                }

                // could do this in the template, but this is much easier...
                this._setFeedback();
                this._setCorrectResponse();

                this._clearValidation();

                // Removed this and replaced with direct calls
                // to undelegate and delegate events above to try to free
                // up Radio Buttons which were getting held in memory after destroy
                // Backbone - establish new el as the el.
                // this.setElement(this.$el);

                return this;
            },

            _feedbackSupported: function(supported) {
                if (supported !== this._showFeedback) {
                    this._showFeedback = supported;
                    this.render();
                }
            },

            onDestroy: function() {
                EventBus.off('assessment-builder:feedback-supported', this._feedbackSupported, this);

                this.destroyEditor(true);
                this._quickLinksAnswers.destroy();
                this._quickLinksAnswers = null;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.SkillCollectionView',
    initArgs: [
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.CollectionView',
        'UXF.AssessmentBuilder.Views.SkillView'
    ],
    initFunc: function($, Backbone, _, debug, CollectionView, SkillView) {
        'use strict';

        var View,
            skillTemplate = [
                '<div>',
                    '<span class="uxf-question-label-skill">' +
                        '<%__ "assessment-builder.question.skills.header" %></span>',
                '</div>',
                '<div class="uxf-skill-collection-list"></div>',
                '<div class="uxf-skill-default-msg"><%__ "assessment-builder.question.skills.help" %></div>'
                ].join('');

        View = CollectionView.extend({

            options: {
                template: skillTemplate,
                collectionName: 'skillDetails',
                viewClass: SkillView,
                viewName: 'SkillView',
                containerSelector: 'skillDetails'
            },

            events: {
                'click .remove': '_removeSkill',
                'click .undo': '_undoRemoveSkill'
            },

            classes: {
                skillDetails: 'uxf-skill-collection-list',
                defaultSkillsMsg: 'uxf-skill-default-msg'
            },

            selectors: {
                skillDetails: 'skillDetails',
                defaultSkillsMsg: 'defaultSkillsMsg'
            },

            initialize: function() {
                if (!this.model) {
                    debug.error('SkillModelCollection is required');
                    throw new Error('SkillModelCollection is required');
                }
            },

            _renderTemplate: function(template, model) {
                CollectionView.prototype._renderTemplate.apply(this, [template, model]);
                if (model.get('skillDetails').length === 0) {
                    this.locate('skillDetails').hide();
                } else {
                    this.locate('defaultSkillsMsg').hide();
                }
            },

            onChildViewCreated: function(view) {
                this.listen(view, 'remove', this._removeSkill, this);
                this.listen(view, 'undo', this._undoRemoveSkill, this);
            },

            onChildViewDestroyed: function(view) {
                this.unlisten(view, 'remove', this._removeSkill, this);
                this.unlisten(view, 'undo', this._undoRemoveSkill, this);
            },

            _removeSkill: function(model) {
                model.setFlaggedForRemoval(true);
            },

            _undoRemoveSkill: function(model) {
                model.setFlaggedForRemoval(false);
            },

            clearSkillsFlaggedForRemoval: function() {
                this.model.get('skillDetails').each(function(skill) {
                    skill.setFlaggedForRemoval(false);
                });
            }

        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }

});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.SkillView',
    dependencies: ['jQuery.fn.ckeditor'],
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.Common.AbstractView', 'UXF.Common.QuickLinksView', 'debug'],
    initFunc: function($, Backbone, _, AbstractView, QuickLinksView, debug) {
        'use strict';

        var View, editTemplate, editUnDoTemplate;

        editTemplate = [
            '<div><hr />',
            '<span class="uxf-skill-description"><%= description %></span>',
            '</div>',
            '<div class="uxf-skill-controls"></div>'
        ].join('');

        editUnDoTemplate = [
            '<div><hr />',
                '<span class="uxf-skill-undo-remove-skill">' +
                    '<%__ "assessment-builder.question.undo-remove-skill.caption" %><%= description %></span>',
            '</div>',
            '<div class="uxf-skill-undo-controls"></div>'
        ].join('');

        View = AbstractView.extend({
            tagName: 'div',
            className: 'uxf-question-skill',

            options: {
                editMode: true
            },

            templates: {
                edit: editTemplate,
                undo: editUnDoTemplate
            },

            events: {
                'click .remove': '_removeSkillClicked',
                'click .undo': '_undoRemoveSkillClicked'
            },

            classes: {
                editMode: 'uxf-skill-edit-mode'
            },

            selectors: {
                skill: '.uxf-skill-description',
                undoSkill: '.uxf-skill-undo-remove-skill',
                skillControls: '.uxf-skill-controls',
                skillUnDoControls: '.uxf-skill-undo-controls',
                removeLink: function() {
                    return this._quicklinksSkills.$('.icon-remove-sign').parent();
                },
                undoLink: function() {
                    return this._quicklinksSkillsUndo.$('.icon-undo').parent();
                }
            },

            initialize: function() {
                if (!this.model) {
                    throw 'SkillView must be initialized with a model';
                }

                this._quicklinksSkills = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.remove-skill',
                        className: 'icon-remove-sign',
                        event: 'remove'
                    }]
                });

                this._quicklinksSkillsUndo = QuickLinksView.newInstance(this, {
                    links: [{
                        label: 'assessment-builder.question.undo-remove-skill',
                        className: 'icon-undo',
                        event: 'undo'
                    }]
                });

                this.listen(this._quicklinksSkills, 'remove', this._removeSkillClicked, this);
                this.listen(this._quicklinksSkillsUndo, 'undo', this._undoRemoveSkillClicked, this);
                this.listen(this.model, 'change', this.render, this);
            },

            _removeSkillClicked: function(e) {
                // bubble up
                this.trigger('remove', this.model);
            },

            _undoRemoveSkillClicked: function(e) {
                // bubble up
                this.trigger('undo', this.model);
            },

            // 0 - template with remove link will be displayed, 1 - template with undo-remove link will be displayed
            render: function() {
                var template = this.templates.view;
                if (false === this.model.get('isFlaggedForRemoval')) {
                    template = this.templates.edit;
                } else {
                    template = this.templates.undo;
                }
                this.$el.removeClass(this.classes.viewMode).addClass(this.classes.editMode);
                this.$el.html(template(this.model.toJSON()));
                // Backbone - establish new el as the el.
                this.setElement(this.el);
                if (false === this.model.get('isFlaggedForRemoval')) {
                    this._quicklinksSkills.setElement(this.locate('skillControls'));
                    this._quicklinksSkills.render();
                } else {
                    this._quicklinksSkillsUndo.setElement(this.locate('skillUnDoControls'));
                    this._quicklinksSkillsUndo.render();
                }

                return this;
            },

            onDestroy: function() {
                this._quicklinksSkills.destroy();
                this._quicklinksSkills = null;
                this._quicklinksSkillsUndo.destroy();
                this._quicklinksSkillsUndo = null;
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Views.XmlQuestionView',
    initArgs: [
        'angular',
        'jQuery',
        'Backbone',
        '_',
        'debug',
        'UXF.Common.AbstractView'
    ],
    initFunc: function(angular, $, Backbone, _, debug, AbstractView) {
        'use strict';

        var View, scope;

        View = AbstractView.extend({
            templates: {
                body: '<div class="uxf-question-preview-container"></div>',
                xmlQuestion: '<div class="uxf-xml-question-view" uxf-assessment-question-preview ' +
                    'question-id="{{ questionId }}" session-id="{{ sessionId }}" sequence="{{ sequence }}" ' +
                    'paf="{{ paf }}" position="{{ position }}" player-height="{{ playerHeight }}"></div>'
            },
            selectors: {
                preview: '.uxf-question-preview-container'
            },
            initialize: function() {
                if (!this.model) {
                    throw 'XmlQuestionView must be initialized with a model';
                }
            },
            render: function() {
                var self = this;
                this.$el.empty();
                this.$el.html(this.templates.body());

                angular.element(self.selectors.preview, self.$el).injector().invoke([
                        '$compile',
                        '$log',
                        function($compile, $log) {
                            //Insert angular magic
                            var el = angular.element(self.templates.xmlQuestion());

                            angular.element(self.selectors.preview, self.$el).empty().append(el);
                            scope = el.scope().$new(true);
                            angular.extend(scope, {
                                sessionId: self.options.previewSession,
                                sequence: self.options.sequence,
                                questionId: self.model.get('pafId'),
                                paf: self.model.get('isPaf'),
                                position: self.model.get('position'),
                                playerHeight: '426px'
                            });

                            $compile(el)(scope);
                        }
                ]);

                return this;
            },

            onDestroy: function() {
                if (scope) {
                    scope.$destroy();
                    scope = null;
                }
                this.$el.empty(); //remove the inserted element
            }
        });

        View.newInstance = function(parent, opts) {
            return new View(parent, opts);
        };

        return View;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Widget.AssessmentBuilder',
    dependencies: ['jQuery.widget'],
    initArgs: [
        'jQuery',
        '_',
        'debug',
        'UXF.Common.EventBus',
        'UXF.AssessmentBuilder.Models.AssessmentModel',
        'UXF.AssessmentBuilder.Views.AssessmentBuilderView',
        'UXF.AssessmentBuilder.Views.PrintView',
        'UXF.Assessment.Services.AudioPlayerService'
    ],
    initFunc: function($, _, debug, EventBus, AssessmentModel, AssessmentBuilder, PrintView, AudioPlayerService) {
        'use strict';

        var overlay = {
            init: function() {
                var overlay;
                if ($('#uxf-overlay').length === 0) {
                    overlay = $('<div id="uxf-overlay"/>');
                    $('body').append(overlay);
                } else {
                    overlay = $('#uxf-overlay');
                }

                overlay.hide();
            },

            destroy: function() {
                $('#uxf-overlay').remove();
            },

            show: function() {
                $('#uxf-overlay').show();
            },

            hide: function() {
                $('#uxf-overlay').hide();
            }
        };

        $.widget('ui.assessmentBuilder', {
            options: {
                assessment: null,
                mode: null,
                isReadOnly: false,
                restPath: '/assessment',
                fixedHeaderHeight: 0,
                // user of the builder widget (e.g. the angular directive) should register a function
                // to receive callback events for validation errors
                callbackFn: $.noop,
                useDropdownForAddQuestion: false,
                navigationFn: $.noop,
                includeSkills: true,
                includeExtendedHeader: true,
                ckeditorSkin: undefined,
                dialogCallbackFn: null,
                overlayService: overlay,
                create: false,
                program: null,
                defaultThumbnailURL: null,
                includeQuestionBankSupport: true,
                allowTitleUpdate: true
            },

            _create: function() {
                EventBus.on('assessment-builder:show-alert', this._onAlert, this);
                EventBus.on('assessment-builder:publish-event', this._publishEvent, this);
                EventBus.on('assessment-builder:question-count-changed', this._questionCountChanged, this);
                EventBus.on('assessment-builder:question:enterEdit', this._questionEnterEdit, this);
                EventBus.on('assessment-builder:question:leaveEdit', this._questionLeaveEdit, this);

                if (!this.options.create) {
                    this._assessmentModel = AssessmentModel.newInstance(this.options.assessment);
                } else {
                    this._assessmentModel = AssessmentModel.newInstance();
                }

                this._setupDialogProxyAndOverlay();

                // would it be better to just put this in a different widget?
                switch (this.options.mode) {
                    case 'assessment_builder_print_test':
                    case 'assessment_builder_print_test_answer':
                        this._assessmentBuilderView = this._loadPreview(this._assessmentModel);
                    break;

                    default:
                        this._assessmentBuilderView = this._loadEditor(this._assessmentModel);

                        // make sure host app mode is in sync...
                        this._trigger('navigation', null, this._assessmentBuilderView.getCurrentMode());
                }

                this._assessmentBuilderView.render();

                this._trigger('onRender');
            },

            _setupDialogProxyAndOverlay: function() {
                var setupProxyButtonCallback,
                    proxiedDialogCallback,
                    self = this;

                // init the overlay that will protect against double-clicks
                // while waiting for user action from host app
                this.options.overlayService.init();

                // helper method to set up proxy for each button that will first
                // hide the overaly before continuing with original button callback
                setupProxyButtonCallback = function(container, buttonCallbackName) {
                    // proxy all calls to the dialog to first display overlay
                    var proxiedButtonCallback = container[buttonCallbackName];
                    container[buttonCallbackName] = function() {
                        self.options.overlayService.hide();
                        return proxiedButtonCallback.apply(this, arguments);
                    };
                };

                if (this.options.dialogCallbackFn) {

                    // any call to the host apps dialog function will be proxied
                    // to first show the overlay to protect against double-clicks
                    // and other clicks, as well as to hide the overlay when any
                    // button is clicked
                    proxiedDialogCallback = this.options.dialogCallbackFn;
                    this.options.dialogCallbackFn = function(dialogObj) {
                        self.options.overlayService.show();

                        setupProxyButtonCallback(dialogObj, 'closeClickHandler');
                        setupProxyButtonCallback(dialogObj, 'defaultClickHandler');

                        _.each(dialogObj.buttons, function(button, idx) {
                            setupProxyButtonCallback(button, 'clickHandler');
                        });

                        return proxiedDialogCallback.apply(this, arguments);
                    };
                }
            },

            _loadEditor: function(model, readOnlyFlag) {
                var self, view;

                self = this;
                view = AssessmentBuilder.newInstance(null, {
                    el: this.element,
                    model: model,
                    defaultMode: (this.options.create) ? 'create' : 'edit',
                    restPath: this.options.restPath,
                    fixedHeaderHeight: this.options.fixedHeaderHeight,
                    useDropdownForAddQuestion: this.options.useDropdownForAddQuestion,
                    includeSkills: this.options.includeSkills,
                    includeExtendedHeader: this.options.includeExtendedHeader,
                    ckeditorSkin: this.options.ckeditorSkin,
                    isReadOnly: this.options.isReadOnly,
                    program: this.options.program,
                    defaultThumbnailURL: this.options.defaultThumbnailURL,
                    includeQuestionBankSupport: this.options.includeQuestionBankSupport,
                    allowTitleUpdate: this.options.allowTitleUpdate
                });

                // not a good long-term solution...
                view.bind('assessment.builder:unsaved-edit:warning', this._unsavedEditWarning, this);
                view.bind('question:audio-warn', this._questionSaveAudioAlert, this);

                return view;
            },

            _loadPreview: function(model) {
                var view;

                view = PrintView.newInstance(null, {
                    el: this.element,
                    model: model,
                    answerKey: this.options.mode === 'assessment_builder_print_test_answer',
                    logoImgUrl: this.options.logoImgUrl,
                    correctResponseImgUrl: this.options.correctResponseImgUrl
                });

                return view;
            },

            setAssessment: function(assessment) {
                this.options.assessment = assessment;
                this._assessmentModel.set(assessment);
                this._assessmentModel.updateAddedQuestionIds();
            },

            setMode: function(mode) {
                this._assessmentBuilderView.setMode(mode);
            },

            /**
             * Helper method to get access to the top level view object.
             * @return the view
             */
            getBackboneView: function() {
                return this._assessmentBuilderView;
            },

            /**
             * Stops any audio that is currently playing
             */
            stopAudio: function() {
                AudioPlayerService.stop();
            },

            destroy: function() {
                // widget destroy must be called first in order to not make this take forever to run
                // In jQuery UI 1.8, you must invoke the destroy method from the base widget
                $.Widget.prototype.destroy.call(this);
                // In jQuery UI 1.9 and above, you would define _destroy instead of destroy and not call the base method

                EventBus.off('assessment-builder:show-alert');
                EventBus.off('assessment-builder:publish-event', this._publishEvent, this);
                EventBus.off('assessment-builder:question-count-changed', this._questionCountChanged, this);
                EventBus.off('assessment-builder:question:enterEdit', this._questionEnterEdit, this);
                EventBus.off('assessment-builder:question:leaveEdit', this._questionLeaveEdit, this);

                this.options.overlayService.destroy();

                if (this._assessmentBuilderView) {
                    this._assessmentBuilderView.destroy();
                }

                // must clear these out to free up memory
                this._assessmentBuilderView = null;
                this._assessmentModel = null;

                EventBus.destroyNamespace('assessment-builder');
            },

            _onNavigationRequest: function(page) {
                if (this.options.navigationFn) {
                    this.options.navigationFn(page);
                }
            },

            _publishEvent: function(evt) {
                this._trigger(evt.event, null, evt.data);
            },

            _questionCountChanged: function(evt) {
                this._trigger('builder-question:count:changed', null, evt.questionsSize);
            },
            _questionEnterEdit: function(evt) {
                this._trigger('assessment-builder:question:enterEdit', evt);
            },
            _questionLeaveEdit: function(evt) {
                this._trigger('assessment-builder:question:leaveEdit', evt);
            },

            _onAlert: function(data) {
                if (this.options.callbackFn) {
                    this.options.callbackFn(data.messageType, data.message, data.element);
                }
            },

            _questionSaveAudioAlert: function(audioWarnDialog) {
                // if the host app has supplied a callback, then
                // call it and pass the warn audioWarnDialog definition
                if (this.options.dialogCallbackFn) {
                    this.options.dialogCallbackFn(audioWarnDialog);

                    // if not, we'll just call the default handler
                    // to keep the save going until the handler is in place
                } else {
                    audioWarnDialog.defaultClickHandler();
                }
            },

            /*
             * Execute the host's callback function for warning of an unsaved question/ summary.
             * @param errorCode
             * @param i18nMsg - The default localized error message
             */
            _unsavedEditWarning: function(config) {
                if (this.options.dialogCallbackFn) {
                    this.options.dialogCallbackFn(config);
                } else {
                    config.defaultClickHandler();
                }
            }
        });

        return $.fn.assessmentBuilder;
    }
});
;


UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Config',
    initArgs: ['UXF.Common.ConfigFactory'],
    initFunc: function(configFactory) {
        'use strict';

        return configFactory();
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.AudioPlayer',
    initArgs: [
        'angular',
        'jQuery',
        'flowplayer',
        'UXF.AssessmentPlayer.Config',
        'UXF.Common.BrowserUtils',
        'debug',
        'UXF.Assessment.Services.AudioPlayerService'
    ],
    initFunc: function(angular, $, flowplayer, config, browserUtils, debug, AudioPlayerService) {
        'use strict';

        var module;

        /**
         * Grr.  Pearson media player plugin is very dependent on the file extension.
         * So, try to figure it out based on the type.
         * @param type
         * @return {String}
         */
        function getExtension(type) {
            switch (type ? type.toLowerCase() : '') {
                case 'audio/mp3':
                    return '.mp3';

                case 'audio/mp4':
                    return '.mp4';

                default:
                    return '';
            }
        }

        module = angular.module('AssessmentServices.Player.Directives.AudioPlayer',
                ['AssessmentServices.Player.Filters.i18n']);
        module.controller('AssessmentPlayerAudioController',
            ['$scope', 'AssessmentPlayerService', function($scope, service) {
                $scope.playAudio = function() {

                    if ($scope.src) {
                        AudioPlayerService.playAudioURL($scope.audioType, $scope.src);

                    } else {
                        AudioPlayerService.play($scope.audioType, $scope.uuid, $scope.audioAssessmentId);
                    }
                };
                /*
                 * Pause the audio when the user moves focus / navigates away from page.
                 */
                $scope.$on('preNavigationChange', function(event, currentPlayerState, responseObj) {

                    AudioPlayerService.stop();
                });
            }]);

        module.directive('uxfAudioLink', function() {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    audioAssessmentId: '=audioAssessmentId',
                    src: '@src',
                    uuid: '=uuid',
                    audioType: '=audioType',
                    /*
                     * wrapper for parent scope function to be invoked to report errors, e.g. validation error
                     */
                    playerErrorHandler: '&'
                },
                templateUrl: config('templateRoot') + '/audioplayer.html',
                controller: 'AssessmentPlayerAudioController',
                link: {
                    post: function(scope, elem, attrs) {
                        // init the service
                        AudioPlayerService.init({
                            flowplayerRoot: config('flowplayerRoot'),
                            contextPath: config('contextPath')
                        });
                        // create the audio player (a jquery widget will be created in the dom)
                        AudioPlayerService.createAudioPlayer();
                    }
                }
            };
        });

        return module;
    }
});

;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.NativeQuestionCommonService',
    initArgs: ['angular', '_'],
    initFunc: function(angular, _) {
        'use strict';

        var module, factory;

        module = angular.module('AssessmentServices.Player.Services.NativeQuestionCommonService', []);

        factory = module.factory('NativeQuestionCommonService', [
            'QUESTION_TYPES',
            '$filter',
            function(QUESTION_TYPES, $filter) {
                var ret = {};

                // This function has been used in the native-question-review.directive.js and question-directive.js
                ret.nativeQuestionHandler = function($scope, questionData) {
                    var i18n = $filter('uxfLocalize'),
                        hasResponse,
                        griddedResponse,
                        layout;

                    $scope.attempts = 0;
                    // for GR for completed assessment, should show 'wrong' icon next to the grid if not
                    // answered. so we'll set the default to wrong and update later (see below)
                    // if there are responses
                    $scope.attemptAnswer = (questionData.assessmentComplete ?
                        'uxf-griddedresponse-check-wrong' : 'null');
                    $scope.attemptFeedback = false;
                    $scope.question = questionData.question;
                    //default state of button is disabled
                    $scope.isCheckAnswerEnabled = false;
                    // set all response.isReadOnly flags in the responses to false if
                    // they are empty, since we use the value in the directive
                    angular.forEach(questionData.question.responses, function(response, indx) {
                        if (!response.isReadOnly) {
                            response.isReadOnly = false;
                        }
                    });
                    // Is the question readonly or not due to assessment submitted?
                    $scope.isQuestionReadOnly = $scope.isAssessmentSubmitted || questionData.answerCorrect ||
                        $scope.$parent.isTeacherInprogressReview;
                    if (!$scope.isQuestionReadOnly && questionData.previousResponses) {
                        // Is the question readonly or not due to max committed attempts?
                        angular.forEach(questionData.previousResponses, function(previousResponse, indx) {
                            $scope.attempts += previousResponse.isCommitted ? 1 : 0;
                        });

                        if ($scope.maxAttempts <= $scope.attempts) {
                            $scope.isQuestionReadOnly = true;
                        }
                    }

                    hasResponse = angular.isDefined(
                        _.findWhere(questionData.previousResponses, {
                            isAnswered: true
                        })
                    );

                    $scope.isQuestionUnanswered = questionData.assessmentComplete &&
                        (!questionData.previousResponses.length || !hasResponse);

                    //show the users committed answers and the correct answer to the question
                    switch ($scope.question.questionType.toLowerCase()) {
                        case QUESTION_TYPES.GRIDDED_RESPONSE:
                            if ($scope.isQuestionReadOnly && !questionData.answerCorrect &&
                                questionData.correctAnswer) {
                                $scope.attemptFeedback = i18n('assessment-player.question.correct-answer') +
                                    questionData.correctAnswer.responseValue.trim();
                            }
                            break;

                        case QUESTION_TYPES.MULTIPLE_CHOICE:
                            angular.forEach(questionData.previousResponses, function(previousResponse, indx) {
                                if (previousResponse.isCommitted && previousResponse.response &&
                                    angular.isDefined(previousResponse.response.position)) {
                                    //default all committed responses to be wrong
                                    // .i.e show the incorrect answer icon in the UI
                                    $scope.question
                                        .responses[previousResponse.response.position]
                                        .isAnswerCorrect = false;
                                    //the radio button is disabled once the answer has been revealed
                                    $scope.question
                                        .responses[previousResponse.response.position]
                                        .isReadOnly = true;
                                }
                            });
                            if ($scope.isQuestionReadOnly && questionData.correctAnswer) {
                                //select the correct response, possibly overwriting the flag for one of
                                //the above committed responses
                                $scope.question
                                    .responses[questionData.correctAnswer.position]
                                    .isAnswerCorrect = true;
                            }
                            break;
                    }

                    // must be in separate object or you run into scoping problems.
                    $scope.selection = {};
                    if (questionData.question.questionType === QUESTION_TYPES.GRIDDED_RESPONSE) {

                        griddedResponse = $scope.question.responses[0];

                        layout = griddedResponse.griddedResponseLayout;
                        layout.immutable = $scope.isQuestionReadOnly;

                        // gridded response questions have only one response object.
                        // since we differentiate GR responses (i.e., in
                        // wasResponseChanged()) by their text values, we don't need (or want)
                        // to differentiate on responseId.
                        // so we'll just set the current and previous responseId values to
                        // the one valid id, never to be changed.
                        $scope.selection.responseId = griddedResponse.id;
                        $scope.selection.originalResponseId = $scope.selection.responseId;

                        //re-initialize the widget for answering a gridded response type question
                        $scope.griddedResponse.init({
                            immutable: layout.immutable,
                            boxes: layout.boxes,
                            delim: layout.delim,
                            delimPosition: layout.delimPosition,
                            currencySymbol: layout.currencySymbol,
                            plusMinus: layout.plusMinus
                        });

                        $scope.griddedResponse.setValue('');

                        angular.forEach(questionData.previousResponses, function(previousResponse, idx) {
                            if (previousResponse.isCommitted) {
                                $scope.attemptAnswer = 'uxf-griddedresponse-check-' +
                                    (questionData.answerCorrect ? 'correct' : 'wrong');
                                return false;
                            }
                        });
                    }

                    $scope.selection.hasPreviousResponses =
                        (questionData.previousResponses && questionData.previousResponses[0]);
                    if ($scope.selection.hasPreviousResponses) {
                        switch ($scope.question.questionType) {
                            case QUESTION_TYPES.MULTIPLE_CHOICE:
                                if (questionData.previousResponses[0].response &&
                                    questionData.previousResponses[0].response.id) {
                                    $scope.selection.responseId = questionData.previousResponses[0].response.id;
                                    $scope.selection.originalResponseId =
                                        questionData.previousResponses[0].response.id;
                                }
                                break;

                            case QUESTION_TYPES.GRIDDED_RESPONSE:
                                if (questionData.previousResponses[0].responseValue) {
                                    $scope.selection.originalResponseText =
                                        questionData.previousResponses[0].responseValue;
                                    $scope.griddedResponse.setValue($scope.selection.originalResponseText);
                                }
                                break;
                        }

                        // The check answer button is enabled on question load if  an answer is submitted
                        // but not committed e.g. user selects a radio and hits Next/Previous
                        $scope.isCheckAnswerEnabled = !$scope.isQuestionReadOnly &&
                            (false === questionData.previousResponses[0].isCommitted);

                    } else {
                        switch ($scope.question.questionType) {
                            case QUESTION_TYPES.MULTIPLE_CHOICE:
                                $scope.selection.responseId = null;
                                $scope.selection.originalResponseId = null;
                                break;

                            case QUESTION_TYPES.GRIDDED_RESPONSE:
                                // for gridded response, if there is no previous response,
                                // set the originalResponseText to the default/empty value
                                // for the particular grid config (this will be used to detect
                                // whether the user has changed the value)
                                $scope.selection.originalResponseText = $scope.griddedResponse.getValue();
                                break;
                        }
                    }
                };

                return ret;
            }
        ]);
    }
});
;UXF.Module.define({
    dependencies: ['jQuery.fn.griddedResponse'],
    name: 'UXF.AssessmentPlayer.Directives.NativeQuestion',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'window', '_'],
    initFunc: function(angular, $, config, debug, window, _) {
        'use strict';

        var module;

        module = angular.module('AssessmentServices.Player.Directives.NativeQuestion', [
            'AssessmentServices.Player.Services.Player',
            'AssessmentServices.Player.Services.NativeQuestionCommonService'
        ]);
        module.controller('AssessmentNativeQuestionController', [
            '$scope',
            'AssessmentPlayerService',
            'QUESTION_TYPES',
            'NativeQuestionCommonService',
            function($scope, service, QUESTION_TYPES, NativeQuestionCommonService) {

                /*
                 * handler invoked only when question id changes.
                 *
                 */
                function questionHandler() {
                    // first reset the question - otherwise the previous question will be shown (briefly)
                    //  on the page while the new question is being retrieved
                    $scope.question = null;
                    service.question($scope.sessionId, $scope.questionId)
                        .then(function(data) {
                            NativeQuestionCommonService.nativeQuestionHandler($scope, data);
                        });
                }

                if ($scope.griddedResponse && $scope.question &&
                        $scope.question.questionType === QUESTION_TYPES.GRIDDED_RESPONSE) {
                    $scope.griddedResponse.setReadOnly(true);
                }

                $scope.isAssessmentSubmitted = true;

                questionHandler();

                $scope.isCorrectOrSelectedAnswer = function(response) {
                    return angular.isDefined(response.isAnswerCorrect);
                };

                $scope.getAnswerMessage = function(response) {
                    var label,
                        isUserSelectedAnswer = $scope.selection && $scope.selection.responseId === response.id,
                        isCurrentAnswerIncorrect = response.isAnswerCorrect === false;

                    label = isUserSelectedAnswer || isCurrentAnswerIncorrect ? 'submitted' : 'correct';

                    return 'assessment-player.question.answer.' + label + '.message';
                };

                /*
                 * Using the response's index position, create an alpha string for the response's label.
                 */
                $scope.responseLabel = function(answPosition) {
                    answPosition = answPosition || 0;
                    var newAnswLabel = String.fromCharCode((answPosition % 26) + 97).toUpperCase();
                    return newAnswLabel;
                };

                $scope.getMultipleChoiceTabIndex = function(responseId) {
                    var selectedId = !!$scope.selection.responseId ?
                        $scope.selection.responseId : $scope.question.responses[0].id;
                    return (selectedId === responseId) ? 0 : -1;
                };
            }
        ]);

        module.directive('uxfAssessmentPlayerNativeQuestion', [
                function() {
                    return {
                        restrict: 'E',
                        scope: {
                            questionId: '<',
                            sessionId: '<'
                        },
                        templateUrl: config('templateRoot') + '/native-question.html',
                        controller: 'AssessmentNativeQuestionController',
                        link: {
                            post: function(scope, element) {
                                var containerElement,
                                    setScopeGriddedResponse = function() {
                                        containerElement = $(element).find('.uxf-griddedresponse-widget-container');
                                        if (containerElement.length !== 0) {
                                            containerElement.griddedResponse({
                                                'response:change': scope.griddedResponseChangeCallback
                                            });

                                            scope.griddedResponse = {
                                                getValue: function() {
                                                    return containerElement.griddedResponse('getValue');
                                                },

                                                setValue: function(value) {
                                                    containerElement.griddedResponse('setValue', value);
                                                },

                                                setReadOnly: function(readOnly) {
                                                    containerElement.griddedResponse('setReadOnly', readOnly);
                                                },

                                                init: function(options) {
                                                    containerElement.griddedResponse('init', options);
                                                }
                                            };
                                        }
                                    };

                                setScopeGriddedResponse();
                            }
                        }
                    };
                }
        ]);

        return module;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.Player',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'window'],
    initFunc: function(angular, $, config, window) {
        'use strict';

        var module = angular.module('AssessmentServices.Player.Directives.Player', [
            'AssessmentServices.Player.Services.Player',
            'AssessmentServices.Player.Services.ActivityManager',
            'AssessmentServices.Player.Services.ItemPlayer'
        ]);

        module.controller('AssessmentServices.Player.Controllers.Player', [
            '$scope',
            '$filter',
            '$window',
            '$timeout',
            'AssessmentPlayerService',
            'ActivityManager',
            'ItemPlayerService',
            '$log',
            'QUESTION_STATUS',
            '$q',
            'BrowserUtil',
            function($scope, $filter, $window, $timeout, service, ActivityManager,
                ItemPlayerService, $log, QUESTION_STATUS, $q, BrowserUtil) {

                var initActivityManager,
                    keepAliveTimer = null,
                    fifteenMinutes = 15 * 60 * 1000,
                    fixLostHtml5MessagesForAnchorsOnIE,
                    isIncompleteTestSession = false,
                    isTestAlreadySubmitted = false,
                    emitRubricEvent;

                if (!$scope.styleWithFlexbox) {
                    $scope.playerBodyStyle = {
                        height: ($window.innerHeight - 110) + 'px'
                    };
                }

                //See http://connect.microsoft.com/IE/feedback/details/802397/
                //ie9-ie10-events-can-be-sent-to-the-wrong-listeners
                fixLostHtml5MessagesForAnchorsOnIE = function(event) {
                    if (event) {
                        event.preventDefault();
                    }
                };

                function preventResubmissionTest(sequenceNode) {
                    isIncompleteTestSession =
                        $scope.session && $scope.session.type === 'TEST' && $scope.session.status !== 'COMPLETE';

                    isTestAlreadySubmitted =
                        sequenceNode &&
                        sequenceNode.parentSequence &&
                        sequenceNode.parentSequence.sequenceResult &&
                        sequenceNode.parentSequence.sequenceResult.resultStatus &&
                        sequenceNode.parentSequence.sequenceResult.resultStatus ===
                        'Complete';

                    if (isIncompleteTestSession &&  isTestAlreadySubmitted) {
                        $scope.$emit('assessment-player.player-directive.preventResubmissionTest');
                        $log.log('Emit: assessment-player.player-directive.preventResubmissionTest');
                    }
                }

                function loadSplashScreen() {
                    $scope.playerState = 'splash';
                    $scope.reportLoading = false;
                    $scope.position = -1;
                    $scope.resizePlayerBody();
                }

                function loadQuestionScreen(position) {
                    $scope.displayedPage = position + 1;
                    $scope.reportLoading = false;
                    if ($scope.navigationForm && $scope.navigationForm.input) {
                        $scope.navigationForm.input.$setPristine();
                    }
                    $scope.playerState = 'question';
                    $scope.resizePlayerBody();
                    if (!$scope.isNativeTarget) {
                        //Check to see if already loading.  In theory we should never get here, but if we do
                        //it will cause issues so lets flag it.
                        if ($scope.isLoading && !$scope.isAdaptive) {
                            $log.log('Sorry, item is already loading.');
                            return;
                        }

                        var questionId = $scope.session.questionIds[position];
                        $scope.isLoading = true;
                        $scope.activityManager.hidePlayer();

                        $log.log('starting to load ', questionId);
                        $scope.activityManager.setSequence($scope.session.sequence);

                        return $scope.activityManager.playItem($scope.sessionId, questionId).then(
                            function(sequenceNode) {
                                var isReviewMode = function(parentSequence) {
                                    return parentSequence.activityMode === 'Review' || //TEMP for PAF-SIM
                                        (parentSequence.settings &&
                                        parentSequence.settings.reviewMode !== 'false') || //Another TEMP for PAF-SIM?
                                        (parentSequence.sequenceResult &&
                                        parentSequence.sequenceResult.resultStatus === 'Complete'); //PAF Apiary doc
                                },
                                showCorrectAnswers = function(parentSequence) {
                                    return isReviewMode(parentSequence) &&
                                        parentSequence.sequenceResult.showCorrectAnswers;
                                };
                                preventResubmissionTest(sequenceNode);
                                $scope.currentQuestionId = questionId;
                                $scope.position = position;
                                $scope.isLoading = false;
                                $scope.activityManager.showPlayer();
                                $scope.showCorrectAnswers = showCorrectAnswers(sequenceNode.parentSequence);
                                $scope.resizePlayerBody();
                                $scope.$broadcast('show-correct-answers-tab',
                                    {showCorrectAnswers: $scope.showCorrectAnswers});
                                preventResubmissionTest();

                                if (angular.isDefined(sequenceNode.rubric_guid)) {
                                    if ($scope.assessmentSubmitted) {
                                        service.getScoreSummaryAndSkills($scope.sessionId, $scope.session.sequence)
                                            .then(function(manualScoreSummary) {
                                                manualScoreSummary.questionScores
                                                    .some(function(question) {
                                                    if (sequenceNode.targetBinding.guid === question.questionId &&
                                                        question.manualScore) {
                                                        $scope.manualPoints = question.points;
                                                        return true;
                                                    }
                                                });
                                                $scope.$emit('assessment-player.question.rubricGuid', {
                                                    rubricGuid: sequenceNode.rubric_guid,
                                                    questionId: sequenceNode.targetBinding.guid,
                                                    manualScore: $scope.manualPoints,
                                                    isScoreSent: service.getIsScoreSent()
                                                });
                                            },
                                            // we should load side panel even this fails
                                            function(error) {
                                                emitRubricEvent(sequenceNode);
                                            });
                                    } else {
                                        emitRubricEvent(sequenceNode);
                                    }
                                }
                                $scope.sequenceNode = sequenceNode;
                                $log.log('done loading ', questionId);
                            }
                        );
                    } else {
                        /* TODO:
                         * Per existing architecture, position and currentQuestionId
                         * changes and the $watch on questionId causes the fetch for a new
                         * question. It should fetch the new question first and then increment
                         * the position/currentQuestionId, but it's too invasive a re-factor
                         * for a patch release.
                         */

                        $scope.position = position;
                        $scope.currentQuestionId = $scope.session.questionIds[$scope.position];
                    }
                }

                emitRubricEvent = function(sequenceNode) {
                    $scope.$emit('assessment-player.question.rubricGuid', {
                        rubricGuid: sequenceNode.rubric_guid,
                        questionId: sequenceNode.targetBinding.guid
                    });
                };

                function loadReportScreen() {
                    var loadReportPage,
                        eventTarget,
                        getReportEvent;

                    loadReportPage = function() {
                        var renderPage = function() {
                            //removes height set by resizePlayerBody() to prevent double scrolls
                            $('.uxf-assessment-player-body').css('height', '100%');
                            $scope.playerState = 'report';
                        };

                        if (!$scope.isNativeTarget) {
                            ItemPlayerService
                                .getNewSessionWithReviewMode($scope.sessionId)
                                .then(function(newSession) {
                                    $scope.session = newSession;
                                    renderPage();
                                }, renderPage);
                        } else {
                            renderPage();
                        }
                    };

                    $scope.reportLoading = true;

                    eventTarget = $scope.isNativeTarget ? 'Native' : 'ItemPlayer';

                    getReportEvent = 'uxfReport' + eventTarget + '.summary.get';

                    if ($scope.playerState !== 'loading') {
                        $scope.playerState = 'loading';
                        $scope.resizePlayerBody();
                    }

                    //send event to report-directive to load the report page
                    $scope.$broadcast(getReportEvent);
                    $scope.$on(getReportEvent + '.success', loadReportPage);
                    $scope.$on(getReportEvent + '.failure', loadReportPage);
                }

                function loadSubmitScreen() {
                    var eventTarget,
                        getReviewEvent,
                        loadReviewPage;

                    loadReviewPage = function() {
                        $('.uxf-assessment-player-body').css('height', '100%');
                        $scope.isLoading = false;
                        $scope.playerState = 'review';
                    };

                    if (!$scope.isNativeTarget && $scope.activityManager) {
                        $scope.activityManager.hidePlayer();
                    }
                    $scope.reportLoading = false;
                    eventTarget = $scope.isNativeTarget ? 'Native' : 'ItemPlayer';

                    getReviewEvent = 'uxfReview' + eventTarget + '.summary.get';

                    if ($scope.playerState !== 'loading') {
                        $scope.isLoading = true;
                        $scope.resizePlayerBody();
                    }
                    $scope.$broadcast('showSubmitScreen', {
                        areAllQuestionsAnswered: false,
                        sequence: $scope.session.sequence
                    });

                    if (!$scope.isAdaptive) {
                        $scope.$on(getReviewEvent + '.success', loadReviewPage);
                        $scope.$on(getReviewEvent + '.failure', loadReviewPage);
                    }
                }

                function navigateToPosition(position) {
                    $scope.isNavigating = true;

                    if (position < 0) {
                        $scope.position = position;
                        loadSplashScreen();
                        $scope.isNavigating = false;
                    } else if (position >= $scope.session.questionIds.length) {
                        $scope.position = $scope.session.questionIds.length;
                        if (!$scope.assessmentSubmitted) {
                            loadSubmitScreen();
                        } else {
                            loadReportScreen();
                        }
                        $scope.isNavigating = false;
                        // as per AC rubric button should be disabled in review and score summary page
                        $scope.$emit('assessment-player.question.rubricGuid', {
                            rubricGuid: null
                        });
                    } else {
                        $q.when(loadQuestionScreen(position)).then(
                            function() {
                                $log.log('done navigatingToPosition (deferred) ', position);
                                $scope.isNavigating = false;
                                $scope.isPlayerDialogVisible = false;
                                $scope.$broadcast('AssessmentServices.mathXlForceIframeResize');
                                $log.debug('Event broadcast: AssessmentServices.mathXlForceIframeResize');
                                if ($scope.isAdaptive) {
                                    $log.log('emitting assessmentSubmitted ', $scope.assessmentSubmitted);
                                    $scope.$emit('assessment-player.player-directive.assessmentSubmitted',
                                        {assessmentSubmitted: $scope.assessmentSubmitted});
                                }
                            }
                        );
                    }
                }

                $scope.saveProgress = function(event) {
                    $scope.activityManager.postStudentResponse($scope.sessionId, $scope.currentQuestionId,
                    // Callback function that's called when and IF nodeResult comes back
                    function() {
                        $scope.$emit('assessment-player.player-directive.assessmentSaved', {assessmentSaved: true});
                    },
                    function() {
                        $scope.$emit('assessment-player.player-directive.assessmentSaved', {assessmentSaved: false});
                    });
                };

                function saveProgressAndNavigate(targetPosition) {
                    var readyToNavigate = $scope.notifyNavigationChange();
                    if (!readyToNavigate) { //EX. GR reported error and show warning
                        $log.log('Navigation canceled');
                        $scope.isNavigating = false;
                        return;
                    }

                    if ($scope.isNativeTarget) {
                        if ($scope.assessmentSubmitted || $scope.isTeacherInprogressReview) {
                            navigateToPosition(targetPosition);
                        } else {
                            service.postResponse(false, false, function() {
                                navigateToPosition(targetPosition);
                            }, $scope.postResponseErrorHandler);
                        }
                    } else {
                        if ($scope.isPlayerDialogVisible) {
                            $log.log('player has disabled navigation');
                            return;
                        }

                        if ($scope.isLoading || $scope.isNavigating) {
                            $log.log('Navigation prevented, not ready to move on');
                            return;
                        }

                        $log.log('requestNodeResult for ', $scope.currentQuestionId);

                        $scope.activityManager.postStudentResponse($scope.sessionId, $scope.currentQuestionId,
                            // Callback function that's called when and IF nodeResult comes back
                            function() {
                                navigateToPosition(targetPosition);
                            });

                        $log.log('back from requestNodeResult for ', $scope.currentQuestionId);
                        if (service.isTestNavTarget($scope.playerTarget)) {
                            $scope.isNavigating = true;
                        }
                    }
                    $scope.$emit('assessment-player.question.rubricGuid', {});
                }

                function keepSessionAlive() {
                    if ($scope.session.sequence) {
                        service.keepAlive($scope.sessionId,
                                $scope.session.sequence).then(function(result) {
                            keepAliveTimer = $timeout(keepSessionAlive, fifteenMinutes);
                        }, function(reason) {
                            keepAliveTimer = null;
                        });
                    }
                }

                initActivityManager = function() {
                    $scope.activityManager = new ActivityManager(ItemPlayerService);

                    $scope.activityManager.bind(ActivityManager.prototype.EVENT_TOGGLE_UI,
                        function(evt, message) {
                            $scope.isPlayerDialogVisible = !message.enableUI;
                            $scope.$digest();
                            $log.log('Toggle ui', message);
                            $scope.$emit('activity-manager.player-directive.toggle-ui', message);
                        }
                    );
                };

                //Defaults
                $scope.position = -1;
                $scope.isNativeTarget = service.isNativeTarget($scope.playerTarget);
                $scope.isSubmitEnabled = true;
                $scope.submitEssayAction = false;
                $scope.assessmentSubmitted = false;
                $scope.isCheckAnswerEnabled = false;
                $scope.playerState = 'loading';

                $scope.window = $($window);
                $scope.$on('$destroy', function() {
                    if (keepAliveTimer !== null) {
                        $timeout.cancel(keepAliveTimer);
                    }
                });

                $scope.showSubmitButton = function() {
                    return !$scope.isTeacherInprogressReview && $scope.session && $scope.playerState === 'review';
                };

                $scope.showEssayScorerSubmitButton = function() {
                    return !$scope.isReviewMode || !$scope.isTeacherInprogressReview;
                };

                // Update isNativeTarget on playerTarget value change for lesson assignments
                $scope.$watch('playerTarget', function(newVal, oldVal) {
                    $scope.isNativeTarget = service.isNativeTarget($scope.playerTarget);
                });

                $scope.$watch('sessionId', function(newVal, oldVal) {
                    if (newVal !== '') { //Continue only if not empty
                        //reset the state
                        $scope.isCheckAnswerEnabled = false;

                        service.sessionSummary($scope.sessionId).then(function(data) {
                            $scope.session = data;
                            $scope.assessmentId = data.assessmentId;
                            $scope.playerMode = data.type.toLowerCase();
                            $scope.maxAttempts = (data.type && data.type.toLowerCase() === 'prep') ? 2 : 1;
                            $scope.isTeacherInprogressReview = $scope.isReviewMode &&
                                $scope.session.status !== 'NOT_STARTED';

                            if (!service.isNativeTarget($scope.playerTarget)) {
                                if (angular.isUndefined($scope.activityManager)) {
                                    initActivityManager();
                                }
                            }

                            if ($scope.session.status.toLowerCase() === QUESTION_STATUS.COMPLETE) {
                                $scope.assessmentSubmitted = true;
                                if ($scope.isAdaptive || $scope.hasEssayScorer) {
                                    navigateToPosition(0);
                                } else {
                                    loadReportScreen();
                                }

                            } else if ($scope.session.status.toLowerCase() === QUESTION_STATUS.INCOMPLETE) {
                                $scope.assessmentSubmitted = false;
                                $scope.isSubmitEnabled = true;
                                if ($scope.isAdaptive || $scope.hasEssayScorer) {
                                    navigateToPosition(0);
                                } else {
                                    loadSubmitScreen();
                                }

                            } else {
                                if ($scope.isAdaptive || $scope.hasEssayScorer) {
                                    navigateToPosition(0);
                                } else if ($scope.skipSplashScreen) {
                                    $scope.playerState = 'splash';
                                    $scope.nextButton();
                                } else {
                                    loadSplashScreen();
                                }
                                //Reset the state for single page ajax applications
                                //since the player would be initialized only once
                                $scope.assessmentSubmitted = false;
                                $scope.isSubmitEnabled = $scope.hasEssayScorer ? false : true;
                            }

                            keepSessionAlive();

                            /* Sometimes assessmentTypeIsAvailable is fired
                             * before the $scope.$on handler in splash page is defined,
                             * which means instructions don't render. Exposing instuctionsType to scope
                             * and passing it to splash directive to cover this edge case.
                             */
                            $scope.instructionsType = $scope.session.type;
                            $scope.$broadcast('player.assessmentTypeIsAvailable', $scope.instructionsType);
                        });
                    }
                });

                /**
                 * Callback invoked when feedback data for user's response is available (in prep/practice mode)
                 * @param statusCode
                 * @param feedbackData
                 */
                $scope.$on('feedbackRequestProcessed', function(event, statusCode, feedbackData) {
                    if ('assessment-player.question.feedbackfailed' === statusCode) {
                        $scope.playerMessageHandler(statusCode, 'assessment-player.error');
                    } else if ('assessment-player.question.feedbackcorrect' === statusCode) {
                        $scope.playerMessageHandler('assessment-player.question.feedback.correct',
                                'assessment-player.question.feedbackcorrect', feedbackData.feedbackText);
                    } else if ('assessment-player.question.feedbackincorrect' === statusCode) {
                        $scope.playerMessageHandler('assessment-player.question.feedback.incorrect',
                                'assessment-player.question.feedbackincorrect', feedbackData.feedbackText);
                    }
                });

                /**
                 * Invoke registered callbacks when the next/previous is used. Return false to stop further processing
                 */
                $scope.notifyNavigationChange = function() {
                    var navigationNotificationResponse = {};
                    // create a object that the listener can modify to communicate status back to the broadcaster
                    navigationNotificationResponse.proceed = true;
                    //listeners are invoked synchronously as long as they do not use stuff like $timeout and $http
                    $scope.$broadcast('preNavigationChange', $scope.playerState, navigationNotificationResponse);
                    return navigationNotificationResponse.proceed;
                };

                $scope.postResponseErrorHandler = function(data) {
                    $scope.playerMessageHandler('assessment-player.question.answer.savefailed',
                            'assessment-player.error');
                };

                /**
                 *  Save the response when the user hits the back button.
                 */
                $scope.$on('preNavigationChange', function(event, currentPlayerState) {
                    if ('backButton' === currentPlayerState) {
                        if (!$scope.assessmentSubmitted) {
                            service.postResponse(false, false, function() {
                                $.noop(); //the success handler, do nothing
                            }, $scope.postResponseErrorHandler);
                        }
                    }
                });

                $scope.$on('assessment-player:question:navigate', function(event, data) {
                    var targetPosition = data.targetPosition;
                    navigateToPosition(targetPosition);
                });

                $scope.$on('content-viewer.recommendation.continue', function(event) {
                    $scope.nextButton(event);
                });

                $scope.$on('content-viewer.recommendation.save', function(event) {
                    $scope.saveProgress(event);
                });

                $scope.hideFooter = function() {
                    return $scope.reportLoading || $scope.playerState === 'report' ||
                        $scope.isAdaptive || $scope.hasEssayScorer;
                };

                $scope.navigate = function(event) {
                    $log.log('playerDirective:$scope.navigate');
                    fixLostHtml5MessagesForAnchorsOnIE(event);

                    if ($scope.isNavigating || $scope.navigationForm.$pristine || !$scope.navigationForm.$valid) {
                        return false;
                    }

                    var targetPosition = $scope.displayedPage - 1;
                    saveProgressAndNavigate(targetPosition);
                    $scope.scrollToPageTop();
                };

                $scope.activityReview = function(event) {
                    $log.log('playerDirective:$scope.activityReview');
                    fixLostHtml5MessagesForAnchorsOnIE(event);

                    var targetPosition = $scope.session.questionIds.length;
                    saveProgressAndNavigate(targetPosition);
                };

                $scope.prevButton = function(event) {
                    $log.log('playerDirective:$scope.prevButton');
                    fixLostHtml5MessagesForAnchorsOnIE(event);

                    var targetPosition;
                    //FIXME report no longer have prev button after summary page update, this is temp for JD
                    if ($scope.playerState === 'question') {
                        targetPosition = $scope.position - 1;
                        saveProgressAndNavigate(targetPosition);
                    } else if ($scope.playerState === 'review' || $scope.playerState === 'report') {
                        targetPosition = $scope.session.questionIds.length - 1;
                        navigateToPosition(targetPosition);
                    }

                    $scope.scrollToPageTop();

                };

                $scope.nextButton = function(event) {
                    $log.log('playerDirective:$scope.nextButton');
                    fixLostHtml5MessagesForAnchorsOnIE(event);

                    if ($scope.playerState === 'question') {
                        var targetPosition = $scope.position + 1;
                        saveProgressAndNavigate(targetPosition);
                    } else if ($scope.playerState === 'review') {
                        loadReportScreen();
                    }

                    $scope.scrollToPageTop();

                };

                $scope.$on('assessment-player:splash:start', function() {
                    if (!$scope.notifyNavigationChange()) {
                        return;
                    }
                    navigateToPosition(0);
                });

                /**
                 * Event handler for 'Check answer' button
                 */
                $scope.checkAnswer = function() {

                    if (!$scope.isCheckAnswerEnabled) {
                        return false;
                    }
                    //disable the button until we get the feedback for current answer selection
                    $scope.isCheckAnswerEnabled = false;
                    $scope.$broadcast('feedbackRequested', $scope.playerState);
                };

                /**
                 * Event handler for 'Try Again' button
                 */
                $scope.tryAgainAssessment = function(event) {
                    $scope.playerMessageHandler('assessment-player.report.try-again.modal.will-replace',
                            'assessment-player.tryagain');
                };

                function handleEssayScorerSubmit() {
                    var essaySubmitRequest = {essaySubmitRequested : true};
                    $scope.activityManager.postPlayerMessage(essaySubmitRequest);
                }

                $scope.confirmSubmit = function(event) {
                    $scope.submitEssayHandler($scope.submitEssayAction);
                };

                $scope.$on('essayScorer.submitTest', function(event, clickEvent) {
                    $scope.submitTest(clickEvent);
                });

                $scope.submitTest = function(event) {
                    if (!$scope.isSubmitEnabled) {
                        return false;
                    }
                    $scope.isSubmitEnabled = false;

                    if ($scope.hasEssayScorer) {
                        handleEssayScorerSubmit();
                        return;
                    }

                    $scope.playerState = 'loading';

                    service.completeAssessment($scope.sessionId, $scope.session.sequence, $scope.playerTarget).then(
                        // success callback function
                        function(data) {
                            $scope.assessmentSubmitted = true;
                            // send event that assessment is complete. consumers
                            // like question-directive will set their state to readonly
                            $scope.$broadcast('assessmentCompleted');
                            // load the report screen after assessment has been marked as complete
                            loadReportScreen();
                            $scope.isSubmitEnabled = true;
                        },
                        // error callback function
                        function(data) {
                            $scope.playerMessageHandler('assessment-player.assessment.complete.savefailed',
                                'assessment-player.error');
                            $scope.isSubmitEnabled = true;
                        }
                    );
                };

                function itemPlayerMessageListener(ev) {
                    var eventData = typeof(ev.data) === 'string' ? JSON.parse(ev.data) : ev.data,
                        itemAnswered = false;
                    $log.log('Received message in player directive ', eventData);
                    if (angular.isDefined(eventData.essaySoreCompleted)) {
                        if (eventData.essaySoreCompleted) {
                            $scope.playerState = 'loading';
                            service.completeAssessment($scope.sessionId, $scope.session.sequence)
                            .then(
                                // success callback function
                                function(data) {
                                    $scope.assessmentSubmitted = true;
                                    $scope.$broadcast('assessmentCompleted');
                                    $scope.$emit('assessment-player.hasEssayScorer.exit', ev);
                                },
                                // error callback function
                                function(data) {
                                    $scope.playerMessageHandler('assessment-player.assessment.complete.savefailed',
                                        'assessment-player.error');
                                    $scope.isSubmitEnabled = true;
                                }
                            );
                        } else {
                            $scope.isSubmitEnabled = true;
                        }
                    } else if (angular.isDefined(eventData.enableSubmitButton)) {
                        $scope.isSubmitEnabled = eventData.enableSubmitButton;
                        $scope.submitEssayAction = eventData.enableSubmitAction;
                        $scope.warningMessage = eventData.warningMessage;

                        if ($scope.warningMessage) {
                            $scope.$emit('assessment-player.hasEssayScorer.warningMessageCode', {
                                warningMessage: $scope.warningMessage
                            });
                        }
                        if (!($scope.isSubmitEnabled && !$scope.submitEssayAction) && !$scope.warningMessage) {
                            $scope.$emit('assessment-player.hasEssayScorer.answerError', {
                                answerError: false,
                                warningEnabled: false
                            });
                        }
                        $scope.$apply();
                    } else if (angular.isDefined(eventData.questionStatus)) {
                        $log.log('emitting questionStatusChanged : ', eventData.questionStatus);
                        $scope.$emit('assessment-player.player-directive.questionStatusChanged', eventData);
                    } else if (angular.isDefined(eventData.telemetryParamsForEssayScorer)) {
                        $log.log('emitting essayscorer event : ', eventData.telemetryParamsForEssayScorer);
                        $scope.$emit('essayScorer.telemetry.event', eventData.telemetryParamsForEssayScorer);
                    }
                }

                $window.addEventListener('message', itemPlayerMessageListener);

                $scope.$on('navigation.event.location.change', function() {
                    $window.removeEventListener('message', itemPlayerMessageListener);
                });

                $scope.isCheckAnswerVisible = function() {
                    var type = $scope.session && $scope.session.type ? $scope.session.type.toLowerCase() : null;
                    return ($scope.playerState === 'question' && (type === 'prep' || type === 'practice'));
                };

                $scope.isTryAgainVisible = function() {
                    var type = ($scope.session && $scope.session.type) ? $scope.session.type.toLowerCase() : null;
                    return $scope.playerState === 'report' && (type === 'prep' ||
                            type === 'practice' || type === 'homework') && $scope.assessmentSubmitted &&
                        !!$scope.tryAgainHandler;
                };

                $scope.isPrevButtonVisible = function() {
                    return $scope.session && ($scope.playerState === 'question' || $scope.playerState === 'report');
                    //Use this once summary page update story is completed
                    //return $scope.session && $scope.playerState === 'question';
                };

                $scope.$on('player.assessmentTypeIsAvailable', function(e, type) {
                    $scope.submitButtonMessage = 'assessment-player.submit.button' +
                        (type.toLowerCase() === 'homework' ? '.homework' : '.default');
                });

                $scope.$on('assessment-player:tryAgain', function(event, data) {
                    $scope.tryAgainAssessment(event);
                });

                $scope.isGoButtonDisabled = function() {
                    return $scope.isLoading || $scope.isNavigating || $scope.navigationForm.input.$pristine ||
                        $scope.navigationForm.input.$invalid || $scope.isPlayerDialogVisible;
                };

                /*
                 * @param - messageCode is a key for i18n defined in assessmentplayer.js
                 * @param - messageType is one of:
                 *              assessment-player.error,
                 *              assessment-player.tryagain,
                 *              assessment-player.question.feedbackcorrect,
                 *              assessment-player.question.feedbackincorrect
                 * @param - rawMessage (optional) is appended to the internationalized
                 * message based on messageCode and is intended
                 *          to be used to relay third party error messages (e.g., from flash player)
                 */
                $scope.playerMessageHandler = function(messageCode, messageType, rawMessage) {
                    var opts, i18n, i18nFn, handledFn;

                    i18nFn = function(key) {
                        var val = i18n(key);
                        return val === key ? null : val;
                    };

                    i18n = $filter('uxfLocalize');
                    messageCode = messageCode || '';
                    opts = {
                        // host web app can display this message or construct their own
                        // using the messageType and/or messageCode
                        messageType: messageType,
                        messageCode: messageCode,
                        title: i18nFn(messageCode + '.title'),
                        header: i18nFn(messageCode + '.header'),
                        message: i18nFn(messageCode),
                        assessmentId: $scope.assessmentId
                    };

                    if (rawMessage) {
                        if (opts.message) {
                            opts.message += '<br>' + rawMessage;
                        } else {
                            opts.message = rawMessage;
                        }
                    }

                    // make sure User does not see null or undefined if message is not set. Defect DE21482
                    if (!opts.message) {
                        opts.message = '';
                    }

                    if ('assessment-player.tryagain' === messageType) {
                        handledFn = $scope.tryAgainHandler;
                    } else {
                        handledFn = $scope.messageHandler;
                    }

                    if (handledFn) {
                        handledFn(opts);
                    } else {
                        // ugly ugly ugly default handler.  If host app doesn't override
                        // then they deserve what they get.
                        window.alert(opts.message);
                    }
                };

                service.setMessageHandler($scope.playerMessageHandler);
            }
        ]);

        module.directive('uxfNavigationValidator', ['$log', function($log) {
            return {
                require: 'ngModel',
                link: function(scope, elem, attr, ctrl) {
                    ctrl.$parsers.unshift(function(viewValue) {
                        if (!viewValue) {
                            return;
                        }
                        var num = parseInt(viewValue, 10);

                        ctrl.$setValidity('isInteger', /^\d+$/.test(viewValue));
                        ctrl.$setValidity('isWithinLimit', num >= 1 && num <= scope.session.questionIds.length);
                        ctrl.$setValidity('isChanged', num !== scope.position + 1);

                        return viewValue;
                    });
                }
            };
        }]);

        module.directive('uxfAssessmentPlayer', [
            '$timeout',
            'AssessmentPlayerService',
            '$anchorScroll',
            '$log',
            'HeightUtil',
            'BrowserUtil',
            '$document',
            function($timeout, AssessmentPlayerService, $anchorScroll, $log, HeightUtil, BrowserUtil, $document) {

                var service = AssessmentPlayerService;

                return {
                    restrict: 'A',
                    replace: false,
                    scope: {
                        sessionId: '@',
                        defaultSplashUrl: '@',
                        // reference to host web app function to which notifications for Error
                        //and Check My Answer result will be sent
                        messageHandler: '=',
                        // reference to host web app function to which notification for Try Again will be sent
                        // If not included or null, the Try Again button will never be shown
                        tryAgainHandler: '=',
                        // if user has chose to do 'Try Again' then start with the questions page
                        skipSplashScreen: '=',
                        playerTarget: '@',
                        isAdaptive: '=',
                        hasEssayScorer: '=',
                        submitEssayHandler: '=',
                        isReviewMode: '=',
                        itemLanguage: '@',
                        styleWithFlexbox: '='
                    },
                    templateUrl: config('templateRoot') + '/player.html',
                    controller: 'AssessmentServices.Player.Controllers.Player',
                    link: function($scope) {
                        var _transitionEndEvents,
                            bindResizeWindowHandlers,
                            unbindResizeWindowHandlers,
                            mathXlForceIframeResize,
                            scopeApplyResizePlayerBody,
                            resizeOnHeightTransitionEnd,
                            resizeOnOrientationChange,
                            _initPageDisplay,
                            _reRenderParentScrollPatch,
                            _addOrShowCorrectAnswerItemPlayer;

                        /* TODO remove when xlplayer is fixed.
                         * This is a hack for mathxl because in iPad it persists the largest
                         * calculated scrollSize instead of a scrollSize appropriate
                         * for the content its rendering. */
                        mathXlForceIframeResize = function() {
                            $('#itemPlayer').attr('scrolling', 'no');
                            $scope.resizePlayerBody();
                            $('#itemPlayer').removeAttr('scrolling');
                        };

                        scopeApplyResizePlayerBody = function() {
                            $scope.$apply(function() {
                                $scope.resizePlayerBody();
                            });
                        };

                        resizeOnHeightTransitionEnd = function(e) {
                            var isHeightTransitionComplete = e.originalEvent &&
                                e.originalEvent.propertyName === 'height',
                                resizeBasedOnItemPlayerAndDevice = function() {
                                    if (service.isMathXlTarget($scope.playerTarget) && BrowserUtil.isIpad()) {
                                        mathXlForceIframeResize();
                                    } else {
                                        $scope.resizePlayerBody();
                                    }
                                };

                            if (isHeightTransitionComplete) {
                                resizeBasedOnItemPlayerAndDevice();
                            }
                        };

                        resizeOnOrientationChange = function() {
                            //taken from http://uihacker.blogspot.com/2011/10/javascript-hide-ios-soft-keyboard.html
                            var hideVirtualKeyboard = function() {
                                angular.element('input').blur();
                                angular.element('iframe').blur();
                            };

                            if (BrowserUtil.isIpad() || BrowserUtil.isAndroid()) {
                                /* improves issue where an orientationchange
                                 * while virtual keyboard is visible on iOS7/8 and Android
                                 * causes black bars */
                                hideVirtualKeyboard();

                                $scope.scrollToPageTop();

                                if (service.isMathXlTarget($scope.playerTarget)) {
                                    mathXlForceIframeResize();
                                }
                            }
                        };

                        _transitionEndEvents = 'transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd';

                        bindResizeWindowHandlers = function() {
                            $scope.window.bind('resize', scopeApplyResizePlayerBody);

                            $scope.window.bind('orientationchange', resizeOnOrientationChange);

                            $('.uxf-assessment-player-footer').bind(_transitionEndEvents, resizeOnHeightTransitionEnd);
                        };

                        unbindResizeWindowHandlers = function() {
                            $scope.window.unbind('resize', scopeApplyResizePlayerBody);

                            $scope.window.unbind('orientationchange', resizeOnOrientationChange);

                            $('.uxf-assessment-player-footer').unbind(_transitionEndEvents,
                                    resizeOnHeightTransitionEnd);
                        };

                        $scope.resizePlayerBody = function() {
                            var elBody,
                                playerFrames,
                                resize;

                            elBody = $('.uxf-assessment-player-body');

                            //get both student response and correct response frames
                            //resize the height for both when available
                            //this selector selects iframes with id ends with 'player'...
                            playerFrames = $('iframe[id$="Player"]');

                            //this fixes the alignment issue on iPads RGHT-61895
                            playerFrames.css('margin', 'auto');

                            resize = function() {
                                var isPlayerBodyVisible,
                                    newHeight,
                                    addHeightPropertyToElBody,
                                    elFooterHeight,
                                    expectedFooterHeight,
                                    useFixedWidth,
                                    correctAnswersTabHeight,
                                    offsetMarginForScrollbar,
                                    scrollBarWidth,
                                    container,
                                    bodyWidth,
                                    itemPlayerWidth;

                                scrollBarWidth = 15;
                                correctAnswersTabHeight = 50;
                                isPlayerBodyVisible = elBody[0];

                                if (!isPlayerBodyVisible) {
                                    unbindResizeWindowHandlers();
                                    return;
                                }
                                if ($scope.hasEssayScorer) {
                                    elBody.css('width', '100%');
                                }

                                newHeight = HeightUtil.getPlayerBodyHeight();
                                useFixedWidth = elBody.width() > 980 && !$scope.hasEssayScorer;
                                itemPlayerWidth = useFixedWidth ? 980 : elBody.width();

                                if ($scope.isState('question') && $scope.isNativeTarget && BrowserUtil.isIOS7()) {
                                    //Workaround IOS7 not firing animation end event
                                    expectedFooterHeight = 60;
                                    elFooterHeight = angular.element('.uxf-assessment-player-footer.large').height() ||
                                        expectedFooterHeight;
                                } else {
                                    elFooterHeight = angular.element('.uxf-assessment-player-footer').height() ||
                                        angular.element('.content-controlbar').height();
                                }

                                offsetMarginForScrollbar = function() {
                                    container = playerFrames.contents().find('.container');
                                    container.css('margin-left', '');
                                    bodyWidth = playerFrames.contents().find('body').width();
                                    //check if the scroll bar is present
                                    if (container.offset() && playerFrames.width() > bodyWidth) {
                                        container.css('margin-left',
                                            (container.offset().left + scrollBarWidth * 0.5) + 'px');
                                    }
                                };

                                addHeightPropertyToElBody = function() {
                                    if ($scope.isState('question')) {
                                        //w/o ios7 height fix, iframe height is 20px too tall
                                        HeightUtil.applyIOS7HeightFix();
                                    } else {
                                        /* ios7 height fix prevents user from scrolling body.
                                         * it causes issues on the report, review and splash screens
                                         * which don't need it */
                                        HeightUtil.removeIOS7HeightFix();
                                    }

                                    if ($scope.isState('report') || $scope.isState('review')) {
                                        //prevents double scroll bars on summary page
                                        elBody.css('height', '');
                                        if ($scope.styleWithFlexbox) {
                                            $scope.playerBodyStyle = {};
                                        }
                                    } else {
                                        elBody.css('height', newHeight + 'px');
                                        $scope.playerBodyStyle = {
                                            'height': newHeight + 'px'
                                        };
                                        playerFrames.height(newHeight);
                                        playerFrames.width(itemPlayerWidth);
                                    }
                                    if ($scope.showCorrectAnswers) {
                                        playerFrames.contents().find('#itemCanvas').css('margin-top', '0');
                                        playerFrames.height(newHeight - correctAnswersTabHeight);
                                        $('.uxf-assessment-player-body').css('height', 'auto');
                                        offsetMarginForScrollbar();
                                    }
                                };

                                if ($scope.isNativeTarget && !BrowserUtil.isIOS7()) {
                                    //native player needs minHeight property or questions are cut off
                                    elBody.css('min-height', newHeight + 'px');

                                } else if ($scope.isNativeTarget && BrowserUtil.isIOS7()) {

                                    //add footer height so that questions are not cut off
                                    angular.forEach([
                                            '.uxf-question',
                                            '.uxf-answer-options',
                                            '.uxf-griddedresponse-holder'
                                        ],
                                        function(selector) {
                                            angular.element('.nativePlayer-container' + ' ' + selector)
                                                .css('padding-bottom', elFooterHeight + 'px');
                                        });

                                    $('.nativePlayer-container').css('min-height', newHeight + 'px');

                                    //fixes iOS7 footer displacement issue
                                    addHeightPropertyToElBody();

                                } else {
                                    addHeightPropertyToElBody();
                                }
                                $scope.playerBodyStyle.height = $scope.isAdaptive ? newHeight + 'px' : 'inherit';
                            };

                            $timeout(resize, 0);

                        };

                        if ($scope.window) {
                            $scope.wideMode = $scope.window.width() >= 980;
                        }

                        $scope.scrollToPageTop = function() {
                            $anchorScroll();
                            $('.uxf-assessment-player-body').scrollTop(0);
                        };

                        $scope.isState = function(state) {
                            return $scope.playerState === state;
                        };

                        _initPageDisplay = function() {
                            //init call is needed to resize and position the loader gif correctly
                            $scope.scrollToPageTop();
                            $scope.resizePlayerBody();
                        };

                        _initPageDisplay();
                        bindResizeWindowHandlers();

                        if (service.isMathXlTarget($scope.playerTarget) && BrowserUtil.isIpad()) {
                            $scope.$on('AssessmentServices.mathXlForceIframeResize', function() {
                                mathXlForceIframeResize();
                                $log.debug('Event captured: AssessmentServices.mathXlForceIframeResize');
                            });
                        }

                        _reRenderParentScrollPatch = function(element) {
                            var height = element.height(),
                                minimalOffset = 1;
                            element.height(height + minimalOffset);
                            $timeout($.fn.height.bind(element, height), 0);
                        };

                        _addOrShowCorrectAnswerItemPlayer =  function(parentScope) {
                            var node = parentScope.sequenceNode,
                                id = 'correctAnswerItemPlayer',
                                anotherFrame = $('#' + id),
                                correctResponseLoader = $('#correctResponseLoader'),
                                itemPlayer = $('#itemPlayer'),
                                questionUrl = node.targetBinding['@id'],
                                assessmentSessionId = node.assessmentSessionId,
                                correctAnswerPromise,
                                tempMessageListener = function(messageEvent) {
                                    var eventData = null,
                                        correctAnswerWindow = null,
                                        postMessageForNewFrame = function(correctResponse) {
                                            node.isCorrectAnswers = true;
                                            var nodeResult = node.nodeResult[0];
                                            nodeResult.questionCorrectness = {};
                                            if (nodeResult.reviewData) {
                                                nodeResult.reviewData['@value'] = correctResponse;
                                            } else {
                                                nodeResult.reviewData = {
                                                    '@value': correctResponse
                                                };
                                            }
                                            correctAnswerWindow.postMessage(JSON.stringify(node),
                                                correctAnswerWindow.location.origin);
                                            correctResponseLoader.remove();
                                            anotherFrame.css('visibility', 'visible');
                                            window.removeEventListener('message', tempMessageListener);
                                            $scope.resizePlayerBody();
                                        };
                                    if (anotherFrame[0] && anotherFrame[0].contentWindow) {
                                        anotherFrame.contents().find('#itemCanvas').css('margin-top', '0');
                                        correctAnswerWindow = anotherFrame[0].contentWindow;
                                    }
                                    if (typeof messageEvent.data !== 'object') {
                                        eventData = JSON.parse(messageEvent.data);
                                    } else { eventData = messageEvent.data; }

                                    if (eventData['@type'] === 'PlayerReady' &&
                                            messageEvent.source === correctAnswerWindow) {
                                        correctAnswerPromise.then(postMessageForNewFrame);
                                    }
                                };
                            itemPlayer.hide();
                            if (anotherFrame.length) {
                                if (correctResponseLoader.length) {
                                    correctResponseLoader.remove();
                                }
                                _reRenderParentScrollPatch(anotherFrame.show());
                            } else {
                                //by default "#correctResponseLoader" is loaded with display none.
                                correctResponseLoader.css('display', 'block');
                                window.addEventListener('message', tempMessageListener);
                                parentScope.$on('$destroy', function() {
                                    window.removeEventListener('message', tempMessageListener);
                                });
                                anotherFrame = itemPlayer.clone();
                                anotherFrame.attr('id', id)
                                    .css('display', 'block')
                                    .css('visibility', 'hidden');
                                correctAnswerPromise = AssessmentPlayerService.
                                    correctResponse(assessmentSessionId, questionUrl);
                                anotherFrame.appendTo(itemPlayer.parent());
                            }
                        };

                        $scope.$on('correct-answer-clicked', function(ev) {
                            _addOrShowCorrectAnswerItemPlayer(ev.targetScope.$parent);
                        });

                        $scope.$on('student-response-clicked', function(ev) {
                            $('#correctAnswerItemPlayer').hide();
                            _reRenderParentScrollPatch($('#itemPlayer').show());
                        });

                        $scope.$on('$destroy', function() {
                            HeightUtil.removeIOS7HeightFix();
                            unbindResizeWindowHandlers();
                        });
                    }
                };
            }
        ]);
    }
});
;UXF.Module.define({
    dependencies: ['jQuery.fn.griddedResponse'],
    name: 'UXF.AssessmentPlayer.Directives.Question',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'window', '_'],
    initFunc: function(angular, $, config, debug, window, _) {
        'use strict';

        var module;

        module = angular.module('AssessmentServices.Player.Directives.Question', [
            'AssessmentServices.Player.Services.Player',
            'ngSanitize',
            'AssessmentServices.Player.Services.NativeQuestionCommonService'
        ]);
        module.controller('AssessmentPlayerQuestionController', [
            '$scope',
            '$filter',
            '$timeout',
            'AssessmentPlayerService',
            '$log',
            '$window',
            'QUESTION_TYPES',
            'NativeQuestionCommonService',
            function($scope, $filter, $timeout, service, $log, $window, QUESTION_TYPES, NativeQuestionCommonService) {

                // Update isNativeTarget on playerTarget value change for lesson assignments
                $scope.$watch('playerTarget', function(newVal, oldVal) {
                    $scope.isNativeTarget = service.isNativeTarget($scope.playerTarget);
                });

                /*
                 * Package the user's response to be saved
                 * @param $scope - the scope object
                 * @param forceRead - optional flag to force the read activity. Default value is False.
                 * @see function $scope.$on('feedbackRequested', function(event, currentPlayerState) {
                 * to see why this flag is required
                 */
                function readResponse($scope, forceRead) {
                    // this can be called when there's no question loaded
                    // (e.g., navigating from the splash page by clicking 'Go back')
                    if (!$scope.question) {
                        return null;
                    }

                    if (forceRead === undefined) {
                        forceRead = false;
                    }

                    if (forceRead || !$scope.selection || !$scope.selection.hasPreviousResponses ||
                         $scope.wasResponseChanged()) {
                        if ($scope.question.questionType === QUESTION_TYPES.MULTIPLE_CHOICE) {
                            //save a copy of the current answer after sending response to the server to prevent a repost
                            $scope.selection.originalResponseId = $scope.selection.responseId;
                            return {
                                sessionId: $scope.sessionId,
                                questionId: $scope.question.id,
                                responseId: $scope.selection.responseId,
                                isAnswered: !!$scope.selection.responseId
                            };
                        } else if ($scope.question.questionType === QUESTION_TYPES.GRIDDED_RESPONSE) {
                            /*
                             * Save the current valid grid value. In case the User navigates from the Submit page
                             * to the last question page and then
                             * either to the second last question page or back to the Submit page, a repost of
                             * the GR value for the last question will be avoided
                             * as $scope.wasResponseChanged will return false
                             */
                            $scope.selection.originalResponseText = $scope.griddedResponse.getValue();
                            return {
                                sessionId: $scope.sessionId,
                                questionId: $scope.question.id,
                                responseId: ($scope.griddedResponse.isAnswered() ? $scope.selection.responseId : null),
                                responseText: $scope.griddedResponse.getValue(),
                                isAnswered: $scope.griddedResponse.isAnswered()
                            };
                        }

                        $scope.selection.hasPreviousResponses = true;
                    }
                    return null;
                }

                /*
                 * handler invoked only when question id changes.
                 *
                 */
                function onQuestionIdChanged($scope, newQuestionId) {

                    var defaultQuestionHandler = function() {
                        // first reset the question - otherwise the previous question will be shown (briefly)
                        //  on the page while the new question is being retrieved
                        $scope.question = null;

                        $scope.isQuestionUnanswered = false;
                        service.question($scope.sessionId, newQuestionId)
                            .then(function(data) {
                                NativeQuestionCommonService.nativeQuestionHandler($scope, data);
                            });
                    };

                    if (newQuestionId && service.isNativeTarget($scope.playerTarget)) {
                        defaultQuestionHandler();
                    }
                }

                function validate($scope, currentPlayerState) {
                    // check if examinee has changed the previously entered response
                    if ($scope.wasResponseChanged()) {
                        switch ($scope.question.questionType) {
                            case QUESTION_TYPES.MULTIPLE_CHOICE:
                                break;

                            case QUESTION_TYPES.GRIDDED_RESPONSE:
                                var retVal = $scope.griddedResponse.validate();

                                // validate() returns an empty string if validation succeeded
                                if ('' !== retVal) {
                                    $scope.playerErrorHandler({
                                        messageCode: retVal,
                                        messageType: 'assessment-player.error'
                                    });
                                    return false;
                                }
                                break;
                        }
                    }
                    //return success
                    return true;
                }

                /*
                 * Consumer for event that question is to be readonly
                 *
                 */
                $scope.$watch('isQuestionReadOnly', function(isQuestionReadOnly) {
                    if ($scope.griddedResponse && $scope.question &&
                            $scope.question.questionType === QUESTION_TYPES.GRIDDED_RESPONSE) {
                        $scope.griddedResponse.setReadOnly(isQuestionReadOnly);
                    }
                });

                $scope.$watch('questionId', function(newQuestionId) {
                    onQuestionIdChanged($scope, newQuestionId);
                });

                // reload question when sessionId changes
                // this is needed when starting a new session for an assessment with 1 question
                // (i.e., questionId doesn't change from previous session, but sessionId does)
                $scope.$watch('sessionId', function(newSessionId) {
                    onQuestionIdChanged($scope, $scope.questionId);
                });

                /*
                 * The user has completed an assessment and goes back the last question page.
                 * At that time the last question page should be readonly
                 */
                $scope.$on('assessmentCompleted', function(newQuestion) {
                    $scope.isQuestionReadOnly = true;

                    //loading the last question after submit to get the answerCorrect flag and correctAnswer object
                    onQuestionIdChanged($scope, $scope.questionId);
                });

                /**
                 * Callback invoked when the user changes a multiple choice answer
                 */
                $scope.$watch('selection.responseId', function(newResponseId) {
                    if ($scope.question && $scope.question.questionType ===
                            QUESTION_TYPES.MULTIPLE_CHOICE && $scope.wasResponseChanged()) {
                        $scope.isCheckAnswerEnabled = true;
                    }
                });

                /*
                 * Process request for 'check my answer'
                 */
                $scope.$on('feedbackRequested', function(event, currentPlayerState) {
                    var retVal, userResponse, response, forceActivity = true;

                    if ('question' !== currentPlayerState) {
                        return;
                    }

                    //always validate the answer before committing the answer
                    if (!validate($scope)) {
                        return;
                    }

                    //force reading user's answer even if nothing has changed. e.g. user selects an answer
                    //thereby enabling the try again button. The user
                    //chooses to navigate using next/previous to another question. if the user immediately comes
                    //back to the previous question
                    //using previous/next then the button is still enabled and we want to submit the answer
                    //although wasChanged function would return false
                    userResponse = readResponse($scope, forceActivity);

                    // Call the service passing in the userResponse data, isAnswerRevealed (true),
                    // isResponseCommited(true)
                    service.response(userResponse.sessionId, userResponse.questionId,
                            userResponse.responseId, userResponse.responseText, userResponse.isAnswered,
                            true, true).then(
                        function(feedbackData) {
                            var i18n = $filter('uxfLocalize');

                            $scope.attempts++;
                            if (feedbackData.answerCorrect || ($scope.maxAttempts <= $scope.attempts)) {
                                $scope.isQuestionReadOnly = true;
                            }

                            switch (feedbackData.correctAnswer.responseType.toLowerCase()) {
                                case 'gridded_response':
                                    if (!feedbackData.answerCorrect && $scope.isQuestionReadOnly) {
                                        $scope.attemptFeedback = i18n('assessment-player.question.correct-answer') +
                                            feedbackData.correctAnswer.responseValue.trim();
                                    } else if (feedbackData.answerCorrect) {
                                        // Needed so that answer is immutable after getting it correct.
                                        $scope.isQuestionReadOnly = true;
                                    }

                                    $scope.attemptAnswer = 'uxf-griddedresponse-check-' +
                                        (feedbackData.answerCorrect ? 'correct' : 'wrong');
                                    break;

                                case 'text_option':
                                    angular.forEach($scope.question.responses, function(thisResponse, indx) {
                                        if (thisResponse.id === userResponse.responseId) {
                                            response = thisResponse;
                                            return false;
                                        }
                                    });
                                    //show the correct/incorrect icon in the UI
                                    response.isAnswerCorrect = feedbackData.answerCorrect;
                                    //this particular response is now disabled since it has been revealed
                                    response.isReadOnly = true;
                                    if ($scope.isQuestionReadOnly) {
                                        //show green check for the correct answer
                                        $scope.question.responses[
                                            feedbackData.correctAnswer.position
                                            ].isAnswerCorrect = true;
                                    }
                                    break;
                            }

                            $scope.selection.hasPreviousResponses = true;

                            retVal = feedbackData.answerCorrect ? 'assessment-player.question.feedbackcorrect' :
                                'assessment-player.question.feedbackincorrect';
                            $scope.$emit('feedbackRequestProcessed', retVal, feedbackData);
                        },
                        function(errData) {
                            retVal = 'assessment-player.question.feedbackfailed';
                            $scope.$emit('feedbackRequestProcessed', retVal);
                        }
                    );
                });

                // Utility method to check if the examinee has entered a new response
                $scope.wasResponseChanged = function() {

                    if ($scope.selection && !$scope.isQuestionReadOnly) {

                        switch ($scope.question.questionType) {

                            // multiple choice responses are differentiated by the selected responseId
                            case QUESTION_TYPES.MULTIPLE_CHOICE:
                                return ($scope.selection.responseId !== $scope.selection.originalResponseId);

                                // gridded responses are differentiated by their text value
                            case QUESTION_TYPES.GRIDDED_RESPONSE:
                                try {
                                    return ($scope.griddedResponse.getValue() !==
                                            $scope.selection.originalResponseText);
                                } catch (error) {
                                    // griddedResponse.getValue() throws an error if there's a validation error. in this
                                    // case, we can infer that the value was changed
                                    // (i.e., original value can't be invalid)
                                    return true;
                                }

                                break;
                        }
                    }

                    return false;
                };

                /*
                 * Return true/false whether the answer and radio button should be displayed read-only.
                 */
                $scope.isAnswerOptionReadOnly = function(response) {
                    return $scope.isQuestionReadOnly || response.isReadOnly;
                };

                $scope.isCorrectOrSelectedAnswer = function(response) {
                    return angular.isDefined(response.isAnswerCorrect);
                };

                $scope.getAnswerMessage = function(response) {
                    var label,
                        isUserSelectedAnswer = $scope.selection && $scope.selection.responseId === response.id,
                        isCurrentAnswerIncorrect = response.isAnswerCorrect === false;

                    label = isUserSelectedAnswer || isCurrentAnswerIncorrect ? 'submitted' : 'correct';

                    return 'assessment-player.question.answer.' + label + '.message';
                };

                /*
                 * Callback for change in gridded response widget, so we can enable/disable the Check My Answer button
                 * Note - not making this a private function because making it private will
                 * require the widget to pass in the scope as a parameter
                 */
                $scope.griddedResponseChangeCallback = function(eventType, data) {
                    // Instruct angular to update DOM (player.html) based on the value of isCheckAnswerEnabled.
                    //Using $apply here was causing ' digest
                    // already in progress' console log message
                    $timeout(function() {
                        $scope.isCheckAnswerEnabled = !$scope.isQuestionReadOnly && !data.isEmpty;
                    }, 100);
                };

                /*
                 * Event listener for navigation change. Make sure that we don't use $http or $timeout in this handler
                 * since we want all handlers
                 * for this event to be executed synchronously
                 */
                $scope.$on('preNavigationChange', function(event, currentPlayerState, responeObj) {
                    // do not process further if a previous event listener has already raised an error
                    if (('question' === currentPlayerState) && (true === responeObj.proceed)) {
                        // the validate method validates and also show the error message
                        // (not a good example of high cohesion)
                        responeObj.proceed = validate($scope);
                    }
                });

                /*
                 * Using the response's index position, create an alpha string for the response's label.
                 */
                $scope.responseLabel = function(answPosition) {
                    answPosition = answPosition || 0;
                    var newAnswLabel = String.fromCharCode((answPosition % 26) + 97).toUpperCase();
                    return newAnswLabel;
                };

                $scope.getMultipleChoiceTabIndex = function(responseId) {
                    var selectedId = !!$scope.selection.responseId ?
                        $scope.selection.responseId : $scope.question.responses[0].id;
                    return (selectedId === responseId) ? 0 : -1;
                };

                /*
                 * Register a function that the service can use to read the selected
                 * response from this directive.
                 */
                service.registerResponseReader(function() {
                    return readResponse($scope);
                });

                $scope.showCorrectAnswersTab = false;
                $scope.$on('show-correct-answers-tab', function(ev, data) {
                    $scope.showCorrectAnswersTab = data.showCorrectAnswers;
                    $scope.studentResponseActive = true;
                });

                $scope.loadStudentResponse = function() {
                    $scope.studentResponseActive = true;
                    $scope.$emit('student-response-clicked');
                };

                $scope.loadCorrectAnswer = function() {
                    $scope.studentResponseActive = false;
                    $scope.$emit('correct-answer-clicked');
                };
            }
        ]);

        module.directive('uxfAssessmentPlayerQuestion', [
                '$timeout',
                'AssessmentPlayerService',
                'BrowserUtil',
                function($timeout, service, BrowserUtil) {
                    return {
                        restrict: 'A',
                        replace: false,
                        scope: {
                            sessionId: '@sessionId',
                            assessmentId: '@assessmentId',
                            name: '@name',
                            questionId: '=questionId',
                            /*
                             * the max number of attempts for 'Check my answer'
                             */
                            maxAttempts: '=maxAttempts',
                            isAssessmentSubmitted: '=isAssessmentSubmitted',
                            /*
                             * wrapper for parent scope function to be invoked to report errors, e.g. validation error
                             */
                            playerErrorHandler: '&',
                            /*
                             *If true, the User can request a feedback for a new answer
                             */
                            isCheckAnswerEnabled: '=',
                            playerTarget: '=',
                            isLoading: '=isQuestionLoading',

                            /*
                             * Allow container to specify if the question is actually being displayed or not
                             * If attribute not provided, we assume true by default.
                             * False has to be explicitly specified.
                             */
                            isQuestionDisplayed: '@'
                        },
                        templateUrl: config('templateRoot') + '/question.html?buildNumber=' + config('buildNumber'),
                        controller: 'AssessmentPlayerQuestionController',
                        link: {
                            post: function(scope, element, attrs) {
                                scope.isNativeTarget = service.isNativeTarget(scope.playerTarget);
                                scope.displayQuestionContent = true;

                                scope.$watch('isQuestionDisplayed', function() {
                                    scope.displayQuestionContent =
                                        (scope.isQuestionDisplayed || '').toLowerCase() !== 'false';
                                });

                                scope.isIOSDevice = BrowserUtil.isIOS();

                                var containerElement,
                                    parentScopeFnWrapper = scope.playerErrorHandler,
                                    setScopeGriddedResponse = function() {
                                        containerElement = element.find('.uxf-griddedresponse-widget-container');
                                        if (containerElement.length !== 0) {
                                            containerElement.griddedResponse({
                                                'response:change': scope.griddedResponseChangeCallback
                                            });

                                            scope.griddedResponse = {
                                                validate: function() {
                                                    return containerElement.griddedResponse('validate');
                                                },

                                                getValue: function() {
                                                    return containerElement.griddedResponse('getValue');
                                                },

                                                isAnswered: function() {
                                                    return containerElement.griddedResponse('isAnswered');
                                                },

                                                setValue: function(value) {
                                                    containerElement.griddedResponse('setValue', value);
                                                },

                                                setReadOnly: function(readOnly) {
                                                    containerElement.griddedResponse('setReadOnly', readOnly);
                                                },

                                                init: function(options) {
                                                    containerElement.griddedResponse('init', options);
                                                }
                                            };
                                        }
                                    };

                                if (!$.isFunction(parentScopeFnWrapper)) {
                                    scope.playerErrorHandler = function() {};
                                } else {
                                    scope.playerErrorHandler = parentScopeFnWrapper;
                                }

                                $timeout(setScopeGriddedResponse, 0, false);
                            }
                        }
                    };
                }
        ]);

        return module;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.QuestionPreview',
    initArgs: ['angular', 'UXF.AssessmentPlayer.Config'],
    initFunc: function(angular, config) {
        'use strict';

        var module = angular.module('AssessmentServices.Player.Directives.QuestionPreview', [
            'AssessmentServices.Player.Services.ActivityManager',
            'AssessmentServices.Player.Services.Player',
            'AssessmentServices.Player.Services.ItemPlayer'
        ]);

        module.directive('uxfAssessmentQuestionPreview', [
            'AssessmentPlayerService',
            'ActivityManager',
            'ItemPlayerService',
            '$log',
        function(service, ActivityManager, ItemPlayerService, $log) {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    sessionId: '@',
                    questionId: '@',
                    // TODO: donot convert the sequence object into string, pass the binding as an object
                    sequence: '@',
                    paf: '@',
                    position: '@', //for debug ref only, not used
                    playerHeight: '@',
                    isCacheData: '@',
                    itemAnalysis: '@'
                },
                templateUrl: config('templateRoot') + '/question-single-view.html',
                link: function(scope) {
                    var playerFrame,
                        previewQuestionHandler = function() {
                        if (scope.$eval(scope.paf) || scope.itemAnalysis) {
                            playerFrame = angular.element('iframe#itemPlayer');
                            //Force height, when itemplayers are more than one
                            if (playerFrame.length > 1) {
                                angular.forEach(playerFrame, function(iframe) {
                                    if (!iframe.height.length) {
                                        iframe.height = scope.playerHeight;
                                    }
                                });
                            } else {
                                playerFrame[0].height = scope.playerHeight;//Force height
                            }

                            if (scope.activityManager) {
                                scope.activityManager.unregisterMessageHandler();
                            }
                            scope.activityManager = new ActivityManager(ItemPlayerService);
                            if (scope.sequence) {
                                scope.activityManager.setSequence(JSON.parse(scope.sequence));
                                scope.activityManager.playItem(scope.sessionId, scope.questionId, scope.isCacheData)
                                    .then(
                                        function() {
                                            scope.activityManager.showPlayer();
                                            playerFrame.addClass('loaded');
                                            if (scope.itemAnalysis) {
                                                var itemPlayer = angular.element('iframe#itemPlayer')[0];
                                                try {
                                                    // adding css style only for testnav in itemAnalysis
                                                    if (itemPlayer && itemPlayer.src &&
                                                    itemPlayer.src.indexOf('testnav.itemplayer') &&
                                                    itemPlayer.contentDocument && itemPlayer.contentDocument.body) {
                                                        itemPlayer.contentDocument.body
                                                            .setAttribute('class', scope.itemAnalysis);
                                                    }
                                                }
                                                catch (error) {
                                                    $log.log('cross browser security issue', error);
                                                }
                                            }
                                        }
                                    );
                            }
                        }
                    };
                    // for new feature Item Analysis, there are some different cases,
                    // when the sequence change, but no the questionId, or opposite way
                    // add the watcher on both questionId and sequence to catch both changes

                    // the sequence object is converted to a string
                    // performance is not affected much here as it is a string comparsion
                    scope.$watch('[questionId, sequence]', function(newVal) {
                        if (angular.isDefined(newVal)) {
                            previewQuestionHandler();
                        }
                    });

                    //Non-paf TO BE IMPLEMENTED

                }
            };
        }]);
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.QuestionReview',
    initArgs: ['angular', 'UXF.AssessmentPlayer.Config'],
    initFunc: function(angular, config) {
        'use strict';

        var module = angular.module('AssessmentServices.Player.Directives.QuestionReview', [
            'AssessmentServices.Player.Services.ActivityManager',
            'AssessmentServices.Player.Services.Player',
            'AssessmentServices.Player.Services.ItemPlayer'
        ]);

        module.directive('uxfAssessmentQuestionReview', [
            'AssessmentPlayerService',
            'ActivityManager',
            'ItemPlayerService', function(service, ActivityManager, ItemPlayerService) {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    sessionId: '@',
                    questionId: '@',
                    sequence: '@',
                    scrollToQuestion: '<?'
                },
                templateUrl: config('templateRoot') + '/question-review.html',
                link: function(scope) {
                    scope.$watch('scrollToQuestion', function(newVal, oldVal) {
                        if (newVal && scope.activityManager && scope.activityManager._playerLoader &&
                            newVal !== oldVal) {
                            scope.activityManager.postPlayerMessage(newVal);
                        }
                    });
                    scope.$watch('questionId', function(newVal, oldVal) {
                        if (scope.activityManager) {
                            scope.activityManager.unregisterMessageHandler();
                        }
                        scope.activityManager = new ActivityManager(ItemPlayerService);
                        scope.activityManager.setSequence(JSON.parse(scope.sequence));
                        // set the score sent flag to true so that Teacher can see the question correctness
                        // indication after scoring a question
                        service.setIsScoreSent(true);
                        scope.activityManager.playItem(scope.sessionId, scope.questionId).then(
                            function() {
                                scope.activityManager.showPlayer();
                                scope.$emit('assessment-player.questionReview.rubricGuid', {
                                    rubricGuid: scope.activityManager._currentNode.rubric_guid
                                });
                                if (scope.scrollToQuestion) {
                                    scope.activityManager.postPlayerMessage(scope.scrollToQuestion);
                                }
                            }
                        );
                    });
                }
            };
        }]);
    }
});
;/*
 * Usage:
 * <div uxf-report-itemplayer summary='mySummaryData' session-id='assessmentSessionId'
 *   hide-uxf-report-header='true'></div>
 *
 * @attr session-id: assessment session id used to fetch summary data. This
 *       allows parent to broadcast the appropriate event to update summary data
 * @attr summary (optional): data to be rendered in template. Useful if summary is
 *       already loaded (e.g. through 'resolve' in routeProvider)
 * @attr hide-uxf-report-header (optional): true if caller wants to hide the default header
 *
 */
UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.ReportItemPlayer',
    initArgs: ['angular', 'UXF.AssessmentPlayer.Config', '_'],
    initFunc: function(angular, config, _) {
        'use strict';

        var module;

        module = angular.module('AssessmentServices.Player.Directives.ReportItemPlayer',
            ['AssessmentServices.Player.Services.Player']);

        module.controller('ReportItemPlayerCtrl', [
            '$scope',
            'AssessmentPlayerService',
            '$q',
            '$log',
            '$filter',
            function($scope, service, $q, $log, $filter) {
                $scope.templateRoot = config('templateRoot');
                $scope.isGetReportCallComplete = angular.isDefined($scope.summary) && $scope.summary !== null;
                if (!angular.isDefined($scope.scoreSent)) {
                    $scope.scoreSent = true;
                }

                $scope.$on('uxfReportItemPlayer.summary.get', function() {
                    var hubSequence = '';
                    if ($scope.$parent.session && $scope.$parent.session.sequence) {
                        hubSequence = $scope.$parent.session.sequence;
                    }
                    // The default scoreSent flag should be initialized to true whenever a new assessment session report
                    // is loaded. The service will determine the actual value of flag for manually scored questions.
                    // The current use of this flag is to determine if question correctness indicator should be
                    // shown for Testnav questions
                    service.setIsScoreSent(true);
                    service.getScoreSummaryAndSkills($scope.sessionId, hubSequence).then(function(summary) {
                        $scope.summary = summary;
                        $scope.maxScore = summary.totalScore.maxPoints;
                        $scope.score = summary.totalScore.points;
                        var hasManualScoreQuestion = _.any(_.pluck(summary.questionScores, 'manualScore')),
                            notifyComplete = function() {
                                $scope.isGetReportCallComplete = true;
                                $scope.$emit('uxfReportItemPlayer.summary.get.success', $scope.summary);
                            };

                        if (hasManualScoreQuestion) {
                            service.getUserAssignmentData($scope.sessionId).then(function(result) {
                                $log.log(result);
                                $scope.scoreSent = result && result.scoreSent;
                                notifyComplete();
                            }, function(err) { //On error, still proceed but force scoreSent to false
                                $log.log(err);
                                $scope.scoreSent = false;
                                notifyComplete();
                            });
                        } else {
                            notifyComplete();
                        }
                    }, function() {
                        $scope.isGetReportCallComplete = true;
                        $scope.$emit('uxfReportItemPlayer.summary.get.failure');
                    });
                });
                $scope.tryAgainAssessmentFromReport = function(event) {
                    $scope.$emit('assessment-player:tryAgain');
                };
                $scope.showManualScoreMessage = function(question) {
                    return question.manualScore && !$scope.scoreSent;
                };
                $scope.redirectQuestionFromReport = function(e, index) {
                    //See http://connect.microsoft.com/IE/feedback/details/802397/
                    //ie9-ie10-events-can-be-sent-to-the-wrong-listeners
                    if (e) {
                        e.preventDefault();
                    }
                    var targetPosition = index;
                    $scope.$emit('assessment-player:question:navigate', {targetPosition: targetPosition});
                };
                $scope.getDisplayScore = function(score) {
                    if (!score.manualScore || $scope.scoreSent) {
                        return $filter('trimLeadingZeros')(score.points);
                    } else {
                        return '-';
                    }
                };
            }]);

        module.directive('uxfReportItemplayer', function() {
            return {
                scope: {
                    sessionId: '@',
                    summary: '=?',
                    isDefaultHeaderHidden: '=?hideUxfReportHeader',
                    isViewQuestionHidden: '=?hideUxfReportViewLink',
                    scoreSent: '=?',
                    isTryAgainVisible: '='
                },
                templateUrl: config('templateRoot') + '/report-itemplayer.html',
                controller: 'ReportItemPlayerCtrl'
            };
        });

        return module;
    }
});

;//report-native-directive.js
/*
 * Usage:
 * <div uxf-report-native assessment-name='myName' session-id='assessmentSessionId'></div>
 *
 * @attr session-id: assessment session id used to fetch summary data. This
 *       allows parent to broadcast the appropriate event to update summary data
 * @attr assessment-name: assessment title rendered in template
 *
 */
UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.ReportNative',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', '_'],
    initFunc: function(angular, $, config, debug, _) {
        'use strict';

        var module;

        module = angular.module('AssessmentServices.Player.Directives.ReportNative', [
                    'AssessmentServices.Player.Services.Player'
                ]);

        module.controller('AssessmentPlayerReportController',
            ['$scope', 'AssessmentPlayerService', function($scope, service) {

                $scope.$on('uxfReportNative.summary.get', function(event, eventData) {
                    service.getFinalReportAndUserName($scope.sessionId, true).then(function(data) {
                        var correctAnswer, responses = [], response, question, userResponses, userResponse,
                            userResponseData, loopCounter, responsesLength, submittedScores = [];

                        angular.forEach(data.questionResponseDefinitions, function(questionResponse, indx) {

                            submittedScores.push(questionResponse.score);
                            response = {};
                            //the question text
                            question = {};
                            question.text = questionResponse.question.text;
                            var hasImages = false;

                            question.type = questionResponse.question.questionType.toLowerCase();
                            response.question = question;

                            //view for the correct answer
                            correctAnswer = {};

                            switch (question.type) {
                                case 'gridded_response':
                                    correctAnswer.text = questionResponse.correctAnswer.responseValue;
                                    break;

                                case 'multiple_choice':
                                    correctAnswer.position =
                                        $scope.responseLabel(questionResponse.correctAnswer.position);
                                    correctAnswer.text = questionResponse.correctAnswer.text;
                                    // Note: If the user does not answer any question, we will display the correct
                                    // answer in the report.  The following sets a boolean indicating
                                    // if an image is present in the correct answer (needed for styling).
                                    if (questionResponse.correctAnswer.text.indexOf('<img') !== -1) {
                                        correctAnswer.isImagePresentInCorrectResponseText = true;
                                    } else {
                                        correctAnswer.isImagePresentInCorrectResponseText = false;
                                    }
                                    break;
                            }

                            response.correctAnswer = correctAnswer;

                            //view for user's answers
                            responsesLength = questionResponse.userResponses.length;
                            userResponses = [];
                            if (responsesLength !== 0) {
                                response.isImagePresentInResponseText = false;
                            }

                            response.isAnswered = (responsesLength > 0);

                            // question is correct if latest response is correct (i.e., score = 1)
                            // note: at this point, userResponses is in reverse chronological order
                            response.isCorrect = (responsesLength > 0 &&
                                    questionResponse.userResponses[0].score.correct);

                            for (loopCounter = 0; loopCounter < responsesLength; loopCounter++) {
                                userResponseData = questionResponse.userResponses[loopCounter];

                                // for the report page, we only care about committed responses
                                // uncommitted responses are saved whenever the user enters or changes an answer
                                // the last response is committed by Check My Answer and/or Submit My Test
                                if (userResponseData.committed) {
                                    userResponse = {};
                                    userResponse.score = userResponseData.score;
                                    switch (question.type) {
                                        case 'gridded_response':
                                            userResponse.text = userResponseData.responseValue;
                                            break;

                                        case 'multiple_choice':
                                            userResponse.text = userResponseData.text;
                                            userResponse.position = $scope.responseLabel(userResponseData.position);
                                            // Note:  Here we set a boolean whether the user's response has an image
                                            // in it which is used for styling the report.
                                            //TODO Keep in mind it is possible that the correct answer and user
                                            // responses may have different combinations of images and no images
                                            // which have styling implications.We don't tackle that here,
                                            // but may need to in the future.
                                            if (userResponse.text && userResponse.text.indexOf('<img') !== -1) {
                                                //Will render a different template if has image(s)
                                                response.isImagePresentInResponseText = true;
                                            }
                                            break;
                                    }

                                    userResponses.push(userResponse);

                                    // in test mode, there will be only one committed response and it will be first in
                                    // the userResponses array, so we can break
                                    if (data.assessment.assetType.toLowerCase() === 'test') {
                                        break;
                                    }
                                }

                            }//end loop over questionResponse.userResponses

                            // userResponses is in reverse chronological order (latest response first), but we have to
                            // display in the order the responses were submitted, so we need to reverse
                            userResponses = userResponses.reverse();

                            _.each(userResponses, function(question) {
                                response.score = question.score.points;
                                response.maxScore = question.score.maxPoints;
                            });
                            response.userResponses = userResponses;

                            responses.push(response);
                        });// end loop over data.questionResponseDefinitions

                        $scope.submittedScores = submittedScores;
                        $scope.responses = responses;
                        $scope.score = data.score.points;
                        $scope.maxScore = data.score.maxPoints;
                        $scope.percentScore = data.score.percentScore;
                        $scope.name = data.assessment.title;
                        $scope.isGetReportCallComplete = true;
                        $scope.firstName = data.firstName;
                        $scope.lastName = data.lastName;
                        $scope.masteredSkills = data.masteredSkills;
                        $scope.unMasteredSkills = data.unMasteredSkills;
                        $scope.$emit('uxfReportNative.summary.get.success', data);
                    }, function() {
                        $scope.isGetReportCallComplete = true;
                        $scope.$emit('uxfReportNative.summary.get.failure');
                    });
                });

                /*
                 * Set default values for params used in the  i18n strings in the template.
                 * The i18n string is evaluated in the compile phase
                 * and results in a javascript error log saying that the substitution values are undefined.
                 */
                $scope.score = 0;
                $scope.maxScore = 0;

                /*
                 * Using the response's index position, create an alpha string for the response's label.
                 * TODO - move to common bcoz question-directive has same routine
                 */
                $scope.responseLabel = function(answPosition) {
                    answPosition = answPosition || 0;
                    var newAnswLabel = String.fromCharCode((answPosition % 26) + 97).toUpperCase();
                    return newAnswLabel;
                };

                $scope.tryAgainAssessmentFromReport = function(event) {
                    $scope.$emit('assessment-player:tryAgain');
                };

                $scope.redirectQuestionFromReport = function(e, index) {
                    //See http://connect.microsoft.com/IE/feedback/details/802397/
                    //ie9-ie10-events-can-be-sent-to-the-wrong-listeners
                    if (e) {
                        e.preventDefault();
                    }
                    var targetPosition = index;
                    $scope.$emit('assessment-player:question:navigate', {targetPosition: targetPosition});
                };
                $scope.templateRoot = config('templateRoot');
            }]);

        module.directive('uxfReportNative', function() {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    sessionId: '@',
                    assessmentName: '@name',
                    isTryAgainVisible: '=',
                    itemLanguage: '@'
                },
                templateUrl: config('templateRoot') + '/report-native.html',
                controller: 'AssessmentPlayerReportController'
            };
        });

        return module;
    }
});
;
UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.ReportSkills',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'UXF.Common.i18n'],
    initFunc: function(angular, $, config, debug, i18n) {
        'use strict';

        var module = angular.module('AssessmentServices.Player.Directives.ReportSkills', []);

        module.directive('uxfReportSkills', function() {
            return {
                replace: true,
                scope: {
                    skillsHeader: '@',
                    skills:'=uxfReportSkills',
                    itemLanguage: '@'
                },
                templateUrl: config('templateRoot') + '/report/partials/skills.html',
                link: function(scope) {
                    scope.$watch('skills', function(skills) {
                        angular.forEach(skills, function(skill, index) {
                            if ((skill['spanish description'] && skill['spanish description'] !== '') &&
                                (scope.itemLanguage === 'Spanish' || i18n.getLang().toLowerCase() === 'es')) {
                                skill.description = skill['spanish description'];
                            }
                        });
                    });
                }
            };
        });

        return module;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.Splash',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug'],
    initFunc: function(angular, $, config, debug) {
        'use strict';

        var module;

        module = angular.module('AssessmentServices.Player.Directives.Splash', [
            'AssessmentServices.Player.Services.Player'
        ]);

        module.controller('AssessmentPlayerSplashController', [
            '$scope',
            'AssessmentPlayerService',
            function($scope, service) {

                var renderInstructions = function(type) {
                    $scope.instructions = service.getTestInstructions(type, $scope.playerTarget);
                    $scope.instructionAudioURL = service.getTestInstructionAudioURL(type);
                };

                if (angular.isDefined($scope.instructionsType)) {
                    renderInstructions($scope.instructionsType);
                }

                $scope.$on('player.assessmentTypeIsAvailable', function(e, type) {
                    renderInstructions(type);
                });

                $scope.startButton = function(event) {
                    if (event) {
                        event.preventDefault();
                    }
                    debug.log('Start!');
                    $scope.$root.$broadcast('assessment-player:splash:start');
                };
            }
        ]);

        module.directive('uxfAssessmentPlayerSplash', function() {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    name: '@name',
                    splashUrl: '@splashUrl',
                    playerTarget: '=',
                    instructionsType: '='
                },
                templateUrl: config('templateRoot') + '/splash.html',
                controller: 'AssessmentPlayerSplashController'
            };
        });

        return module;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Directives.Submit',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', '_'],
    initFunc: function(angular, $, config, debug, _) {
        'use strict';

        var module;

        module = angular.module('AssessmentServices.Player.Directives.Submit', [
            'AssessmentServices.Player.Services.Player'
        ]);

        module.controller('AssessmentPlayerSubmitController', [
            '$scope',
            'AssessmentPlayerService',
            function($scope, service) {
                var isGriddedResponseAnswered = function(questionResponse) {
                    var resp, delim, delimPos;

                    delim = questionResponse.question.responses[0].griddedResponseLayout.delim;
                    delimPos = questionResponse.question.responses[0].griddedResponseLayout.delimPosition;

                    if (!(questionResponse.userResponses && questionResponse.userResponses.length > 0 &&
                            questionResponse.userResponses[0].responseValue)) {
                        return false;
                    }
                    resp = questionResponse.userResponses[0].responseValue.trim();
                    if (resp === '') {
                        return false;
                    }

                    // if we have fixed delim, and only the delim char shows up in the answer, no
                    // user values provided...
                    if (delimPos >= 0) {
                        if (resp === delim) {
                            return false;
                        }
                    }

                    return true;
                };

                $scope.$on('player.assessmentTypeIsAvailable', function(e, type) {
                    $scope.submitMessage = service.getSubmitMessage(type, $scope.playerTarget);
                });

                $scope.redirectQuestion = function(e, index) {
                    //See http://connect.microsoft.com/IE/feedback/details/802397/
                    // ie9-ie10-events-can-be-sent-to-the-wrong-listeners
                    if (e) {
                        e.preventDefault();
                    }

                    var targetPosition = index;
                    $scope.$emit('assessment-player:question:navigate', {targetPosition: targetPosition});
                };

                // Update isNativeTarget on playerTarget value change for each tab switch on student lesson viewer
                $scope.$watch('playerTarget', function(newVal, oldVal) {
                    $scope.isNativeTarget = service.isNativeTarget($scope.playerTarget);
                });

                $scope.$on('showSubmitScreen', function(event, eventData) {
                    if (eventData.sequence) {
                        //TestNav or MathXL assessment
                        service.review($scope.sessionId, eventData.sequence).then(function(response) {
                            $scope.listOfQuestion = response.questionIds;
                            $scope.isAnsweredStatuses = response.isAnsweredStatuses;
                            $scope.numberOfQuestion = response.isAnsweredStatuses.length;
                            $scope.isSubmitEnabled = true; //Always enabled
                            $scope.isQuestionAnswered = _.groupBy(response.isAnsweredStatuses, function(status) {
                                return status;
                            });
                            if ($scope.isQuestionAnswered.Complete) {
                                $scope.answeredQuestion = $scope.isQuestionAnswered.Complete.length;
                            } else {
                                $scope.answeredQuestion = 0;
                            }
                            $scope.allQuestionAnswered = $scope.answeredQuestion === $scope.numberOfQuestion;
                            $scope.isGetReviewCallComplete = true;
                            $scope.$emit('uxfReviewItemPlayer.summary.get.success');
                        }, function() {
                            $scope.isGetReviewCallComplete = true;
                            $scope.$emit('uxfReviewItemPlayer.summary.get.failure');
                        });
                    } else {
                        //Native assessment
                        service.finalReport($scope.sessionId,
                                eventData.areAllQuestionsAnswered).then(function(response) {
                            var unansweredQuestions = [],
                                areAllQuestionsAnswered,
                                answeredQuestion,
                                isQuestionAnswered,
                                mustAnswerAllQuestions = response.mustAnswerAllQuestions;
                            $scope.numberOfQuestion = response.questionResponseDefinitions.length;
                            $scope.listOfQuestion = response.questionResponseDefinitions;

                            // loop over questions to find any that aren't answered
                            angular.forEach(response.questionResponseDefinitions, function(questionResponse, index) {
                                // no user responses = question not answered
                                if (!questionResponse.userResponses || questionResponse.userResponses.length === 0) {
                                    unansweredQuestions.push({ 'position': index,
                                        'text': questionResponse.question.text });
                                // for gridded response, have to also check if the last user response is empty
                                } else if (questionResponse.question.questionType.toLowerCase() ===
                                    'gridded_response' && !isGriddedResponseAnswered(questionResponse)) {
                                    unansweredQuestions.push({ 'position': index });
                                }

                                questionResponse.isQuestionAnswered = _.first(questionResponse.userResponses);

                            });
                            answeredQuestion = _.filter($scope.listOfQuestion, function(q) {
                                return q.isQuestionAnswered && q.isQuestionAnswered.answered;
                            });

                            $scope.answeredQuestion = answeredQuestion.length;
                            $scope.allQuestionAnswered = $scope.answeredQuestion === $scope.numberOfQuestion;
                            areAllQuestionsAnswered = (unansweredQuestions.length === 0);
                            $scope.areAllQuestionsAnswered = areAllQuestionsAnswered;
                            $scope.mustAnswerAllQuestions = mustAnswerAllQuestions;
                            $scope.unansweredQuestions = unansweredQuestions;
                            $scope.isGetReviewCallComplete = true;
                            $scope.$emit('uxfReviewNative.summary.get.success');
                        }, function() {
                            $scope.isGetReviewCallComplete = true;
                            $scope.$emit('uxfReviewNative.summary.get.failure');
                        });
                    }
                });
            }
        ]);

        module.directive('uxfAssessmentPlayerSubmit', function() {
            return {
                restrict: 'A',
                replace: false,
                scope: {
                    sessionId: '@sessionId',
                    name: '@name',
                    isSubmitEnabled: '=',
                    playerTarget: '='
                },
                templateUrl: config('templateRoot') + '/submit.html',
                controller: 'AssessmentPlayerSubmitController'
            };
        });

        return module;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Filters.i18n',
    initArgs: ['angular', 'UXF.Common.i18n'],
    initFunc: function(angular, i18n) {
        'use strict';

        var module = angular.module('AssessmentServices.Player.Filters.i18n', []);

        module.filter('uxfLocalize', function() {
            // TODO: add support  pluralization
            /*
             * @param key - the key present in file locales/en-US/assessmentplayer.js to be used for translation
             * @args - the array of values for replacement in target string - (optional)
             */
            return function(key, args) {
                if (key) {
                    return i18n.local(key, args);
                }

                return undefined;
            };
        });
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Filters.trunc',
    initArgs: ['angular'],
    initFunc: function(angular) {
        'use strict';

        var module = angular.module('AssessmentServices.Player.Filters.trunc', []);
        module.filter('trimLeadingZeros', function() {
            return function(input) {
                if (input === null || input === undefined) {
                    return input;
                } else if (input === 0) {
                    return 0;
                } else {
                    return input.toString().replace(/^0+/, '');
                }
            };
        });
    }
});
;/*global Paf*/
UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Paf',
    initFunc: function() {
        'use strict';

        return Paf;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.ActivityManager',
    initArgs: [
        'angular',
        'jQuery',
        'UXF.AssessmentPlayer.Config',
        'debug',
        'UXF.Common.i18n',
        'UXF.AssessmentPlayer.Paf',
        '_'
    ],
    initFunc: function(angular, $, config, debug, i18n, Paf, _) {
        'use strict';

        var module, factory;

        module = angular.module('AssessmentServices.Player.Services.ActivityManager', []);

        /**
         * All Player Frame communication should be proxied by this class.
         * This will make it easiest to handle various message and check security.
         */
        factory = module.factory('ActivityManager', [
            '$q',
            '$rootScope',
            'ActivityPlayerLoader',
            function($q, $rootScope, ActivityPlayerLoader) {

                var activityPlayerLoader;

                function ActivityManager(hubService) {
                    // hash table to store nodeResultRequests
                    this._nodeResultRequests = {};

                    this._hubService = hubService;

                    var frameIdentifier = '#' + hubService.ACTIVITY_FRAME_ID,
                        playerFrame = $(frameIdentifier)[0];
                    activityPlayerLoader = new ActivityPlayerLoader(playerFrame, frameIdentifier);
                    this.setPlayerLoader(activityPlayerLoader);
                }

                ActivityManager.prototype = {

                    //OVERWRITE PAF DEFAULTS
                    _processSequenceNodeLoaded: function(evt, message) {
                        var self = this,
                            sequenceNodeId = message.sequenceNodeId;

                        if (self._loadingNode && self._loadingNode['@id'] === sequenceNodeId) {
                            self._currentNode = self._loadingNode;
                        }

                        if (self._deferredSequenceNode) {
                            // Need to resolve deferred inside an apply for angular otherwise it won't get fired until
                            // you click something.
                            $rootScope.$apply(function() {
                                self._deferredSequenceNode.resolve(self._currentNode);
                            });
                        }

                        $(self).trigger(self.EVENT_ITEM_LOADED);
                    },

                    _processNodeResult: function(evt, nodeResult) {
                        //debug.log('_processNodeResult: nodeResult received.');
                        var self,
                            messageId,
                            requestMessage,
                            callback,
                            isTestNav;

                        self = this;

                        messageId = nodeResult.originalMsgId;

                        // Validate existence of sequenceNodeId
                        if (!messageId) {
                            debug.log('NodeResultResponse from item player is missing the messageId', 'danger');
                            return;
                        }

                        requestMessage = self._nodeResultRequests[messageId];
                        if (!requestMessage) {
                            //May consider doing an alert here to make it easier when a custom reports it.
                            debug.log('RequestNodeResult message for messageId ' + messageId +
                                ' can not be found.', 'danger');
                            return;
                        }

                        isTestNav = activityPlayerLoader._playerFrame.src.indexOf('testnav') >= 0;
                        if (requestMessage.statusCode === 202 && isTestNav) {
                            debug.log('ItemPlayer not ready to move on', requestMessage);
                            return;
                        }

                        //Remove this message request from the dictionary.
                        delete self._nodeResultRequests[messageId];

                        // Double check the sequenceNodeId returned by the Player with that of the request.
                        //  They should match. The messageId should be the sequenceNodeId.
                        if (requestMessage.sequenceNodeId !== messageId) {
                            debug.log('NodeResult contains a sequenceNode that does not match requested sequenceNode');
                            return;
                        }

                        callback = requestMessage.callback;
                        if (callback) {
                            callback();
                        }
                    },

                    setOnItemLoaded: function(onItemLoaded) {
                        if (_.isFunction(onItemLoaded)) {
                            $(this).on(this.EVENT_ITEM_LOADED, onItemLoaded);
                        }
                    },

                    //202 NodeResultResponse
                    setOnNodeResultRequestAccepted: function(onNodeResultRequestAccepted) {
                        if (_.isFunction(onNodeResultRequestAccepted)) {
                            this._processNodeResultRequestAccepted = onNodeResultRequestAccepted;
                            activityPlayerLoader.bind(activityPlayerLoader.EVENT_NODE_RESULT_REQUEST_ACCEPTED,
                                this._processNodeResultRequestAccepted, this);
                        }
                    },

                    getSequenceNode: function(sessionId, questionId, cache) {
                        var self = this;
                        self._checkHubService();
                        return self._hubService.getSequenceNode(sessionId, self._sequence, questionId, cache);
                    },

                    //CUSTOM
                    _currentNode: null,

                    _loadingNode: null,

                    _messageIds: [],

                    // When requesting the node result, we need to know why we are doing it so when
                    // we it's finished we know what to do.
                    _requestItemNodeResult: function(sequenceNode, callback) {
                        var self,
                            sequenceNodeId,
                            msgId,
                            request;

                        self = this;

                        // we need to move deferred to the loading of the sequenceNode
                        // So removing defferred here.
                        sequenceNodeId = sequenceNode['@id'];
                        //For now, msgId can be sequenceNodeId assuming it's unique per assignment.
                        msgId = sequenceNodeId;
                        debug.log('_requestItemNodeResult: called for ', msgId);

                        //Store off the callback and sequenceNodeId for later
                        self._nodeResultRequests[msgId] = {
                            sequenceNodeId: sequenceNodeId,
                            callback: callback
                        };

                        request = {
                            '@context': 'http://purl.org/pearson/paf/v1/ctx/core/NodeResultRequest',
                            '@type': 'NodeResultRequest',
                            msgId: msgId,
                            requestedNode: sequenceNodeId,
                            sessionId: sequenceNode.sessionId
                        };

                        self.postPlayerMessage(request);
                    },

                    _displaySequenceNode: function(sequenceNode) {
                        //debug.log('displaySequenceNode: ', sequenceNode);

                        var self = this,
                            playerUrl = sequenceNode.player.frameFrontend.frameURI;

                        //only set currentNode when loaded.
                        self._loadingNode = sequenceNode;

                        return self.loadPlayer(playerUrl).then(
                            function() {
                                //debug.log('displaySequenceNode: playerLoaded');
                                self._deferredSequenceNode = $q.defer();

                                self.postSequenceNode(sequenceNode);

                                return self._deferredSequenceNode.promise;
                            }
                        );
                    },

                    setSequence: function(sequence) {
                        var self = this;
                        self._sequence = sequence;
                    },

                    playItem: function(sessionId, questionId, cache) {
                        //debug.log('playItem: Get current question - ' + questionId);

                        var self = this;

                        return self.getSequenceNode(sessionId, questionId, cache).then(
                            function(sequenceNode) {
                                return self._displaySequenceNode(sequenceNode);
                            }
                        );
                    },

                    postStudentResponse: function(sessionId, questionId, callback) {
                        var self = this,
                            currentSequenceNode;
                        if (self._currentNode && self._currentNode.targetBinding &&
                            self._currentNode.targetBinding['@id'] === questionId) {
                            self._requestItemNodeResult(self._currentNode, callback);
                        } else {
                            currentSequenceNode = self.getSequenceNode(sessionId, questionId);

                            currentSequenceNode.then(
                                function(currentSequenceNode) {
                                    self._requestItemNodeResult(currentSequenceNode, callback);
                                }
                            );
                        }
                    },

                    hidePlayer: function() {
                        activityPlayerLoader.hidePlayer();
                    },

                    showPlayer: function() {
                        activityPlayerLoader.showPlayer();
                    },

                    unregisterMessageHandler: function() {
                        activityPlayerLoader._unregisterMessageHandler();
                    }
                };

                ActivityManager.prototype = angular.extend({},
                    Paf.ActivityManagerBase.prototype,
                    ActivityManager.prototype
                );

                return ActivityManager;
            }
        ]);

        return factory;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.ActivityPlayerLoader',
    initArgs: [
        'angular',
        'jQuery',
        'UXF.AssessmentPlayer.Config',
        'debug',
        'UXF.Common.i18n',
        'window',
        'UXF.AssessmentPlayer.Paf',
        '_'
    ],

    initFunc: function(angular, $, config, debug, i18n, window, Paf, _) {
        'use strict';

        var module, factory;

        module = angular.module('AssessmentServices.Player.Services.ActivityPlayerLoader', []);

        /**
         * All Player Frame communication should be proxied by this class.
         * This will make it easiest to handle various message and check security.
         */
        factory = module.factory('ActivityPlayerLoader', [
            '$q',
            '$rootScope',
            '$log',
            'BrowserUtil',
            'AssessmentPlayerService',
            function($q, $rootScope, $log, BrowserUtil, assessmentPlayerService) {
                var playerContext, messageListener, resizeIframeHeight;

                function ActivityPlayerLoader(playerFrame, frameIdentifier) {
                    this._playerFrame = playerFrame; //needs a check to make sure element exists on page
                    this._frameIdentifier = frameIdentifier;
                    playerContext = this;
                    this._registerMessageHandler();
                }

                resizeIframeHeight = function() {
                    var rubricContentHeight,
                        iframeContentHeight = angular.element(playerContext._playerFrame)
                        .contents().find('body').height();
                    debug.log(iframeContentHeight);
                    angular.element(playerContext._playerFrame).height(iframeContentHeight);
                    // setting rubric panel height for iPad testnav manual scoring page
                    // adding extra 60 for header and footer
                    rubricContentHeight = iframeContentHeight + 60;
                    angular.element(window.document.getElementById('rubricManualScoring')).height(rubricContentHeight);
                };

                messageListener = function(e) {
                    var context = playerContext,
                        message;
                    // Do security check here.  If we pass then interpret data.
                    // Do security check and make sure this message has originated from our frame.
                    if (e.source !== context._playerFrame.contentWindow) {
                        debug.log('PAF Activity Manager: Source does not match expected window ',
                            e.source, ' != ', context._playerFrame.contentWindow);
                        return;
                    }
                    // Security check passed so process the message
                    message = $.parseJSON(e.data);

                    //debug.log('PAF Activity Manager received message: ', message);
                    context._handleMessage(message);
                };

                ActivityPlayerLoader.prototype = {
                    //OVERWRITE PAF DEFAULTS
                    _handleMessage: function(message) {
                        var _scope,
                            _parentScope;
                        if (message && message.hasOwnProperty('@type')) {
                            switch (message['@type']) {
                                case 'PlayerReady':
                                    if (message['@context'] !== 'http://purl.org/pearson/paf/v1/ctx/core/PlayerReady') {
                                        debug.log('PAF Activity Manager received unexpected message context.');
                                        //TODO PlayerReady Error Handler
                                    }
                                    this._playerReady();
                                    break;
                                case 'NodeResultResponse':
                                    $('#correctAnswerItemPlayer').remove();
                                    _scope = angular.element('#studentAndCorrectResponses').scope();
                                    if (_scope) {
                                        _parentScope = _scope.$parent;
                                        _parentScope.showCorrectAnswersTab = false;
                                        _parentScope.$apply();
                                    }
                                    this._handleNodeResult(message);
                                    break;
                                case 'SequenceNodeLoaded':
                                    this._handleSequenceNodeLoaded(message);
                                    break;
                                    // Check result
                                case 'CheckResult':
                                    this._handleCheckResult(message);
                                    break;
                                case 'ToggleUI': //MATHXL
                                    this._handleToggleUI(message);
                                    break;
                                case 'ToggleStandby': //MATHXL
                                    this._handleToggleStandby(message);
                                    break;
                                case 'TestNav.VoiceRecordingStarted':
                                case 'TestNav.VoiceRecordingStopped':
                                    this._handleToggleUI(message);
                                    break;

                                default:
                                    debug.log('PAF Activity Manager received unknown message: ', message);
                                    break;
                            }
                        } else {
                            debug.log('PAF Activity Manager received unknown message without type: ', message);
                        }
                    },

                    _handleNodeResultRequestAccepted: function(message) {
                        $(this).trigger(this.EVENT_NODE_RESULT_REQUEST_ACCEPTED, message);
                    },

                    _registerMessageHandler: function() {
                        window.addEventListener('message', messageListener, false);
                    },

                    _unregisterMessageHandler: function() {
                        window.removeEventListener('message', messageListener, false);
                    },

                    _playerReady: function() {
                        var deferred = this._playerReadyDeferred;
                        if (deferred) {
                            deferred.resolve();
                            if (!$rootScope.$$phase) {
                                $rootScope.$apply();
                            }
                        }
                    },

                    _loadPlayer: function(playerUri, sourceLoader) {
                        this._playerReadyDeferred = $q.defer();

                        sourceLoader.apply(this, [playerUri]);

                        //TODO add timeout to trigger _playerReady OR PlayerReady error handler?

                        return this._playerReadyDeferred.promise;
                    },

                    //Creates new iframe with url, so backspace on iframe (non-input) will
                    // behave properly as there is no iframe history to go back to
                    _replaceIFrame: function(url) {
                        var iFrameId = this._frameIdentifier.substr(1), //remove #
                            originalFrame = window.document.getElementById(iFrameId),
                            newFrame = window.document.createElement('iframe'),
                            ariaAttrs = {},
                            parent;

                        newFrame.id = originalFrame.getAttribute('id');
                        newFrame.width = originalFrame.getAttribute('width');
                        newFrame.height = originalFrame.getAttribute('height');
                        newFrame.frameBorder = originalFrame.getAttribute('frameBorder');
                        newFrame.title = originalFrame.getAttribute('title');
                        newFrame.name = originalFrame.getAttribute('name') || 'content';
                        newFrame.style.visibility = originalFrame.style.visibility;
                        newFrame.style.opacity = originalFrame.style.opacity;
                        newFrame.src = url;
                        _.each(originalFrame.attributes, function(attrs) {
                            if (attrs.nodeName.match(/^aria\-/)) {
                                ariaAttrs[attrs.nodeName] = attrs.nodeValue;
                            }
                        });

                        parent = originalFrame.parentNode;
                        parent.replaceChild(newFrame, originalFrame);

                        this._playerFrame = $(this._frameIdentifier)[0];
                        if (!_.isEmpty(ariaAttrs)) {
                            $(this._frameIdentifier).attr(ariaAttrs);
                        }

                    },

                    _loadFrameSource: function(playerUri) {
                        var self = this,
                            isTestNav = playerUri.indexOf('testnav') >= 0,
                            showQuestionCorrectness;
                        playerContext.isTestNav = isTestNav;
                        if (!self._playerFrame) {
                            /* it's possible for the activity manager to be initialized before
                             * the iframe DOM element renders. So need to set self._playerFrame
                             * if it's not there. */
                            self._playerFrame = $(self._frameIdentifier)[0];
                        }

                        if (isTestNav && config('testNavPreviewApiUrl')) {
                            //Specify language & previewer url and build number
                            playerUri = playerUri + '?testNavPreviewApiUrl=' + config('testNavPreviewApiUrl');
                            playerUri = playerUri + '&lang=' + UXF.Common.i18n.getLang();
                            playerUri = config('buildNumber') ? playerUri + '&buildNumber=' + config('buildNumber') :
                                    playerUri;
                            showQuestionCorrectness = assessmentPlayerService.getIsScoreSent();
                            playerUri = playerUri + '&showQuestionCorrectness=' + showQuestionCorrectness;
                        }

                        if (this._playerFrame.src !== playerUri || isTestNav || !this._playerFrame.contentWindow) {
                            this.hidePlayer();
                            debug.log('Player loading...', playerUri);
                            if (this._playerFrame.src === playerUri && isTestNav && this._playerFrame.contentWindow) {
                                this._playerFrame.contentWindow.location.reload(); //Force reload
                            } else {
                                this._replaceIFrame(playerUri);
                            }
                        } else {
                            debug.log('Player src already loaded.', playerUri);
                            this._playerReady();
                        }
                    },

                    hidePlayer: function() {
                        $(this._playerFrame).css({
                            visibility: 'hidden', //FF breaks with display:none
                            opacity: 0 //iOS does not hide with visibility:hidden when loading xlplayer src url
                        });
                        if (playerContext.isTestNav && BrowserUtil.isIOS()) {
                            var iframe = angular.element(this._playerFrame),
                                iframeContent;
                            //check for iframe content window for hidePlayer and then only proceed
                            if (angular.isDefined(iframe.contentWindow)) {
                                iframeContent = angular.element(this._playerFrame).contents().find('body');
                                iframeContent.off('resize', resizeIframeHeight);
                            }
                        }
                    },

                    showPlayer: function() {
                        $(this._playerFrame).css({
                            display: 'block',
                            visibility: 'visible',
                            opacity: 1
                        });
                        //Fix iOS Scroll
                        if (playerContext.isTestNav && BrowserUtil.isIOS()) {
                            var iframeContent = angular.element(this._playerFrame).contents().find('body');
                            iframeContent.resize(resizeIframeHeight);
                        }
                    },

                    EVENT_NODE_RESULT_REQUEST_ACCEPTED: 'NodeResultResponseStatus202'
                };

                ActivityPlayerLoader.prototype = angular.extend({},
                    Paf.ActivityPlayerLoader.prototype,
                    ActivityPlayerLoader.prototype
                );

                return ActivityPlayerLoader;
            }
        ]);

        return factory;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.Helpers.BrowserUtil',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'window'],
    initFunc: function(angular, $, config, debug, window) {
        'use strict';

        var module, factory;

        module = angular.module('AssessmentServices.Player.Services.Helpers.BrowserUtil', []);

        factory = module.factory('BrowserUtil', function() {
            var svc = this,
                userAgent = window.navigator.userAgent;

            svc.isIOS = function() {
                return (/(iPad|iPhone|iPod)/g).test(userAgent);
            };

            svc.isAndroid = function() {
                return (/android/i).test(userAgent);
            };

            svc.isIOS7 = function() {
                return (/iPad;.*CPU.*OS 7_\d/i).test(userAgent);
            };

            svc.isIpad = function() {
                return (/iPad/i).test(userAgent);
            };

            svc.isChrome = function() {
                return (/chrome|crios|crmo/i).test(userAgent);
            };

            svc.isWin7 = function() {
                return (/Windows NT 6.1/i).test(userAgent);
            };

            return svc;
        });

        return factory;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.Helpers.HeightUtil',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'window'],
    initFunc: function(angular, $, config, debug, window) {
        'use strict';

        var module, factory;

        module = angular.module('AssessmentServices.Player.Services.Helpers.HeightUtil', [
            'AssessmentServices.Player.Services.Helpers.BrowserUtil'
        ]);

        factory = module.factory('HeightUtil', ['BrowserUtil', function(BrowserUtil) {
            var svc = this;

            svc.getPageHeight = function() {
                if (BrowserUtil.isIOS7()) {
                    return window.innerHeight;
                } else {
                    return angular.element('html').height();
                }
            };

            //http://stackoverflow.com/questions/19012135/
            //ios-7-ipad-safari-landscape-innerheight-outerheight-layout-issue
            svc.applyIOS7HeightFix = function() {
                if (BrowserUtil.isIOS7()) {
                    angular.element('html').addClass('ipad ios7');
                }
            };

            svc.removeIOS7HeightFix = function() {
                if (BrowserUtil.isIOS7()) {
                    angular.element('html').removeClass('ipad ios7');
                }
            };

            svc.getPlayerBodyHeight = function() {
                var elBody,
                    getCssPropertyInt,
                    offsetTop,
                    headerHeight,
                    footerHeight,
                    availableHeightBody,
                    minHeightBody,
                    maxHeightBody,
                    playerFooters;

                elBody = angular.element('.uxf-assessment-player-body');

                getCssPropertyInt = function(el, cssProperty) {
                    return parseInt(el.css(cssProperty), 10) || 0;
                };

                offsetTop = angular.element('.uxf-assessment-player-header').offset().top;

                headerHeight = angular.element('.uxf-assessment-player-header').height();
                playerFooters = angular.element('.uxf-assessment-player-footer');
                if (playerFooters.length > 1) {
                    footerHeight = angular.element(playerFooters[1]).height();
                } else {
                    footerHeight = angular.element('.content-controlbar').height() || playerFooters.height();
                }
                availableHeightBody =
                    svc.getPageHeight() - offsetTop - headerHeight - footerHeight -
                        getCssPropertyInt(elBody, 'padding-top') - getCssPropertyInt(elBody, 'padding-bottom');

                minHeightBody = getCssPropertyInt(elBody, 'min-height');
                maxHeightBody = getCssPropertyInt(elBody, 'max-height') || availableHeightBody;

                return Math.max(minHeightBody, Math.min(maxHeightBody, availableHeightBody));
            };

            return svc;
        }]);

        return factory;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.ItemPlayerService',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'window'],
    initFunc: function(angular, $, config, debug, window) {
        'use strict';

        var module, factory;

        module = angular.module('AssessmentServices.Player.Services.ItemPlayer', [
            'AssessmentServices.Player.Services.Player'
        ]);

        factory = module.factory('ItemPlayerService', ['AssessmentPlayerService', function(AssessmentPlayerService) {
            var svc = this;

            this.ACTIVITY_FRAME_ID = 'itemPlayer';

            this.getSequenceNode = function(sessionId, sequence, questionId, cache) {
                return AssessmentPlayerService.sequenceNode(sessionId, sequence, questionId, cache)
                    .then(function(data) {
                        var sequenceNode, isSecureSite, themeQuery, queryIndex;

                        sequenceNode = data;
                        sequenceNode.assessmentSessionId = sessionId;

                        isSecureSite = window.location.protocol === 'https:';

                        if (isSecureSite) {
                            sequenceNode.player.frameFrontend.frameURI =
                                sequenceNode.player.frameFrontend.frameURI.replace(/^http:\/\//i, 'https://');
                        }

                        if (sequence.theme) {
                            themeQuery = 'discipline=' + sequence.theme + '&theme=' + sequence.theme;
                            queryIndex = sequenceNode.player.frameFrontend.frameURI.indexOf('?');
                            if (queryIndex === -1) {
                                sequenceNode.player.frameFrontend.frameURI =
                                    sequenceNode.player.frameFrontend.frameURI + '?' + themeQuery;
                            } else {
                                sequenceNode.player.frameFrontend.frameURI =
                                    sequenceNode.player.frameFrontend.frameURI + '&' + themeQuery;
                            }
                        }
                        sequenceNode.sessionId = sequence.sessionId; //PAF
                        return sequenceNode;
                    });
            };

            this.getNewSessionWithReviewMode = function(sessionId) {
                /* testnav doesn't actually need this to enable
                 * review mode. It derives it from a PAF value and determines
                 * whether to open in review mode. But MathXL needs
                 * the activity manager to make a fetch for a new paf session,
                 * which causes a review mode flag to be toggled on. This needs
                 * to be part of the PAF standard, or mathxl needs to change its behavior.
                 */
                return AssessmentPlayerService.sessionSummary(sessionId).then(function(sessionSummary) {
                    return sessionSummary;
                });
            };

            return svc;
        }]);

        return factory;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Services.PlayerService',
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'debug', 'UXF.Common.i18n', '_'],
    initFunc: function(angular, $, config, debug, i18n, _) {
        'use strict';

        var module, responseReaderFn, factory,
        isScoreSent = true;

        module = angular.module('AssessmentServices.Player.Services.Player', ['ngResource']);
        module.constant('QUESTION_TYPES', {
                GRIDDED_RESPONSE: 'gridded-response',
                MULTIPLE_CHOICE: 'multiple-choice'
            })
            .constant('QUESTION_STATUS', {
                COMPLETE: 'complete',
                INCOMPLETE: 'incomplete'
            });

        factory = module.factory('AssessmentPlayerService', [
            '$http',
            '$resource',
            '$q',
            function($http, $resource, $q) {
                var ret = {};

                ret.keepAlive = function(assessmentSessionId, sequence) {
                    var url = [config('contextPath'), 'assessment', assessmentSessionId, 'current'].join('/'),
                        headerConfigs = {
                            'Hub-Session': sequence.sessionId
                        },
                        httpConfigs = {
                            method: 'PUT',
                            url: url,
                            headers: headerConfigs
                        };
                    return $http(httpConfigs);
                };

                /**
                 * Get the sessionSummary info for a session.
                 *
                 * @param sessionId the sessionId
                 */
                ret.sessionSummary = function(sessionId) {
                    var url = [config('contextPath'), 'assessment', sessionId, 'summary.json'].join('/');
                    return $http.get(url)
                        .then(function(response) {
                            return response.data;
                        });
                };

                /**
                 * Fetch a question.
                 *
                 * @param sessionId
                 * @param questionId
                 */
                ret.question = function(sessionId, questionId) {
                    var url = [
                        config('contextPath'),
                        'assessment',
                        sessionId,
                        'question',
                        questionId + '.json'
                        ].join('/');
                    return $http.get(url)
                        .then(function(response) {
                            return response.data;
                        });
                };

                ret.sequenceNode = function(asessmentSessionId, sequence, questionId, cache) {
                    var data = {
                            'targetBinding': questionId,
                            'nodeCollectionUrl': sequence.nodeCollectionUrl,
                            'cacheNodes': !!cache
                        },
                        url;

                    url = config('contextPath') + '/assessment/' + asessmentSessionId + '/nodes.json';

                    return $http({
                            method: 'POST',
                            url: url,
                            params: data,
                            headers: {
                                'Hub-Session': sequence.sessionId
                            }
                        })
                        .then(function(response) {
                            return response.data;
                        });
                };

                ret.correctResponse = function(asessmentSessionId, questionId) {
                    var url;
                    questionId = questionId.match(/questions\/(.*)\/bindings/)[1];
                    url = config('contextPath') + '/assessments/' + asessmentSessionId +
                        '/question/' + questionId + '/answers';
                    return $http.get(url).then(function(response) {
                            return response.data;
                        });
                };

                /**
                 * Register a function that is responsible for reading the selected response
                 *
                 * @param readerFn
                 */
                ret.registerResponseReader = function(readerFn) {
                    responseReaderFn = readerFn;
                };

                ret.setMessageHandler = function(handlerFn) {
                    ret.messageHandlerFunction = handlerFn;
                };

                ret.invokeMessageHandler = function(code, messageType, rawMessage) {
                    ret.messageHandlerFunction(code, messageType, rawMessage);
                };

                /**
                 * Post a response to the server.  Depends on registerResponseReader
                 * having been called already.
                 *
                 * @param isAnswerRevealed - whether or not the user would get a feedback
                 * indicating correct or incorrect answer
                 * @param isResponseCommited - whether or not this result is the 'final answer'
                 * @param successFn
                 * @param errorFn
                 */
                ret.postResponse = function(isAnswerRevealed, isResponseCommited, successFn, errorFn) {
                    var responseData;

                    if (!responseReaderFn) {
                        if (errorFn) {
                            throw 'No response reader function registered.';
                        }
                    }

                    responseData = responseReaderFn();
                    if (!responseData) {
                        // no changes required, assume success.
                        successFn(null);
                        return;
                    }

                    ret.response(responseData.sessionId, responseData.questionId,
                            responseData.responseId, responseData.responseText, responseData.isAnswered,
                            isAnswerRevealed, isResponseCommited)
                        .then(function(data) {
                            successFn(data);
                        }, function(error) {
                            errorFn(error);
                        });
                };

                /**
                 * post the response
                 *
                 * @param sessionId
                 * @param questionId
                 * @param responseId - the id of the selected response in the question (required)
                 * @param responseText - the free-flowing answer
                 * (e.g. answer to a gridded response type question, optional)
                 * @param isAnswerRevealed - whether or not the user would get a
                 * feedback indicating correct or incorrect answer
                 * @param isResponseCommited - whether or not this result is the 'final answer'
                 */
                ret.response = function(sessionId, questionId, responseId, responseText,
                        isAnswered, isAnswerRevealed, isResponseCommited) {
                    var url = [
                            config('contextPath'),
                            'assessment',
                            sessionId,
                            'question',
                            questionId,
                            'response.json'
                        ].join('/'),

                        params = {
                            responseId: responseId,
                            isAnswered: isAnswered,
                            answerRevealed: isAnswerRevealed,
                            commit: isResponseCommited
                        };

                    if (responseText) {
                        //the textual answer for gridded-response type question
                        params.responseValue = responseText;
                    }

                    return $http({
                            method: 'POST',
                            url: url,
                            params: params
                        })
                        .then(function(response) {
                            return response.data;
                        });
                };

                /**
                 * Check the final report.
                 *
                 * @param sessionId
                 * @param isFinalReport
                 */
                ret.finalReport = function(sessionId, isFinalReport) {
                    var url = [config('contextPath'), 'assessment', sessionId, 'user.json'].join('/');

                    return $http.get(url, {
                        params: {
                            returnOnlyCommittedResponses: isFinalReport
                        }
                    }).then(function(response) {
                        return response.data;
                    });
                };

                /**
                 * Return the data for the native Score Summary report.
                 */
                ret.getFinalReportAndUserName = function(sessionId, isFinalReport) {
                    return $q.all([ret.finalReport(sessionId, isFinalReport),
                            ret.skills(sessionId), ret.getUserAssignmentUserName(sessionId)]).then(function(response) {
                        var finalRpt = response[0],
                            skillCodeToDetailsMap = response[1],
                            userAssignmentUserName = response[2];

                        finalRpt.masteredSkills =
                            ret.getSkillDetailsList(finalRpt.masteredSkills, skillCodeToDetailsMap);
                        finalRpt.unMasteredSkills =
                            ret.getSkillDetailsList(finalRpt.unMasteredSkills, skillCodeToDetailsMap);
                        finalRpt.firstName = userAssignmentUserName.firstName;
                        finalRpt.lastName = userAssignmentUserName.lastName;

                        return finalRpt;
                    });
                };

                ret.result = function(sessionId, sequence) {
                    var httpConfigs = {
                        url: config('contextPath') + '/assessment/' + sessionId + '/results',
                        method: 'GET'
                    };

                    if (sequence) {
                        httpConfigs.headers = {
                            'Hub-Session': sequence.sessionId
                        };
                    }

                    return $http(httpConfigs).then(function(response) {
                        return response.data;
                    });
                };

                ret.review = function(sessionId, sequence) {
                    var httpConfigs = {
                        url: config('contextPath') + '/assessment/' + sessionId + '/review',
                        method: 'GET'
                    };

                    if (sequence) {
                        httpConfigs.headers = {
                            'Hub-Session': sequence.sessionId
                        };
                    }

                    return $http(httpConfigs).then(function(response) {
                        return response.data;
                    });
                };

                ret.getUserAssignmentData = function(sessionId) {
                    var url = config('contextPath') + '/assessment/' + sessionId + '/userAssignmentData';
                    return $http.get(url).then(function(response) {

                        var responseData = response.data;
                        isScoreSent = responseData && responseData.scoreSent;

                        return responseData;
                    });
                };

                ret.setIsScoreSent = function(scoreSentIn) {
                    isScoreSent = scoreSentIn;
                };

                ret.getIsScoreSent = function() {
                    return isScoreSent;
                };

                ret.getUserAssignmentUserName = function(sessionId) {
                    var url = config('contextPath') + '/assessment/' + sessionId + '/userAssignmentUserName';
                    if (config('useAssignmentFacadeService')) {
                        url = url + '?v2=true';
                    }
                    return $http.get(url).then(function(response) {
                        return response.data;
                    });
                };

                /*
                 * @param {string} sessionId
                 * @returns {json} Map of skill codes to skill description
                 */
                ret.skills = function(sessionId) {
                    var url = config('contextPath') + '/assessment/' + sessionId + '/skills';
                    return $http.get(url).then(function(response) {
                        return response.data;
                    });
                };

                ret.getSkillDetailsList = function(skillCodeList, skillCodeToDetailsMap) {
                    var skillDetailsList = _.map(skillCodeList, function(skillCode) {
                            return skillCodeToDetailsMap[skillCode];
                        }),

                        validDetails = _.reject(skillDetailsList, function(details) {
                            return details === undefined || details === null || _.isEmpty(details);
                        });

                    return _.uniq(validDetails);
                };

                /*
                 * @param {string} sessionId
                 * @returns {json} Question scores, skill details, user name
                 */
                ret.getScoreSummaryAndSkills = function(sessionId, sequence) {
                    return $q.all([ret.result(sessionId, sequence), ret.skills(sessionId),
                            ret.getUserAssignmentUserName(sessionId)]).then(function(response) {
                        var summary = response[0],
                            skillCodeToDetailsMap = response[1],
                            userAssignmentUserName = response[2];

                        summary.masteredSkills = ret.getSkillDetailsList(summary.masteredSkills, skillCodeToDetailsMap);
                        summary.unMasteredSkills =
                            ret.getSkillDetailsList(summary.unMasteredSkills, skillCodeToDetailsMap);
                        summary.firstName = userAssignmentUserName.firstName;
                        summary.lastName = userAssignmentUserName.lastName;

                        return summary;
                    });
                };

                /**
                 *
                 * TODO
                 *
                 * @param sessionId
                 * @param questionId
                 * @param success
                 *
                 * ret.checkResponse = function(sessionId, questionId, responseId, success) {};
                 */

                /**
                 * Complete an assessment
                 *
                 * @param sessionId - the session to complete
                 * @param sequence
                 */
                ret.completeAssessment = function(sessionId, sequence, playerTarget) {
                    var httpConfigs = {
                        url: config('contextPath') + '/assessment/' + sessionId + '/complete.json',
                        method: 'PUT'
                    };

                    if (sequence) {
                        httpConfigs.headers = {
                            'Hub-Session': sequence.sessionId,
                            'playerTarget': playerTarget
                        };
                    }

                    return $http(httpConfigs)
                        .then(function(response) {
                            return response.data;
                        });
                };

                ret.getSubmitMessage = function(type, playerTarget) {
                    var keycode = 'assessment-player.submit.message';

                    if (ret.isMathXlTarget(playerTarget)) {
                        type = type.toLowerCase();
                        return [keycode, playerTarget, type].join('.');
                    }

                    return [keycode, 'default'].join('.');
                };

                ret.getTestInstructions = function(type, playerTarget) {
                    if (!type) {
                        return '';
                    }

                    switch (type.toLowerCase()) {
                        case 'practice':
                            return 'assessment-player.splash.instructions.default.practice';
                        case 'prep':
                            return 'assessment-player.splash.instructions.default.prep';
                        case 'homework':
                            if (ret.isMathXlTarget(playerTarget)) {
                                return 'assessment-player.splash.instructions.mathxl.homework';
                            }
                            throw 'Unexpected type for playerTarget ' + playerTarget;
                        default:
                            return 'assessment-player.splash.instructions.default.test';
                    }
                };

                ret.getTestInstructionAudioURL = function(type) {
                    if (!type) {
                        return '';
                    }

                    // host app will set the locale on to the UXF.Common.i18n object
                    var localeDir = i18n.getLang().toLowerCase(),
                        audioFileRoot;
                    audioFileRoot = config('resourcesRoot') + '/audio/' + localeDir;

                    switch (type.toLowerCase()) {
                        case 'practice':
                            return audioFileRoot + '/practice_instructions.mp3';
                        case 'prep':
                            return audioFileRoot + '/prep_instructions.mp3';
                        case 'homework':
                            return '';
                            //TODO add audio for homework instructions when ready
                            //  return  audioFileRoot + '/homework_instructions.mp3';
                        default:
                            return audioFileRoot + '/test_instructions.mp3';
                    }
                };

                ret.isTestNavTarget = function(target) {
                    return target === 'testnav';
                };
                ret.isMathXlTarget = function(target) {
                    return target === 'mathxl';
                };
                ret.isNativeTarget = function(target) {
                    return angular.isUndefined(target) || target === '' || target === 'realize';
                };

                ret.isSplashPage = function(position) {
                    return position < 0;
                };

                ret.isSubmitPage = function(position, numQuestionIds) {
                    return position >= numQuestionIds;
                };

                ret.isQuestionPage = function(position, numQuestionIds) {
                    return !ret.isSplashPage(position) && !ret.isSubmitPage(numQuestionIds);
                };

                return ret;
            }
        ]);

        return factory;
    }
});
;/**
 * Wrapper for using the assessment player in non-angular js apps.
 *
 * Usage:
 * $(...).assessmentPlayer(opts);
 *
 * opts:
 * - sessionId  - the assessment session Id to play
 * - messageHandler - handler for displaying error messages
 * - tryAgainHandler - handler for displaying the try again message
 * - skipSplashScreen - should the splash screen be displayed
 *
 *
 * events:
 * - sessionTimedOut - notify the host app that an internal ajax request returned a 401 status
 **/
UXF.Module.define({
    name: 'UXF.AssessmentPlayer.Widget.Player',
    dependencies: ['jQuery.widget'],
    initArgs: ['angular', 'jQuery', 'UXF.AssessmentPlayer.Config', 'window', 'debug'],
    initFunc: function(angular, $, config, window, debug) {
        'use strict';

        var playerIndex = 1;

        $.widget('ui.assessmentPlayer', {
            options: {
                sessionId: null,
                messageHandler: null,
                tryAgainHandler: null,
                skipSplashScreen: false
            },

            _create: function() {
                var ngapp, player, moduleName;

                ngapp = $('*[ng-app]');
                if (ngapp.length > 0) {
                    throw new Error('Prefer the assessment-player directive to using the jQuery widget');
                }

                if (typeof angular === 'undefined') {
                    throw new Error('AngularJS is required.');
                }

                moduleName = this._generateController();

                debug.log('Initializing angular tags...');
                player = $('<div uxf-assessment-player/>')
                    .attr('session-id', '{{sessionId}}')
                    .attr('message-handler', 'messageHandler')
                    .attr('try-again-handler', 'tryAgainHandler')
                    .attr('skip-splash-screen', 'skipSplashScreen');
                this.element.append(player);

                this.element.attr('ng-controller', 'AssessmentServices.Player.Widget.Controller');

                debug.log('bootstrapping angularjs...');
                angular.bootstrap(this.element, [moduleName]);
            },

            updateAssessment: function(sessionId, skipSplash) {
                var self = this;

                this.options.sessionId = sessionId;
                this.options.skipSplashScreen = skipSplash;

                this.options.$scope.$apply(function() {
                    self.options.$scope.skipSplashScreen = skipSplash;
                    self.options.$scope.sessionId = sessionId;
                    self.element.find('[uxf-assessment-player]').attr('sessionId', this.options.sessionId);
                });
            },

            _generateController: function() {
                var self = this,
                    module,
                    name = 'AssessmentServices.Player.Widget' + this._getId();

                module = angular.module(name, ['AssessmentServices', 'Realize.core.directives.htmlUnsafe']);
                module.config(['$locationProvider', '$browserProvider', function($locationProvider, $browserProvider) {
                    // HACK!  Disable hash-change hijacking...  Not great
                    // that this tries to overload angular internals, but
                    // not sure if there is a good workaround...
                    var oldBrowserGet = $browserProvider.$get,
                        oldBrowserGetFn = oldBrowserGet[oldBrowserGet.length - 1],
                        oldLocationGet = $locationProvider.$get,
                        oldLocationGetFn = oldLocationGet[oldLocationGet.length - 1];

                    // override the default $browser impl to disable URL rewriting and
                    // listening for hash change events...  This is very very very
                    // very very very very horrible.  Stupid angular...  :-(
                    $browserProvider.$get = ['$window', '$log', '$sniffer', '$document',
                        function($window, $log, $sniffer, $document) {
                            var ret = oldBrowserGetFn($window, $log, $sniffer, $document);
                            // kill of the onUrlChange handler
                            ret.onUrlChange = function(newUrl) {
                                return;
                            };

                            // don't allow angular to set the URL
                            ret.url = function(val) {
                                if (val) {
                                    return;
                                }

                                return window.location.href.replace(/%27/g, '\'');
                            };
                            return ret;
                        }
                    ];

                    // override absUrl in the $location service so that it always
                    // returns the current browser url.  Otherwise, we end up with
                    // digest problems because it's trying to change it, but nothing
                    // actually changes...
                    $locationProvider.hashPrefix('');
                    $locationProvider.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
                        function($rootScope, $browser, $sniffer, $rootElement) {
                            var service = oldLocationGetFn($rootScope, $browser, $sniffer, $rootElement);
                            service.absUrl = function() {
                                return $browser.url();
                            };

                            return service;
                        }
                    ];
                }]);

                module.controller('AssessmentServices.Player.Widget.Controller', [
                    '$scope',
                    '$location',
                    function($scope, $location) {
                        self.options.$scope = $scope;

                        $scope.sessionId = self.options.sessionId;

                        if (self.options.messageHandler) {
                            $scope.messageHandler = function(data) {
                                self.options.messageHandler(data);
                            };
                        }

                        if (self.options.tryAgainHandler) {
                            $scope.tryAgainHandler = function(data) {
                                self.options.tryAgainHandler(data);
                            };
                        }

                        $scope.skipSplashScreen = self.options.skipSplashScreen;
                    }
                ]);

                module.config(function($httpProvider) {
                    var interceptObj = ['$rootScope', '$q', function(scope, $q) {
                        function success(response) {
                            return response;
                        }

                        function error(response) {
                            var status = response.status;
                            if (status === 401) {
                                // notify the host app that the session timed out.
                                self.element.trigger('sessionTimedOut', response.data);
                            }
                            return $q.reject(response);
                        }

                        return function(promise) {
                            return promise.then(success, error);
                        };
                    }];

                    $httpProvider.responseInterceptors.push(interceptObj);
                });

                module.run(['$rootScope', function($rootScope) {
                    $rootScope.$on('$locationChangeStart', function(e) {
                        e.preventDefault();
                        return false;
                    });
                }]);

                return name;
            },

            _getId: function() {
                return playerIndex++;
            }
        });
    }
});
;UXF.Module.define({
    name: 'UXF.Assessment.Services.AudioPlayerService',
    initArgs: [
        'jQuery',
        '_',
        'debug'
    ],
    initFunc: function($, _, debug) {
        'use strict';
        var config = {},
            api, jQuerySelector, _getExtension, _getMimeType;

        _getExtension = function(audioType) {
            switch (audioType ? audioType.toLowerCase() : '') {
                case 'audio/mp3':
                    return '.mp3';

                case 'audio/mp4':
                    return '.mp4';

                default:
                    return '';
            }
        };

        _getMimeType = function(audioType) {
            switch (audioType ? audioType.toLowerCase() : '') {
                case 'audio/mp3':
                    return 'audio/mp3';

                    // need to set the mime type for mp4 @see https://github.com/flowplayer/flowplayer/issues/52
                case 'audio/mp4':
                    return 'video/mp4';

                default:
                    return '';
            }
        };

        api = {
            /**
             * Initialize this service by passing in config parameters
             *
             * @param data - the configuration map. Following keys are supported
             *  1. jQuerySelector (String)- the jQuery selector of the element inside which to install
             * the audio player widget
             *  2. flowplayerRoot (String)- the web visible folder in the web app that contains flowplayer files
             *  2. contextPath (String) - the context path of the web application inside which assessment-ui is deployed
             */
            init: function(data) {
                _.extend(config, data);
                jQuerySelector = data.jQuerySelector || 'body';
            },

            /**
             * Create the audio player widget
             */
            createAudioPlayer: function() {
                $(jQuerySelector).audioplayer({
                    // the widget will throw an initialization error if this option is undefined  for non-html5 browsers
                    flowplayerRoot: config.flowplayerRoot
                });
            },

            /**
             * Play the audio by constructing the audio url from the given arguments.
             * Any existing clip being played will be paused first
             * before the audio obtained from the constructed url is played
             * e.g. play audio present in a question
             */
            play: function(audioType, audioId, audioAssessmentId) {
                var audioURL, contextPath, mimeType;

                if (audioId && audioAssessmentId) {
                    contextPath = config.contextPath;
                    if (_.isUndefined(contextPath)) {
                        debug.error('context path is undefined in assessment ui audio player service');
                        throw new Error('context path is undefined in assessment ui audio player service');
                    }
                    mimeType = _getMimeType(audioType);
                    audioURL = contextPath + '/assessment/' + audioAssessmentId + '/audio/' +
                        audioId + _getExtension(audioType) +
                        '?format=' + mimeType;
                    this.playAudioURL(audioType, audioURL);
                }
            },

            /**
             * Play the audio using the given url. Any existing clip being played will be paused first
             * before the audio obtained from the audio url is played
             * e.g. play the instruction present in the assessment player splash page
             */
            playAudioURL: function(audioType, audioURL) {
                var mimeType;
                mimeType = _getMimeType(audioType);
                debug.log('audioURL = ' + audioURL);
                $(jQuerySelector).audioplayer('init', {
                    audioURL: audioURL,
                    audioType: mimeType
                });

                $(jQuerySelector).audioplayer('play');
            },

            /**
             * Stop the currently playing clip. If there is no audio current being played, this api has no effect
             */
            stop: function() {
                try {
                    $(jQuerySelector).audioplayer('stop');
                } catch (e) {}
            }

        };

        return api;
    }
});
;UXF.Module.define({
    name: 'UXF.GriddedResponse.Models.ColumnCollection',
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.GriddedResponse.Models.ColumnModel'],
    initFunc: function($, Backbone, _, GRColumnModel) {
        'use strict';

        var GriddedResponseColumnCollection;

        GriddedResponseColumnCollection = Backbone.Collection.extend({
            missingColumnErrorKey: 'assessment-player.question.griddedresponse.missingcolumn',
            valueTooLongErrorKey: 'assessment-player.question.griddedresponse.toolong',
            invalidValueKey: 'assessment-player.question.griddedresponse.invalid',
            model: GRColumnModel,
            initialOffscreenValue: '',

            defaults: {
                boxes: 0, // number if digit boxes.  (not plusMinus or floating delim)
                delim: null,
                delimPosition: -1,
                currencySymbol: null,
                plusMinus: false,
                value: '',
                offscreenValue: ''
            },

            constructor: function(opts) {
                var columnIdx = 0, // 1-based index of columns added
                    data = {},
                    totalColumns = 0,
                    delimColumn = -1,
                    inputs = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

                this.options = $.extend({}, this.defaults, opts);
                totalColumns = this.options.boxes;

                Backbone.Collection.apply(this);

                /**
                /// Not this User Story, and will require updating the getValue and
                /// setValue functions unless it is part of the value we are testing for.
                if (this.options.currencySymbol) {
                    columns++;
                    data = {
                        fixed: true,
                        txtValue: this.options.currencySymbol,
                        txtValue: this.options.currencySymbol,
                        inputs: [this.options.currencySymbol]
                    };
                    this.add( GRColumnModel.newInstance(data, { columnNum: ++columnIdx }) );
                }
                **/

                if (this.options.plusMinus) {
                    totalColumns += 1;
                    columnIdx += 1;
                    data = {
                        inputs: ['+', '-']
                    };
                    this.add(GRColumnModel.newInstance(data, {
                        columnNum: columnIdx
                    }));

                }

                if (this.options.delim) {
                    /* NEEDS to be the LAST if-statement that increased the columns-variable size. */
                    totalColumns += 1;
                    if (this.options.delimPosition === -1) {
                        /* Add the delim at the start of the default inputs array. */
                        inputs.unshift(this.options.delim);
                    } else {
                        /* Set the relative-left column position. */
                        delimColumn = totalColumns - this.options.delimPosition;
                    }
                }

                while (columnIdx < totalColumns) {
                    columnIdx += 1;
                    if (columnIdx === delimColumn) {
                        data = {
                            fixed: true,
                            txtValue: this.options.delim,
                            optValue: this.options.delim,
                            inputs: [this.options.delim]
                        };
                    } else {
                        data = {
                            inputs: inputs
                        };
                    }

                    this.add(GRColumnModel.newInstance(data, {
                        columnNum: columnIdx
                    }));
                }

                if (this.options.value) {
                    this.setValue(this.options.value);
                } else if (this.options.rawValue) {
                    this.setRawValue(this.options.rawValue);
                }
            },

            setOffscreenValue: function(value) {
                this.options.offscreenValue = $.trim(value);
                this.trigger('change');
            },

            setValue: function(value) {
                this._setGridValue(value);
                this._initOffscreenValue(value);
            },

            _setGridValue: function(value) {
                if (value.length > this.models.length) {
                    throw this.valueTooLongErrorKey;
                }

                this._resetGrid();

                _.each(this.models, function(model, idx) {
                    model.setValue(value.substring(idx, idx + 1));
                });
            },

            _initOffscreenValue: function(value) {
                var trimmedValue = $.trim(value);

                this.options.offscreenValue = trimmedValue;
                this.initialOffscreenValue = trimmedValue;
                this.trigger('reset:offscreenValue', trimmedValue);
            },

            /**
             * Set the value for the grid.  Unlike setValue() which expects the
             * format of the value to line up with the grid, this method will
             * attempt to figure out how to layout the number to fit in the grid.
             * So, where setValue would expect something like '  12.34  ', for
             * a 6 box grid with a delim at position 4, this method will accept
             * '12.34' and attempt to fit the answer into the grid in the
             * most sensible way possible.
             *
             * It currently does not support currency symbol.
             *
             * @param value
             */
            setRawValue: function(value) {
                var plusMinusIndex = -1,
                    delimIndex = -1,
                    valueDelimIndex = -1,
                    left, right,
                    i, j,
                    start,
                    currentGridValue = this._getGridValue(),
                    fullValue = value;

                if (!value) {
                    return;
                }

                if (value.length > this.models.length) {
                    throw this.valueTooLongErrorKey;
                }

                try {
                    this._resetGrid();

                    this.each(function(model, index) {
                        var inputs;

                        if (model.get('fixed')) {
                            delimIndex = index;
                        }

                        inputs = model.get('inputs');
                        if (index === 0 && inputs.length === 2 && $.inArray('+', inputs) >
                            -1) {
                            plusMinusIndex = index;
                        }
                    });

                    // handle the plus/minus column first...
                    if (plusMinusIndex > -1) {
                        if (value[0] === '+' || value[0] === '-') {
                            this.at(plusMinusIndex).setValue(value[0]);
                            value = value.substring(1); // throw away the sign...
                        } else {
                            this.at(plusMinusIndex).setValue(' ');
                        }
                    }

                    // now that leading +/- has been handled, strip off unnecessary space...
                    value = $.trim(value);

                    // find the delimiter in the value...
                    if (this.options.delim) {
                        valueDelimIndex = value.indexOf(this.options.delim);
                    }

                    // no fixed delim, just fill bubbles from right to left
                    if (delimIndex === -1) {
                        j = value.length - 1;
                        for (i = this.size() - 1; i >= 0 && j >= 0; i--) {
                            this.at(i).setValue(value[j]);
                            j--;
                        }
                    } else {
                        if (valueDelimIndex >= 0) {
                            left = value.substring(0, valueDelimIndex);
                            right = value.substring(valueDelimIndex + 1);
                        } else {
                            left = value;
                            right = '';
                        }
                        // fill in the cols on the right side of the delim
                        start = delimIndex + 1;
                        for (i = 0; i < right.length; i++) {
                            this.at(start + i).setValue(right[i]);
                        }

                        // fill in the cols on the left side of the delim
                        start = delimIndex - left.length;
                        for (i = 0; i < left.length; i++) {
                            this.at(start + i).setValue(left[i]);
                        }
                    }

                    // if we get to here, value is valid, so update offscreen value
                    this._initOffscreenValue(fullValue);
                } catch (e) {
                    // since this method changes the text/radio buttons iteratively, if there's an error we
                    // want to reset back to the original values in the grid
                    this._setGridValue(currentGridValue);
                    throw this.invalidValueKey;
                }
            },

            getValue: function() {
                this._updateGridFromOffscreenValue();
                return this._getGridValue();
            },

            _updateGridFromOffscreenValue: function() {
                if (this.options.offscreenValue !== this.initialOffscreenValue) {
                    this.setRawValue(this.options.offscreenValue);
                }
            },

            _getGridValue: function() {
                var values = [];

                _.each(this.models, function(model, idx) {
                    values[idx] = model.getValidatedValue();
                });

                return values.join('');
            },

            /* Returns true if the grid value includes a digit or if the offscreen value includes
             * more than just the fixed column values. Otherwise returns false. */
            isEmpty: function() {
                var i,
                    fixedColumnsString = '',
                    offscreenValueWithoutSpaces = this.options.offscreenValue.replace(/\s/g, '');

                for (i = 0; i < this.models.length; i++) {
                    // make sure this isn't a fixed decimal
                    if (!this.models[i].get('fixed')) {
                        // if text or option has a value, then this is non-empty
                        if ($.trim(this.models[i].get('txtValue')) ||
                            this.models[i].get('optValue')) {
                            return false;
                        }
                    } else {
                        fixedColumnsString += this.models[i].get('txtValue');
                    }
                }

                if (offscreenValueWithoutSpaces && offscreenValueWithoutSpaces !==
                    fixedColumnsString) {
                    return false;
                }

                return true;
            },

            validate: function() {
                var msg = '',
                    value;

                // first try to set grid value from offline value
                try {
                    this._updateGridFromOffscreenValue();
                } catch (error) {
                    msg = error;
                }

                if (!msg) {
                    // validate columns
                    _.each(this.models, function(model, idx) {
                        if (!msg) {
                            msg = model.getValidationMsg();
                        }
                    });
                }

                // if columns are all valid, validate the full value
                if (!msg) {
                    value = this.getValue();

                    // ignore +/-
                    if (this.options.plusMinus) {
                        value = value.substring(1);
                    }

                    // ignore fixed decimal point
                    if (this.options.delim === '.' && this.options.delimPosition !== -1) {
                        value = value.split('.').join('');
                    }

                    // ignore leading and trailing spaces (i.e., columns with no entries)
                    value = $.trim(value);

                    // invalid if the value still contains any non-leading/-trailing spaces
                    if (value.length !== 0 && value.indexOf(' ') !== -1) {
                        msg = this.missingColumnErrorKey;
                    }
                }

                return msg;
            },

            _resetGrid: function() {
                this.each(function(m) {
                    m.setValue('');
                });
            }
        });

        GriddedResponseColumnCollection.newInstance = function(attrs) {
            return new GriddedResponseColumnCollection(attrs);
        };

        return GriddedResponseColumnCollection;
    }
});
;UXF.Module.define({
    name: 'UXF.GriddedResponse.Models.ColumnModel',
    initArgs: ['jQuery', 'Backbone', '_', 'debug'],
    initFunc: function($, Backbone, _, debug) {
        'use strict';

        var GriddedResponseColumn = Backbone.Model.extend({
            mismatchErrorKey: 'assessment-player.question.griddedresponse.mismatch',
            missingErrorKey: 'assessment-player.question.griddedresponse.missing',
            invalidErrorKey: 'assessment-player.question.griddedresponse.invalid',

            defaults: {
                fixed: false, // this is being used
                txtValue: '',
                optValue: '',
                // inputs is an array of values for the selection (and allowed values for validation)
                inputs: []
            },

            options: {
                columnNum: 0 // 1-based index of this column's position within the parent collection
            },

            /**
             * Throw exception if value is invalid (e.g., mismatch between text entry and selection).
             */
            getValidatedValue: function() {
                var validationMessage = this.getValidationMsg();

                if (validationMessage) {
                    throw validationMessage;
                }

                // if valid, txtValue and optValue must match, so we can just work with one of them
                // return space if there is no entered/selected value
                return (this.get('txtValue') || ' ');
            },

            /**
             * Return empty string for valid values or a specific validation error key
             */
            getValidationMsg: function() {
                var txtValue = $.trim(this.get('txtValue')),
                    optValue = this.get('optValue'),
                    inputs = this.get('inputs');

                // a fixed value is always valid
                if (this.get('fixed')) {
                    return '';

                // no value for both text value and option value is always valid
                } else if (!txtValue && !optValue) {
                    return '';

                // missing text value or option value is invalid
                } else if (!txtValue || !optValue) {
                    return this.missingErrorKey;

                // mismatched text and option values is invalid
                } else if (txtValue !== optValue) {
                    return this.mismatchErrorKey;

                // don't think this could happen, but values not in the allowed values array is invalid
                } else if ($.isArray(inputs) && $.inArray(txtValue, inputs) === -1) {
                    return this.invalidErrorKey;
                }

                return '';
            },

            /**
             * Throw exception if value is invalid (e.g., not in the allowed inputs array).
             */
            setValue: function(value) {
                var inputs = this.get('inputs'),
                    fixed = this.get('fixed');

                // space is equivalent to no entry/unselected
                if (value === ' ') {
                    value = '';
                }

                if (fixed && (!value || value === this.get('txtValue'))) {
                    return;
                }

                if (value && $.isArray(inputs) && $.inArray(value, inputs) === -1) {
                    throw this.invalidErrorKey;
                }

                this.set({'txtValue': value, 'optValue': value});
            }
        });

        GriddedResponseColumn.newInstance = function(attrs, opts) {
            var instance = new GriddedResponseColumn(attrs);
            instance.options = opts;
            return instance;
        };

        return GriddedResponseColumn;
    }
});
;UXF.Module.define({
    name: 'UXF.GriddedResponse.Views.ColumnCollectionView',
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.Common.CollectionView', 'UXF.GriddedResponse.Views.ColumnView'],
    initFunc: function($, Backbone, _, CollectionView, GRColumnView) {
        'use strict';

        var GriddedResponseCollectionView,
            template = [
                    '<div aria-hidden="true" role="presentation" class="uxf-griddedresponse-instructions">' +
                        '<%__ "gridded-response.instructions" %></div>',
                    '<div class="uxf-a11yOffScreen">',
                        '<label for="<%= id %>"><%__ "gridded-response.offscreen.answer.label" %></label>',
                        '<input id="<%= id %>" class="uxf-griddedresponse-offscreen-input" type="text" ' +
                            'value="<%= offscreenValue %>" maxlength="<%= maxLength %>"' +
                                '<% if (immutable) { %>disabled<% } %> tabindex="0" />',
                        '<a class="skip-gr-radio-bubble" href="javascript://">' +
                            '<%__ "gridded-response.offscreen.skipto.player.footer" %></a>',
                    '</div>',
                    '<div aria-hidden="true" role="presentation" ' +
                        'class="uxf-griddedresponse-response-container ' +
                        '<% if (useTallColumns) { %>uxf-griddedresponse-tall-column<% } %>" ></div>',
                    '<div style="clear:both;"></div>'
                ].join('');

        GriddedResponseCollectionView = CollectionView.extend({
            selectors: {
                container: '.uxf-griddedresponse-response-container',
                offscreenInput: '.uxf-griddedresponse-offscreen-input'
            },
            events: {
                'keyup .uxf-griddedresponse-offscreen-input': '_updateModelFromOffscreenInput',
                'click .skip-gr-radio-bubble': '_skipGriddedRadioBubble'
            },

            options: {
                viewClass: GRColumnView,
                viewName: 'GRColumnView',
                containerSelector: 'container',
                template: template,
                immutable: false,
                responseId: 0,
                boxes: 0,
                delim: null,
                delimPosition: -1,
                currencySymbol: null,
                plusMinus: false,
                value: ''
            },

            initialize: function() {
                if (!this.collection) {
                    throw 'GriddedResponseCollection is required';
                }

                this.listen(this.collection, 'reset:offscreenValue', this._setOffscreenInputValue, this);
            },

            _createView: function(model) {
                var options = {
                    immutable: this.options.immutable,
                    responseId: this.options.responseId,
                    boxes: this.options.boxes,
                    delim: this.options.delim,
                    delimPosition: this.options.delimPosition,
                    currencySymbol: this.options.currencySymbol,
                    plusMinus: this.options.plusMinus,
                    value: this.options.value
                };
                return CollectionView.prototype._createView.apply(this, [model, options]);
            },

            render: function() {
                var floatingDelim = (this.collection.options.delim && this.collection.options.delimPosition === -1);

                this._renderTemplate(this.viewTemplate, this.model, {
                        useTallColumns: floatingDelim,
                        offscreenValue: (this.collection.options.offscreenValue || ''),
                        maxLength: this.collection.length,
                        id: this.cid,
                        immutable: this.options.immutable
                    });

                this.renderChildren();

                return this;
            },

            setReadOnly: function(readOnly) {
                this.options.immutable = readOnly;
                _.each(this._viewMap, function(view, idx) {
                    view.setReadOnly(readOnly);
                });
            },

            _updateModelFromOffscreenInput: function() {
                this.collection.setOffscreenValue(this.$el.find(this.selectors.offscreenInput).val());
            },

            _setOffscreenInputValue: function(newValue) {
                this.$el.find(this.selectors.offscreenInput).val($.trim(newValue));
            },

            _skipGriddedRadioBubble: function(event) {
                var checkAnswer = $('.uxf-assessment-player-check:visible'),
                    prev = $('.uxf-prev');

                event.preventDefault();
                if (checkAnswer.length > 0) {
                    checkAnswer.focus();
                } else {
                    prev.focus();
                }
            }
        });

        GriddedResponseCollectionView.newInstance = function(parent, opts) {
            return new GriddedResponseCollectionView(parent, opts);
        };

        return GriddedResponseCollectionView;
    }
});
;UXF.Module.define({
    name: 'UXF.GriddedResponse.Views.ColumnView',
    initArgs: ['jQuery', 'Backbone', '_', 'UXF.Common.AbstractView'],
    initFunc: function($, Backbone, _, AbstractView) {
        'use strict';

        var GriddedResponseColumnView, baseTemplate, optionTemplate, fixedTemplate;

        baseTemplate = [
            '<div class="uxf-gr-column-text">',
                '<label for="<%= id %>" class="uxf-a11yOffScreen">' +
                    '<%__ "gridded-response.offscreen.answer.response.label" %></label>',
                '<input type="text" pattern="[0-9]*" maxlength="1" class="uxf-gr-column-text-input"' +
                    ' name="gr-text-<%= responseId %>-<%= columnNum %>" id="<%= id %>" value="<%= txtValue %>" />',
            '</div>',
            '<div class="uxf-gr-column-buttons"><%= optHtml %></div>'
        ].join('');

        fixedTemplate = [
            '<div class="uxf-gr-column-text"><%= fixedText %></div>',
            '<div class="uxf-gr-column-buttons"></div>'
        ].join('');

        optionTemplate = [
            '<div  class="uxf-gr-column-option<%= checkedClass %>">',
                '<input type="radio" class="uxf-gr-column-option-radio" role="group" ' +
                    'name="<%= name %>" id="<%= id %>" value="<%= value %>"<%= checkedAttr %> />',
                '<label for="<%= id %>" onclick=" "><%= label %></label>',
                //TODO: For audio-based accessibility, we may need to change the existing label to a span,
                // and create a new label with a value of 'Column # <%= columnNum %>, Value <%= value %>';
                // this label would then also be "hidden" just like the input so it didn't show on screen.
            '</div>'
        ].join('');

        GriddedResponseColumnView = AbstractView.extend({
            className: 'uxf-gr-column uxf-gr-not-read-only',
            templates: {
                base: baseTemplate,
                fixed: fixedTemplate,
                option: optionTemplate
            },
            options: {
                responseId: 0,
                immutable: false,
                labelReplacement: {
                    '.': '&middot;'
                }
            },
            selectors: {
                column: '.uxf-gr-column',
                columnText: '.uxf-gr-column-text',
                columnTextInput: '.uxf-gr-column-text-input',
                columnButtons: '.uxf-gr-column-buttons',
                columnOption: '.uxf-gr-column-option',
                columnOptionInput: '.uxf-gr-column-option-radio',
                columnOptionInputChecked: '.uxf-gr-column-option-radio:checked',
                columnOptionSelected: '.uxf-gr-column-option-selected',
                columnFixed: '.uxf-gr-column-fixed'
            },

            events: {
                'focusin .uxf-gr-column-option': '_focusIn',
                'focusout .uxf-gr-column-option': '_focusOut',
                'hover .uxf-gr-column-option': '_toggleHover',
                'keypress .uxf-gr-column-text-input': '_textChanged',
                //The keypress event most-often replaces the keyup event, so just combined their code.
                'keydown .uxf-gr-column-text-input': '_keyDown', //don't replace with the 'change' event
                'click .uxf-gr-column-option-radio': '_optionSelected'
            },

            initialize: function() {
                this.listen(this.model, 'change:txtValue', this._setTextInput, this);
                this.listen(this.model, 'change:optValue', this._setOptionInput, this);
            },

            render: function() {
                var template, data;
                if (this.model.get('fixed')) {
                    this.$el.addClass('uxf-gr-column-fixed');
                    template = this.templates.fixed;
                    data = { fixedText: this.model.get('txtValue') };
                } else {
                    template = this.templates.base;
                    data = {
                        responseId: this.options.responseId,
                        columnNum: this.model.options.columnNum,
                        txtValue: this.model.get('txtValue'),
                        id: 'uxf-gr-radio-' + this.cid,
                        optHtml: this._buildOptionHtml()
                    };
                }
                this.$el.html(template(data));
                this._setRadioInputTabIndexes();
                this.setReadOnly(this.options.immutable);
                return this;
            },

            /**
             * Event handler for keydown which is fired before the keypress event.
             * The keydown event is fired on all browsers for both
             * character and special keys
             *
             * http://msdn.microsoft.com/en-us/magazine/ff928319.aspx
             *
             */
            _keyDown: function(e) {

                var which = e.which, deletionKeysAllowed = [8, 46];// Backspace and Delete
                // debug.log('_keydown fired which='  + which);

                // Note -  For keydown and keyup events, the keycodes are not character codes,
                // and the String.fromCharCode(event.keyCode)
                // conversion will give wild results for many keys.
                if (!this.options.immutable && ($.inArray(which, deletionKeysAllowed) !== -1)) {
                    // case when the key  pressed is for deleting the text box value

                    this.model.set('txtValue', '');
                    // the backspace key was causing the previous web page to load in IE8
                    e.preventDefault();
                }
            },

            /**
             * Event handler for keypress which is fired:
             * 1. only for character keys in IE, Chrome, and Safari
             * 2. for both character keys and special keys in FF
             */
            _textChanged: function(e) {
                var which = e.which,
                    value = which ? String.fromCharCode(which) : $(e.currentTarget).val(),
                    // The above param conditional for situations where the function is externally
                    // triggered to updated; like Jasmine

                    // we will bubble up the key press event only for these special keys
                    // Possible special keys allowed : [8, 9, 16, 37, 39, 46] =>
                    // [Backspace, Tab, Shift, Arrow Left, Arrow Right, Delete]
                    specialKeysAllowed = [8, 9, 16, 37, 39, 46];

                // debug.log(' which=' + which + ", value = "  + value + ", e.charCode= " + e.charCode + ',
                // e.keyCode = ' + e.keyCode);
                if ($.inArray(value, this.model.get('inputs')) === -1) {
                    // check if the key is one of the special keys (for FF) or some character key
                    // whose charcode is the same as one of
                    // the allowed special keys e.g. '%'  has keycode 37 on all browsers and charcode 37 except IE8
                    // http://blog.pothoven.net/2008/05/keydown-vs-keypress-in-javascript.html
                    // note that the value obtained from String.fromCharCode(which) for Delete key is '.'. However,
                    // the keycode for Delete key is 46 and the keycode for decimal point is 190 on all browsers
                    // http://blog.pothoven.net/2008/05/keydown-vs-keypress-in-javascript.html
                    // In IE8:  e.keyCode and e.which will return the ASCII code.
                    // In Chrome:  e.keyCode, e.charCode and e.which will return the ASCII code.
                    // In Safari:  e.keyCode, e.charCode and e.which will return the ASCII code.
                    // In Firefox : for normal characters e.which and e.charCode will return the ASCII code and
                    // e.keyCode will return 0, and for special characters e.keyCode will return the keyboard code,
                    // and e.which and e.charCode will return 0 but for Backspace, e.which and e.keyCode will return
                    // the keyboard code (8) and e.charCode will return 0
                    which = which || e.keyCode;
                    // debug.log(' which=' + which + ", 0 !== e.charCode = "  + (0 !== e.charCode));
                    if (($.inArray(which, specialKeysAllowed) === -1) || ('%' === value) || ('.' === value)) {
                        // debug.log ('event prevented');
                        e.preventDefault();
                    }

                } else if (!this.options.immutable) {
                    // the pressed key is for one of the allowed input for this column
                    this.model.set('txtValue', value);
                }
            },

            _optionSelected: function(e) {
                var curValue = this.model.get('optValue'),
                    newValue = $(e.currentTarget).val();

                if (!this.options.immutable) {
                    newValue = (newValue === curValue ? '' : newValue);
                    this.model.set('optValue', newValue);
                }
            },

            _setTextInput: function() {
                this.$el.find(this.selectors.columnTextInput).val(this.model.get('txtValue'));
            },
            _setOptionInput: function() {
                var value = this.model.get('optValue');
                this.$el.find(this.selectors.columnOptionInput).each(function() {
                    var radio = $(this);
                    if (radio.val() === value) {
                        radio.attr('checked', 'checked');
                        radio.parent().addClass('uxf-gr-column-option-selected');
                    } else {
                        radio.removeAttr('checked');
                        radio.parent().removeClass('uxf-gr-column-option-selected');
                    }
                });
                this._setRadioInputTabIndexes();
            },

            _focusIn: function(e) {
                $(e.currentTarget).addClass('uxf-gr-column-option-focus');
            },
            _focusOut: function(e) {
                $(e.currentTarget).removeClass('uxf-gr-column-option-focus');
            },
            _toggleHover: function(e) {
                $(e.currentTarget).toggleClass('uxf-gr-column-option-hover');
            },

            _buildOptionHtml: function() {
                var self = this,
                    newHtml = [];
                $.each(this.model.get('inputs'), function(index, value) {
                    var template = self.templates.option,
                        data = {
                            id: 'uxf-gr-radio-' + self.cid + '-' + self.options.responseId + '-' +
                                self.model.options.columnNum + '-' + index,
                            name: 'uxf-gr-radio-' + self.cid + '-' + self.options.responseId + '-' +
                                 self.model.options.columnNum,
                            //columnNum: self.model.options.columnNum,
                            value: value,
                            label: (self.options.labelReplacement[value] || value),
                            checkedClass: '', checkedAttr: ''
                        };
                    if (self.model.get('optValue') === value) {
                        data.checkedAttr = ' checked';
                        data.checkedClass = ' uxf-gr-column-option-selected';
                    }
                    newHtml.push(template(data));
                });
                return newHtml.join('');
            },

            _setRadioInputTabIndexes: function() {
                var checked = this.$el.find(this.selectors.columnOptionInput + ':checked');
                this.$el.find(this.selectors.columnOptionInput).attr('tabindex', '-1').attr('aria-checked', 'false');
                if (0 < checked.length) {
                    checked.attr('aria-checked', 'true');
                } else {
                    checked = this.$el.find(this.selectors.columnOptionInput + ':first');
                }
                checked.attr('tabindex', '0');
            },

            setReadOnly: function(readOnly) {
                this.options.immutable = readOnly;
                if (this.options.immutable) {
                    this.$el.find('input').attr('disabled', 'disabled');
                    this.$el.removeClass('uxf-gr-not-read-only');
                } else {
                    this.$el.find('input').removeAttr('disabled');
                }
            }
        });

        GriddedResponseColumnView.newInstance = function(parent, opts) {
            return new GriddedResponseColumnView(parent, opts);
        };

        return GriddedResponseColumnView;
    }
});
;UXF.Module.define({
    name: 'UXF.GriddedResponse.Widget.GriddedResponse',
    dependencies: ['jQuery.widget'],
    initArgs: [
        'jQuery',
        'debug',
        'UXF.GriddedResponse.Models.ColumnCollection',
        'UXF.GriddedResponse.Views.ColumnCollectionView'
    ],
    initFunc: function($, debug, ColumnCollection, ColumnCollectionView) {
        'use strict';

        $.widget('ui.griddedResponse', {
            defaults: {
                immutable: false,
                boxes: null,
                delim: null,
                delimPosition: null,
                currencySymbol: null,
                plusMinus: null,
                value: null,
                rawValue: null
            },

            _create: function() {
                this.options.griddedResponseLayout = $.extend({}, this.defaults, this.options);

                this._initialize();
            },

            init: function(griddedResponseLayout) {
                this.options.griddedResponseLayout = $.extend({}, this.defaults, griddedResponseLayout);

                this._initialize();
            },

            _initialize: function() {
                this._columnCollection = ColumnCollection.newInstance(this.options.griddedResponseLayout);
                this._columnCollectionView = ColumnCollectionView.newInstance(null, {
                    el: this.element,
                    collection: this._columnCollection,
                    options: {
                        immutable: this.options.griddedResponseLayout.immutable
                    }
                });
                if (this.options.griddedResponseLayout.immutable) {
                    this.setReadOnly(this.options.griddedResponseLayout.immutable);
                }

                this._columnCollection.bind('change', this._modelChange, this);
                if (this.options.rawValue) {
                    this._columnCollection.setRawValue(this.options.rawValue);
                }

                this._columnCollectionView.render();

                // calls event immediately to set correct default
                this._modelChange();
            },

            _modelChange: function() {
                var isEmpty;

                isEmpty = this._columnCollection.isEmpty();
                this._trigger('response:change', null, {
                    isEmpty: isEmpty
                });
            },

            /** Destroys the gridded response */
            destroy: function() {
                $.Widget.prototype.destroy.call(this);
                this._columnCollection.unbind('change', this._modelChange);
                this._columnCollectionView.destroy();
            },

            /**
             * Set value of gridded response.
             *
             * @param value string
             */
            setValue: function(value) {
                this._columnCollection.setValue(value);
                this._modelChange();
            },

            /**
             * Get value of gridded response. Throws error if value is invalid.
             *
             * @return string
             */
            getValue: function() {
                return this._columnCollection.getValue();
            },

            isAnswered: function() {
                return !this._columnCollection.isEmpty();
            },

            /**
             * Set value of gridded response.
             *
             * @param readOnly boolean
             */
            setReadOnly: function(readOnly) {
                this.options.immutable = readOnly;
                this._columnCollectionView.setReadOnly(this.options.immutable);
            },

            /**
             * Returns the first error encountered looping left to right through the gridded
             * response columns:
             *
             * 'assessment-player.question.griddedresponse.missing': user has entered a text value,
             * but hasn't selected a 'bubble' value, or vice versa
             *
             * 'assessment-player.question.griddedresponse.mismatch': user has entered a text value
             * that doesn't match the selected 'bubble' value
             *
             * 'assessment-player.question.griddedresponse.invalid': the user entered text value
             * matches the selected 'bubble' value but is not one of the allowed values (THIS SHOULD
             * NEVER HAPPEN)
             *
             * '': all gridded response columns have valid values
             *
             * @return string
             */
            validate: function() {
                return this._columnCollection.validate();
            }
        });

        return $.fn.griddedResponse;
    }
});
;UXF.Module.define({
    name: 'UXF.AssessmentBuilder.Templates',
    initArgs: [],
    initFunc: function() {
        "use strict";

        var templates = {};

                templates["assessment-summary-view.edit"] = "<div class=\"uxf-summary-edit-mode\"><div class=\"uxf-summary\"><div id=\"uxf-edit-title-container\"><div class=\"uxf-assessment-summary-quicklinks\"></div></div><div class=\"uxf-notification uxf-notification-error uxf-notification-message\"></div><% if (typeof id === \"undefined\" || !id) { %><div class='uxf-step-instructions'><%__ \"assessment-builder.summary.create-test\" %></div><% } %><div class=\"uxf-form-field-container\"><label class=\"uxf-assessment-summary-label\" for=\"uxf-assessment-title\"><%__ \"assessment-builder.summary.title-label\" %></label><input id=\"uxf-assessment-title\" type=\"text\" value=\"<%- assetTitle %>\" maxlength=\"75\"/><span class=\"uxf-field-validation-error\"></span></div><div class=\"uxf-form-field-container\"><label class=\"uxf-assessment-summary-label\" for=\"uxf-assessment-description\"><%__ \"assessment-builder.summary.description-label\" %></label><textarea id=\"uxf-assessment-description\" maxlength=\"250\"><%- assetDescription %></textarea><span class=\"uxf-field-validation-error\"></span></div><% if (includeExtendedHeader) { %><div class=\"uxf-form-field-container uxf-summary-mastery\"><div><span class=\"uxf-label\"><%__ \"assessment-builder.summary.mastery-label\" %></span><span class=\"uxf-field-validation-error\"></span></div><span><%__ \"assessment-builder.summary.mastery-info\" %></span><span class=\"uxf-a11yOffScreen\" id=\"mastery-option-id\"><%__ \"assessment-builder.summary.mastery-info.mastry-type\" %></span><div class=\"uxf-radio-group clearfix\" role=\"radiogroup\" aria-labelledby=\"mastery-option-id\"><div class=\"uxf-radio-wrapper\"><input type=\"radio\" name=\"mastery\" value=\"true\" id=\"uxf-mastery-yes\"><label for=\"uxf-mastery-yes\"><%__ \"assessment-builder.summary.mastery.yes\" %></label></div><div class=\"uxf-radio-wrapper\"><input type=\"radio\" name=\"mastery\" value=\"false\" id=\"uxf-mastery-no\"><label for=\"uxf-mastery-no\"><%__ \"assessment-builder.summary.mastery.no\" %></label></div></div></div><% if (allowTestTypeUpdate) { %><div class=\"uxf-form-field-container uxf-summary-type\"><div><span class=\"uxf-label\"><%__ \"assessment-builder.summary.type-label\" %></span><span class=\"uxf-field-validation-error\"></span></div><span class=\"uxf-a11yOffScreen\" id=\"test-type-id\"><%__ \"assessment-builder.summary.type.test.type\" %></span><div class=\"uxf-radio-group clearfix\" role=\"radiogroup\" aria-labelledby=\"test-type-id\"><div class=\"uxf-radio-wrapper\"><input type=\"radio\" value=\"TEST\" name=\"test-type\" id=\"uxf-type-test\"><label for=\"uxf-type-test\"><%__ \"assessment-builder.summary.type.test\" %></label></div><div class=\"uxf-radio-wrapper\"><input type=\"radio\" value=\"PRACTICE\" name=\"test-type\" id=\"uxf-type-practice\"><label for=\"uxf-type-practice\"><%__ \"assessment-builder.summary.type.practice\" %></label></div><div class=\"uxf-radio-wrapper\"><input type=\"radio\" value=\"PREP\" name=\"test-type\" id=\"uxf-type-prep\"><label for=\"uxf-type-prep\"><%__ \"assessment-builder.summary.type.prep\" %></label></div></div></div><% } } %></div></div>";
                templates["reorder-collection-view"] = "<ul class=\"uxf-reorder-list\"></ul>";
                templates["assessment-builder-view"] = "<div class=\"uxf-assessment-builder <% if (isReadOnly) { %>uxf-read-only<% } %>\"><div class='uxf-body'></div><div class=\"uxf-assessment-builder-audio\"></div></div>";
                templates["question-bank-item-view"] = "<div class=\"uxf-item-row uxf-table-display uxf-qbank-item <%= isImported ? 'uxf-qbank-imported' : '' %>\"><div class=\"uxf-item-cell uxf-qbank-selector\"><input value=\"<%= assessmentId %>\" id='check-<%= assessmentId %>' type=\"checkbox\" <%= (isChecked || isImported) ? \"checked\" : \"\" %><%= isImported ? ' disabled=\"disabled\"' : '' %>/><label for='check-<%= assessmentId %>'></label></div><div class=\"uxf-item-cell uxf-qbank-image\"><img src=\"<%= thumbnailUrl %>\" alt=\"\"/></div><div class='uxf-item-cell uxf-qbank-success'><div class='uxf-qbank-success-row'><i class='icon-ok-sign'></i><span><%__ \"assessment-builder.question-banks.success\" %></span></div><div class=\"uxf-qbank-title\"><%- title %></div><div class=\"uxf-qbank-description\"><%= description %></div></div><div class=\"uxf-item-cell uxf-qbank-details\"><div class=\"uxf-qbank-title\"><%- title %></div><div class=\"uxf-qbank-question-types\"><span class=\"uxf-qbank-qtype\"><span class=\"uxf-qbank-qtype-count uxf-qbank-count-mc\"><%= multipleChoiceCount %></span><span class=\"uxf-qbank-qtype-name\"><%__ \"assessment-builder.question-banks.multiple-choice\" %></span></span><span class=\"uxf-qbank-qtype\"><span class=\"uxf-qbank-qtype-count uxf-qbank-count-gr\"><%= griddedResponseCount %></span><span class=\"uxf-qbank-qtype-name\"><%__ \"assessment-builder.question-banks.gridded-response\" %></span></span></div><div class=\"uxf-qbank-description\"><%= description %></div></div></div>";
                templates["question-collection-view"] = "<div class=\"uxf-question-list\"></div><div class=\"uxf-add-items-from-bank\"></div><div class=\"uxf-add-question-dropdown\"></div><div class=\"uxf-questions-zeroState\"><div class=\"uxf-add-question all-types\"><%__ \"assessment-builder.question.zeroState.action.add.question\" %></div><div class=\"uxf-add-question no-qb\"><%__ \"assessment-builder.question.zeroState.action.add.question.no.questionBanks\" %></div><div class=\"uxf-add-question qb-only\"><%__ \"assessment-builder.question.zeroState.action.add.question.questionBanks.only\" %></div></div>";
                templates["assessment-builder-layout"] = "<div class=\"uxf-assessment-builder-instruction\"></div><div class=\"uxf-assessment-builder-header\"></div><div class=\"uxf-assessment-builder-content\"></div><div class=\"uxf-assessment-builder-footer\"></div><div class=\"uxf-assessment-builder-instruction-no-text\"></div>";
                templates["question-banks"] = "<div class='uxf-question-bank-list'><div class='uxf-question-bank-header'><span class='uxf-question-bank-instructions'><%__ \"assessment-builder.question-banks.instructions\" %></span><div class='uxf-question-bank-buttons'></div><br style='clear: both'/></div><div class='uxf-question-banks'></div><div class='uxf-question-banks-pager'></div><div class='uxf-question-bank-footer'><div class='uxf-question-bank-buttons'></div><br style='clear: both'/></div></div>";
                templates["instruction-bar-view"] = "<div class=\"uxf-instruction-container\"><span class=\"uxf-instruction-text\"></span><div class=\"uxf-instruction-nav-buttons .uxf-button-group\"><button class=\"uxf-button uxf-instruction-cancel-button secondary\"><%__ \"assessment-builder.instruction-bar.cancel\" %></button><button class=\"uxf-button uxf-instruction-done-button\"><%__ \"assessment-builder.instruction-bar.done\" %></button></div></div>";
                templates["assessment-summary-view.view"] = "<div class=\"uxf-summary-view-mode\"><div class=\"uxf-summary\"><div id=\"uxf-edit-title-container\"></div><div class=\"uxf-assessment-summary-quicklinks\"></div><div class=\"uxf-summary-item\"><span class=\"uxf-assessment-summary-label\"><%__ \"assessment-builder.summary.title-label\" %></span><span id=\"uxf-assessment-title\"><%- assetTitle %></span></div><div class=\"uxf-summary-item\"><span class=\"uxf-assessment-summary-label\"><%__ \"assessment-builder.summary.description-label\" %></span><span id=\"uxf-assessment-description\"><%- assetDescription %></span></div><% if (includeExtendedHeader) { %><div class=\"uxf-summary-item\"><span class=\"uxf-assessment-summary-label\"><%__ \"assessment-builder.summary.mastery-label\" %></span><span id=\"uxf-assessment-mastery\"></span></div><div class=\"uxf-summary-item\"><span class=\"uxf-assessment-summary-label\"><%__ \"assessment-builder.summary.type-label\" %></span><span id=\"uxf-assessment-type\"></span></div><% } %></div></div>";
        
        return templates;
    }
});
;/*
 * Copyright 2013, Pearson Education, Learning Technology Group
 *
 * assessmentaudio-package.js
 */

/*global UXF */

(function(UXF) {
    "use strict";

    UXF.Module.loadAll([
        'UXF.Assessment.Services.AudioPlayerService'
    ]);
} (UXF));
;/*
 * Copyright 2012, Pearson Education, Learning Technology Group
 *
 * griddedresponse-package.js
 */

/*global UXF */


(function(UXF) {
    "use strict";

    UXF.Module.loadAll([
        'UXF.GriddedResponse.Models.ColumnModel',
        'UXF.GriddedResponse.Models.ColumnCollection',

        'UXF.GriddedResponse.Views.ColumnView',
        'UXF.GriddedResponse.Views.ColumnCollectionView',

        'UXF.GriddedResponse.Widget.GriddedResponse'
    ]);
} (UXF));
;/*
 * Copyright 2012, Pearson Education, Learning Technology Group
 *
 * assessmentbuilder-package.js
 */

/*global UXF, angular */

(function(UXF, angular) {
    "use strict";

    UXF.Module.loadAll([
        'UXF.AssessmentBuilder.Templates',
        'UXF.AssessmentBuilder.Constants',
        'UXF.AssessmentBuilder.Config',
        'UXF.AssessmentBuilder.DialogUtil',
        'UXF.AssessmentBuilder.Services.Builder',
        'UXF.AssessmentBuilder.Models.ResponseModel',
        'UXF.AssessmentBuilder.Models.ResponseCollection',
        'UXF.AssessmentBuilder.Models.SkillModel',
        'UXF.AssessmentBuilder.Models.SkillCollection',
        'UXF.AssessmentBuilder.Models.QuestionModel',
        'UXF.AssessmentBuilder.Models.QuestionCollection',
        'UXF.AssessmentBuilder.Models.AssessmentModel',
        'UXF.AssessmentBuilder.Models.QuestionBanksItemModel',
        'UXF.AssessmentBuilder.Models.QuestionBanksCollection',
        'UXF.AssessmentBuilder.Models.QuestionBanksModel',
        'UXF.AssessmentBuilder.Views.SkillView',
        'UXF.AssessmentBuilder.Views.SkillCollectionView',
        'UXF.AssessmentBuilder.Views.ResponseView',
        'UXF.AssessmentBuilder.Views.GriddedResponseView',
        'UXF.AssessmentBuilder.Views.ResponseProxyView',
        'UXF.AssessmentBuilder.Views.XmlQuestionView',
        'UXF.AssessmentBuilder.Views.AccordionView',
        'UXF.AssessmentBuilder.Views.InstructionView',
        'UXF.AssessmentBuilder.Views.InstructionBarView',
        'UXF.AssessmentBuilder.Views.DropdownView',
        'UXF.AssessmentBuilder.Views.QuestionView',
        'UXF.AssessmentBuilder.Views.GriddedResponseEditLayoutView',
        'UXF.AssessmentBuilder.Views.QuestionProxyView',
        'UXF.AssessmentBuilder.Views.QuestionCollectionView',
        'UXF.AssessmentBuilder.Views.AssessmentSummaryView',
        'UXF.AssessmentBuilder.Views.QuestionRowView',
        'UXF.AssessmentBuilder.Views.ReorderCollectionView',
        'UXF.AssessmentBuilder.Views.EditAssessmentView',
        'UXF.AssessmentBuilder.Views.CreateAssessmentView',
        'UXF.AssessmentBuilder.Views.ReorderView',
        'UXF.AssessmentBuilder.Views.QuestionBankItemView',
        'UXF.AssessmentBuilder.Views.QuestionBanksView',
        'UXF.AssessmentBuilder.Views.AssessmentBuilderView',
        'UXF.AssessmentBuilder.Views.PrintView',
        'UXF.AssessmentBuilder.Widget.AssessmentBuilder',
        'UXF.AssessmentBuilder.Directives.AssessmentBuilder'
    ]);
} (UXF, angular));
;/*
 * Copyright 2012, Pearson Education, Learning Technology Group
 *
 * assessmentplayer-package.js
 */

/*global angular */

(function(UXF, angular) {
    "use strict";

    UXF.Module.loadAll([
        'UXF.AssessmentPlayer.Config',
        'UXF.AssessmentPlayer.Filters.i18n',
        'UXF.AssessmentPlayer.Filters.trunc',
        'UXF.AssessmentPlayer.Paf',
        'UXF.AssessmentPlayer.Services.PlayerService',
        'UXF.AssessmentPlayer.Services.ItemPlayerService',
        'UXF.AssessmentPlayer.Services.ActivityPlayerLoader',
        'UXF.AssessmentPlayer.Services.ActivityManager',
        'UXF.AssessmentPlayer.Services.Helpers.BrowserUtil',
        'UXF.AssessmentPlayer.Services.Helpers.HeightUtil',
        'UXF.AssessmentPlayer.Services.NativeQuestionCommonService',
        'UXF.AssessmentPlayer.Directives.AudioPlayer',
        'UXF.AssessmentPlayer.Directives.Splash',
        'UXF.AssessmentPlayer.Directives.NativeQuestion',
        'UXF.AssessmentPlayer.Directives.Question',
        'UXF.AssessmentPlayer.Directives.QuestionReview',
        'UXF.AssessmentPlayer.Directives.QuestionPreview',
        'UXF.AssessmentPlayer.Directives.ReportItemPlayer',
        'UXF.AssessmentPlayer.Directives.ReportNative',
        'UXF.AssessmentPlayer.Directives.ReportSkills',
        'UXF.AssessmentPlayer.Directives.Submit',
        'UXF.AssessmentPlayer.Directives.Player',
        'UXF.AssessmentPlayer.Widget.Player'
    ]);

    //  everything is loaded...  build our toplevel module...
    angular.module('AssessmentServices.Player', [
        'ngAnimate',
        'AssessmentServices.Player.Filters.i18n',
        'AssessmentServices.Player.Filters.trunc',
        'AssessmentServices.Player.Services.Player',
        'AssessmentServices.Player.Services.ItemPlayer',
        'AssessmentServices.Player.Services.ActivityPlayerLoader',
        'AssessmentServices.Player.Services.ActivityManager',
        'AssessmentServices.Player.Services.Helpers.BrowserUtil',
        'AssessmentServices.Player.Services.Helpers.HeightUtil',
        'AssessmentServices.Player.Services.NativeQuestionCommonService',
        'AssessmentServices.Player.Directives.Player',
        'AssessmentServices.Player.Directives.Splash',
        'AssessmentServices.Player.Directives.NativeQuestion',
        'AssessmentServices.Player.Directives.Question',
        'AssessmentServices.Player.Directives.QuestionReview',
        'AssessmentServices.Player.Directives.QuestionPreview',
        'AssessmentServices.Player.Directives.AudioPlayer',
        'AssessmentServices.Player.Directives.Submit',
        'AssessmentServices.Player.Directives.ReportItemPlayer',
        'AssessmentServices.Player.Directives.ReportNative',
        'AssessmentServices.Player.Directives.ReportSkills'
    ]);
} (UXF, angular));
;/*
 * Copyright 2012, Pearson Education, Learning Technology Group
 *
 * assessmentservices-package.js
 */

/*globals angular */


(function(angular) {
    "use strict";

    angular.module('AssessmentServices', [
            'AssessmentServices.Player',
            'AssessmentServices.Builder.Directives.Builder'
    ]);
} (angular));
